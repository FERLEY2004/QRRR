{
    "sourceFile": "control-acceso-sena/frontend/src/components/scanner/CameraOptimized.jsx",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 16,
            "patches": [
                {
                    "date": 1764022678785,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764022924658,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -18,9 +18,9 @@\n   const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n \n   const defaultConfig = {\n     fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n-    qrbox: { width: 200, height: 200 }, // Reducido para que quepa completamente en la vista\n+    qrbox: { width: 180, height: 180 }, // Reducido para que quepa completamente sin scroll\n     aspectRatio: 1.0,\n     videoConstraints: {\n       facingMode: 'environment',\n       width: { ideal: 1280 },\n@@ -392,9 +392,9 @@\n     );\n   }\n \n   return (\n-    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n+    <div className=\"relative w-full bg-gray-100 rounded-lg overflow-hidden\" style={{ maxHeight: 'calc(100vh - 300px)', aspectRatio: '16/9' }}>\n       <div \n         id={scannerId} \n         ref={containerRef}\n         className=\"w-full h-full\"\n@@ -424,9 +424,9 @@\n \n       {/* Overlay de escaneo */}\n       {cameraState === 'ready' && (\n         <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\n-          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\n+          <div className=\"border-4 border-blue-500 rounded-lg w-40 h-40 md:w-44 md:h-44 lg:w-48 lg:h-48 animate-pulse\" style={{ maxWidth: 'min(60%, 200px)', maxHeight: 'min(60%, 200px)' }}></div>\n         </div>\n       )}\n     </div>\n   );\n"
                },
                {
                    "date": 1764023058062,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,10 +17,10 @@\n   const containerRef = useRef(null);\n   const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n \n   const defaultConfig = {\n-    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n-    qrbox: { width: 180, height: 180 }, // Reducido para que quepa completamente sin scroll\n+    fps: 30, // Optimizado para mejor rendimiento\n+    qrbox: { width: 250, height: 250 }, // Área de escaneo optimizada para mejor detección\n     aspectRatio: 1.0,\n     videoConstraints: {\n       facingMode: 'environment',\n       width: { ideal: 1280 },\n@@ -392,13 +392,14 @@\n     );\n   }\n \n   return (\n-    <div className=\"relative w-full bg-gray-100 rounded-lg overflow-hidden\" style={{ maxHeight: 'calc(100vh - 300px)', aspectRatio: '16/9' }}>\n+    <div className=\"relative w-full bg-gray-100 rounded-lg overflow-hidden\" style={{ maxHeight: 'calc(100vh - 300px)', aspectRatio: '16/9', minHeight: '300px' }}>\n       <div \n         id={scannerId} \n         ref={containerRef}\n         className=\"w-full h-full\"\n+        style={{ position: 'relative' }}\n       />\n       \n       {cameraState === 'checking' && (\n         <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\n"
                },
                {
                    "date": 1764023135519,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,15 +17,15 @@\n   const containerRef = useRef(null);\n   const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n \n   const defaultConfig = {\n-    fps: 30, // Optimizado para mejor rendimiento\n-    qrbox: { width: 250, height: 250 }, // Área de escaneo optimizada para mejor detección\n+    fps: 10, // Reducido para mejor rendimiento y menor latencia\n+    qrbox: { width: 250, height: 250 }, // Área de escaneo optimizada\n     aspectRatio: 1.0,\n     videoConstraints: {\n       facingMode: 'environment',\n-      width: { ideal: 1280 },\n-      height: { ideal: 720 }\n+      width: { ideal: 640 }, // Reducido para procesamiento más rápido\n+      height: { ideal: 480 }\n     },\n     ...config\n   };\n \n"
                },
                {
                    "date": 1764023265495,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,15 +17,15 @@\n   const containerRef = useRef(null);\n   const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n \n   const defaultConfig = {\n-    fps: 10, // Reducido para mejor rendimiento y menor latencia\n-    qrbox: { width: 250, height: 250 }, // Área de escaneo optimizada\n+    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n+    qrbox: { width: 200, height: 200 }, // Reducido para que quepa completamente en la vista\n     aspectRatio: 1.0,\n     videoConstraints: {\n       facingMode: 'environment',\n-      width: { ideal: 640 }, // Reducido para procesamiento más rápido\n-      height: { ideal: 480 }\n+      width: { ideal: 1280 },\n+      height: { ideal: 720 }\n     },\n     ...config\n   };\n \n@@ -392,14 +392,13 @@\n     );\n   }\n \n   return (\n-    <div className=\"relative w-full bg-gray-100 rounded-lg overflow-hidden\" style={{ maxHeight: 'calc(100vh - 300px)', aspectRatio: '16/9', minHeight: '300px' }}>\n+    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n       <div \n         id={scannerId} \n         ref={containerRef}\n         className=\"w-full h-full\"\n-        style={{ position: 'relative' }}\n       />\n       \n       {cameraState === 'checking' && (\n         <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\n@@ -425,9 +424,9 @@\n \n       {/* Overlay de escaneo */}\n       {cameraState === 'ready' && (\n         <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\n-          <div className=\"border-4 border-blue-500 rounded-lg w-40 h-40 md:w-44 md:h-44 lg:w-48 lg:h-48 animate-pulse\" style={{ maxWidth: 'min(60%, 200px)', maxHeight: 'min(60%, 200px)' }}></div>\n+          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\n         </div>\n       )}\n     </div>\n   );\n"
                },
                {
                    "date": 1764023294178,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -392,9 +392,9 @@\n     );\n   }\n \n   return (\n-    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n+    <div className=\"relative w-full max-w-2xl mx-auto bg-gray-100 rounded-lg overflow-hidden\" style={{ minHeight: '300px', maxHeight: '400px', aspectRatio: '16/9' }}>\n       <div \n         id={scannerId} \n         ref={containerRef}\n         className=\"w-full h-full\"\n@@ -424,9 +424,9 @@\n \n       {/* Overlay de escaneo */}\n       {cameraState === 'ready' && (\n         <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\n-          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\n+          <div className=\"border-4 border-blue-500 rounded-lg w-40 h-40 md:w-44 md:h-44 lg:w-48 lg:h-48 animate-pulse\" style={{ maxWidth: 'min(60%, 200px)', maxHeight: 'min(60%, 200px)' }}></div>\n         </div>\n       )}\n     </div>\n   );\n"
                },
                {
                    "date": 1764023384527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,10 +17,10 @@\n   const containerRef = useRef(null);\n   const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n \n   const defaultConfig = {\n-    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n-    qrbox: { width: 200, height: 200 }, // Reducido para que quepa completamente en la vista\n+    fps: 30, // Optimizado para mejor rendimiento\n+    qrbox: { width: 250, height: 250 }, // Tamaño óptimo para detección efectiva\n     aspectRatio: 1.0,\n     videoConstraints: {\n       facingMode: 'environment',\n       width: { ideal: 1280 },\n@@ -392,9 +392,9 @@\n     );\n   }\n \n   return (\n-    <div className=\"relative w-full max-w-2xl mx-auto bg-gray-100 rounded-lg overflow-hidden\" style={{ minHeight: '300px', maxHeight: '400px', aspectRatio: '16/9' }}>\n+    <div className=\"relative w-full max-w-2xl mx-auto bg-gray-100 rounded-lg overflow-hidden\" style={{ minHeight: '400px', maxHeight: '500px', aspectRatio: '16/9' }}>\n       <div \n         id={scannerId} \n         ref={containerRef}\n         className=\"w-full h-full\"\n@@ -423,10 +423,10 @@\n       )}\n \n       {/* Overlay de escaneo */}\n       {cameraState === 'ready' && (\n-        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\n-          <div className=\"border-4 border-blue-500 rounded-lg w-40 h-40 md:w-44 md:h-44 lg:w-48 lg:h-48 animate-pulse\" style={{ maxWidth: 'min(60%, 200px)', maxHeight: 'min(60%, 200px)' }}></div>\n+        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-[1] p-4\">\n+          <div className=\"border-4 border-blue-500 rounded-lg w-44 h-44 md:w-48 md:h-48 lg:w-52 lg:h-52 animate-pulse\" style={{ maxWidth: 'min(65%, 250px)', maxHeight: 'min(65%, 250px)' }}></div>\n         </div>\n       )}\n     </div>\n   );\n"
                },
                {
                    "date": 1764023486472,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,10 +17,10 @@\n   const containerRef = useRef(null);\n   const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n \n   const defaultConfig = {\n-    fps: 30, // Optimizado para mejor rendimiento\n-    qrbox: { width: 250, height: 250 }, // Tamaño óptimo para detección efectiva\n+    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n+    qrbox: { width: 300, height: 300 }, // Aumentado de 250x250 para mejor detección\n     aspectRatio: 1.0,\n     videoConstraints: {\n       facingMode: 'environment',\n       width: { ideal: 1280 },\n@@ -392,9 +392,9 @@\n     );\n   }\n \n   return (\n-    <div className=\"relative w-full max-w-2xl mx-auto bg-gray-100 rounded-lg overflow-hidden\" style={{ minHeight: '400px', maxHeight: '500px', aspectRatio: '16/9' }}>\n+    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n       <div \n         id={scannerId} \n         ref={containerRef}\n         className=\"w-full h-full\"\n@@ -423,10 +423,10 @@\n       )}\n \n       {/* Overlay de escaneo */}\n       {cameraState === 'ready' && (\n-        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-[1] p-4\">\n-          <div className=\"border-4 border-blue-500 rounded-lg w-44 h-44 md:w-48 md:h-48 lg:w-52 lg:h-52 animate-pulse\" style={{ maxWidth: 'min(65%, 250px)', maxHeight: 'min(65%, 250px)' }}></div>\n+        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0\">\n+          <div className=\"border-4 border-blue-500 rounded-lg w-64 h-64 animate-pulse\"></div>\n         </div>\n       )}\n     </div>\n   );\n"
                },
                {
                    "date": 1764023606141,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,435 +0,0 @@\n-// CameraOptimized.jsx - Versión Corregida y Robusta\n-import React, { useState, useEffect, useRef } from 'react';\n-import { Html5Qrcode } from 'html5-qrcode';\n-import CameraErrorRecovery from './CameraErrorRecovery';\n-\n-const CameraOptimized = ({ \n-  scannerId = 'qr-reader',\n-  onScanSuccess, \n-  onScanFailure,\n-  onCameraError,\n-  isActive,\n-  config = {}\n-}) => {\n-  const [cameraState, setCameraState] = useState('idle'); // 'idle', 'checking', 'ready', 'error'\n-  const [errorDetails, setErrorDetails] = useState(null);\n-  const scannerRef = useRef(null);\n-  const containerRef = useRef(null);\n-  const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n-\n-  const defaultConfig = {\n-    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n-    qrbox: { width: 300, height: 300 }, // Aumentado de 250x250 para mejor detección\n-    aspectRatio: 1.0,\n-    videoConstraints: {\n-      facingMode: 'environment',\n-      width: { ideal: 1280 },\n-      height: { ideal: 720 }\n-    },\n-    ...config\n-  };\n-\n-  // Actualizar ref cuando isActive cambia\n-  useEffect(() => {\n-    isActiveRef.current = isActive;\n-  }, [isActive]);\n-\n-  useEffect(() => {\n-    // Solo inicializar si isActive es true y estamos en estado idle o error\n-    if (isActive && (cameraState === 'idle' || cameraState === 'error')) {\n-      initializeCamera();\n-    } else if (!isActive) {\n-      // Si no está activo, detener la cámara y resetear estado\n-      stopCamera();\n-      if (cameraState !== 'idle' && cameraState !== 'checking') {\n-        setCameraState('idle');\n-      }\n-    }\n-\n-    return () => {\n-      // Cleanup: detener cámara si el componente se desmonta o isActive cambia a false\n-      if (!isActive && scannerRef.current) {\n-        stopCamera();\n-      }\n-    };\n-    // eslint-disable-next-line react-hooks/exhaustive-deps\n-  }, [isActive]);\n-\n-  const initializeCamera = async () => {\n-    // Verificar que isActive sigue siendo true antes de continuar (usar ref para valor actualizado)\n-    if (!isActiveRef.current) {\n-      console.log('Inicialización cancelada: isActive es false');\n-      return;\n-    }\n-\n-    try {\n-      setCameraState('checking');\n-      setErrorDetails(null);\n-      \n-      // 1. Verificar si el navegador soporta la API\n-      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n-        throw new Error('NAVEGADOR_NO_COMPATIBLE');\n-      }\n-\n-      // 2. Verificar permisos existentes (si está disponible)\n-      // Nota: La API de permisos puede no estar disponible en todos los navegadores\n-      let permissionState = 'prompt';\n-      try {\n-        if (navigator.permissions && navigator.permissions.query) {\n-          const permission = await navigator.permissions.query({ name: 'camera' });\n-          permissionState = permission.state;\n-          \n-          if (permission.state === 'denied') {\n-            throw new Error('PERMISSION_DENIED');\n-          }\n-        }\n-      } catch (permError) {\n-        // Si el error es específicamente PERMISSION_DENIED, propagarlo\n-        if (permError.message === 'PERMISSION_DENIED') {\n-          throw permError;\n-        }\n-        // Si la API de permisos no está disponible, continuar e intentar getUserMedia\n-        console.log('API de permisos no disponible, intentando getUserMedia directamente');\n-      }\n-\n-      // 3. Obtener cámaras disponibles\n-      // Estrategia: primero solicitar permisos, luego enumerar dispositivos\n-      let cameras = [];\n-      \n-      try {\n-        // Primero intentar obtener permisos (necesario para enumerar dispositivos en algunos navegadores)\n-        let stream = null;\n-        try {\n-          stream = await navigator.mediaDevices.getUserMedia({ video: true });\n-          // Limpiar stream inmediatamente después de obtener permisos\n-          stream.getTracks().forEach(track => track.stop());\n-          \n-          // Esperar un momento para que los permisos se propaguen\n-          await new Promise(resolve => setTimeout(resolve, 200));\n-        } catch (permError) {\n-          // Si getUserMedia falla, es un problema de permisos\n-          if (permError.name === 'NotAllowedError' || permError.name === 'PermissionDeniedError') {\n-            throw new Error('PERMISSION_DENIED');\n-          }\n-          // Si es NotFoundError, puede ser que no haya cámara\n-          if (permError.name === 'NotFoundError' || permError.name === 'DevicesNotFoundError') {\n-            throw new Error('NO_CAMERA_AVAILABLE');\n-          }\n-          // Otros errores también pueden ser de permisos\n-          throw new Error('PERMISSION_DENIED');\n-        }\n-\n-        // Intentar obtener cámaras usando Html5Qrcode (método preferido)\n-        try {\n-          cameras = await Html5Qrcode.getCameras();\n-        } catch (html5Error) {\n-          console.warn('Html5Qrcode.getCameras() falló, usando enumerateDevices como alternativa:', html5Error);\n-          \n-          // Fallback: usar enumerateDevices directamente\n-          const devices = await navigator.mediaDevices.enumerateDevices();\n-          const videoDevices = devices.filter(device => device.kind === 'videoinput');\n-          \n-          if (videoDevices.length === 0) {\n-            throw new Error('NO_CAMERA_AVAILABLE');\n-          }\n-          \n-          // Convertir dispositivos al formato que espera Html5Qrcode\n-          cameras = videoDevices.map(device => ({\n-            id: device.deviceId,\n-            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\n-          }));\n-        }\n-\n-        // Verificar que tenemos cámaras disponibles\n-        if (!cameras || cameras.length === 0) {\n-          // Último intento: usar enumerateDevices directamente\n-          const devices = await navigator.mediaDevices.enumerateDevices();\n-          const videoDevices = devices.filter(device => device.kind === 'videoinput');\n-          \n-          if (videoDevices.length === 0) {\n-            throw new Error('NO_CAMERA_AVAILABLE');\n-          }\n-          \n-          cameras = videoDevices.map(device => ({\n-            id: device.deviceId,\n-            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\n-          }));\n-        }\n-      } catch (error) {\n-        // Si el error ya es PERMISSION_DENIED o NO_CAMERA_AVAILABLE, propagarlo\n-        if (error.message === 'PERMISSION_DENIED' || error.message === 'NO_CAMERA_AVAILABLE') {\n-          throw error;\n-        }\n-        // Para otros errores, intentar determinar la causa\n-        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n-          throw new Error('PERMISSION_DENIED');\n-        }\n-        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n-          throw new Error('NO_CAMERA_AVAILABLE');\n-        }\n-        // Si no podemos determinar, asumir que no hay cámara\n-        console.error('Error desconocido al obtener cámaras:', error);\n-        throw new Error('NO_CAMERA_AVAILABLE');\n-      }\n-\n-      // Verificar nuevamente que isActive sigue siendo true antes de inicializar scanner\n-      if (!isActiveRef.current) {\n-        console.log('Inicialización cancelada: isActive cambió a false durante la verificación');\n-        setCameraState('idle');\n-        return;\n-      }\n-\n-      // 4. Inicializar scanner con configuración robusta\n-      await initializeScanner(cameras);\n-    } catch (error) {\n-      // Solo manejar el error si isActive sigue siendo true (usar ref para valor actualizado)\n-      if (isActiveRef.current) {\n-        handleCameraError(error);\n-      } else {\n-        console.log('Error ignorado porque isActive es false:', error);\n-        setCameraState('idle');\n-      }\n-    }\n-  };\n-\n-  const initializeScanner = async (cameras) => {\n-    try {\n-      // Crear instancia de Html5Qrcode\n-      const html5QrCode = new Html5Qrcode(scannerId);\n-      scannerRef.current = html5QrCode;\n-\n-      // Seleccionar mejor cámara (trasera si está disponible)\n-      let cameraId = cameras[0].id;\n-      const backCamera = cameras.find(camera => \n-        camera.label && (\n-          camera.label.toLowerCase().includes('back') || \n-          camera.label.toLowerCase().includes('rear') ||\n-          camera.label.toLowerCase().includes('environment')\n-        )\n-      );\n-      \n-      if (backCamera && backCamera.id) {\n-        cameraId = backCamera.id;\n-      }\n-\n-      // Intentar iniciar con la cámara seleccionada\n-      let startSuccess = false;\n-      let lastError = null;\n-      \n-      // Intentar con la cámara preferida primero\n-      try {\n-        await html5QrCode.start(\n-          cameraId,\n-          defaultConfig,\n-          onScanSuccess,\n-          onScanFailure\n-        );\n-        startSuccess = true;\n-        setCameraState('ready');\n-        console.log('Cámara iniciada correctamente:', cameraId);\n-      } catch (startError) {\n-        console.warn(`Error iniciando con cámara ${cameraId}, intentando otras cámaras:`, startError);\n-        lastError = startError;\n-        \n-        // Limpiar antes de intentar otras cámaras\n-        try {\n-          await html5QrCode.clear();\n-        } catch (clearError) {\n-          // Ignorar errores al limpiar\n-        }\n-        \n-        // Si falla, intentar con otras cámaras disponibles\n-        for (let i = 0; i < cameras.length; i++) {\n-          if (cameras[i].id === cameraId) continue; // Ya intentamos esta\n-          \n-          try {\n-            // Crear nueva instancia para cada intento\n-            const newHtml5QrCode = new Html5Qrcode(scannerId);\n-            await newHtml5QrCode.start(\n-              cameras[i].id,\n-              defaultConfig,\n-              onScanSuccess,\n-              onScanFailure\n-            );\n-            scannerRef.current = newHtml5QrCode;\n-            startSuccess = true;\n-            setCameraState('ready');\n-            console.log('Cámara iniciada correctamente (fallback):', cameras[i].id);\n-            break;\n-          } catch (fallbackError) {\n-            console.warn(`Error con cámara ${cameras[i].id}:`, fallbackError);\n-            lastError = fallbackError;\n-            // Limpiar antes del siguiente intento\n-            try {\n-              await html5QrCode.clear();\n-            } catch (e) {\n-              // Ignorar\n-            }\n-            continue;\n-          }\n-        }\n-      }\n-      \n-      if (!startSuccess) {\n-        throw new Error(`SCANNER_INIT_FAILED: ${lastError?.message || 'No se pudo iniciar ninguna cámara'}`);\n-      }\n-    } catch (error) {\n-      throw new Error(`SCANNER_INIT_FAILED: ${error.message}`);\n-    }\n-  };\n-\n-  const handleCameraError = (error) => {\n-    console.error('Error de cámara:', error);\n-    \n-    let errorType = 'unknown';\n-    let userMessage = 'Error desconocido con la cámara';\n-    let recoverySteps = [];\n-\n-    if (error.message.includes('PERMISSION_DENIED') || error.message.includes('NotAllowedError')) {\n-      errorType = 'permission_denied';\n-      userMessage = 'Permisos de cámara denegados';\n-      recoverySteps = getPermissionRecoverySteps();\n-    } else if (error.message.includes('NO_CAMERA_AVAILABLE') || error.message.includes('NotFoundError')) {\n-      errorType = 'no_camera';\n-      userMessage = 'No se encontró cámara disponible';\n-      recoverySteps = getNoCameraRecoverySteps();\n-    } else if (error.message.includes('SCANNER_INIT_FAILED')) {\n-      errorType = 'scanner_failed';\n-      userMessage = 'Error al inicializar el escáner';\n-      recoverySteps = getScannerRecoverySteps();\n-    } else if (error.message.includes('NAVEGADOR_NO_COMPATIBLE')) {\n-      errorType = 'browser_not_supported';\n-      userMessage = 'Navegador no compatible';\n-      recoverySteps = getBrowserRecoverySteps();\n-    }\n-\n-    setCameraState('error');\n-    setErrorDetails({\n-      type: errorType,\n-      message: userMessage,\n-      recoverySteps,\n-      originalError: error.message\n-    });\n-\n-    if (onCameraError) {\n-      onCameraError({ type: errorType, message: userMessage });\n-    }\n-  };\n-\n-  const getPermissionRecoverySteps = () => [\n-    'Haz clic en el ícono de candado o cámara en la barra de direcciones',\n-    'Selecciona \"Permitir\" para el acceso a la cámara',\n-    'Recarga la página después de permitir los permisos',\n-    'Si no ves la opción, revisa la configuración de privacidad de tu navegador'\n-  ];\n-\n-  const getNoCameraRecoverySteps = () => [\n-    'Verifica que tu dispositivo tenga una cámara conectada y funcionando',\n-    'Asegúrate de que la cámara no esté siendo usada por otra aplicación',\n-    'Si estás en una computadora, verifica que la cámara esté conectada correctamente',\n-    'Si estás en un dispositivo móvil, verifica que la cámara funcione en otras aplicaciones',\n-    'Intenta recargar la página después de conectar la cámara',\n-    'Usa el modo de entrada manual como alternativa mientras resuelves el problema'\n-  ];\n-\n-  const getScannerRecoverySteps = () => [\n-    'Recarga la página e intenta nuevamente',\n-    'Prueba con un navegador diferente (Chrome, Firefox)',\n-    'Verifica que tu cámara funcione en otras aplicaciones',\n-    'Contacta al soporte técnico si el problema persiste'\n-  ];\n-\n-  const getBrowserRecoverySteps = () => [\n-    'Actualiza tu navegador a la última versión',\n-    'Usa Google Chrome, Mozilla Firefox o Microsoft Edge',\n-    'Verifica que JavaScript esté habilitado',\n-    'Contacta al administrador del sistema si el problema persiste'\n-  ];\n-\n-  const retryCamera = async () => {\n-    setCameraState('idle');\n-    setErrorDetails(null);\n-    await initializeCamera();\n-  };\n-\n-  const requestCameraPermission = async () => {\n-    try {\n-      // Solicitar permisos de manera directa\n-      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n-      // Limpiar stream inmediatamente\n-      stream.getTracks().forEach(track => track.stop());\n-      // Reintentar inicialización\n-      await retryCamera();\n-    } catch (error) {\n-      handleCameraError(error);\n-    }\n-  };\n-\n-  const stopCamera = async () => {\n-    if (scannerRef.current) {\n-      try {\n-        if (scannerRef.current.isScanning) {\n-          await scannerRef.current.stop();\n-        }\n-        await scannerRef.current.clear();\n-      } catch (error) {\n-        console.error('Error deteniendo cámara:', error);\n-      } finally {\n-        scannerRef.current = null;\n-      }\n-    }\n-  };\n-\n-  if (!isActive) {\n-    return (\n-      <div className=\"bg-gray-100 rounded-lg p-12 text-center\">\n-        <svg className=\"w-24 h-24 mx-auto text-gray-400 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n-          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z\" />\n-        </svg>\n-        <p className=\"text-gray-600 text-lg mb-2\">Cámara inactiva</p>\n-        <p className=\"text-gray-500 text-sm\">Activa el scanner para comenzar</p>\n-      </div>\n-    );\n-  }\n-\n-  return (\n-    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n-      <div \n-        id={scannerId} \n-        ref={containerRef}\n-        className=\"w-full h-full\"\n-      />\n-      \n-      {cameraState === 'checking' && (\n-        <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\n-          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-600 mb-4\"></div>\n-          <p className=\"text-yellow-800 font-medium\">Inicializando cámara...</p>\n-        </div>\n-      )}\n-\n-      {cameraState === 'error' && errorDetails && (\n-        <CameraErrorRecovery \n-          errorDetails={errorDetails}\n-          onRetry={retryCamera}\n-          onRequestPermission={requestCameraPermission}\n-        />\n-      )}\n-\n-      {cameraState === 'ready' && (\n-        <div className=\"absolute top-4 left-4 bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 z-10\">\n-          <span>✅</span>\n-          <span>Cámara lista</span>\n-        </div>\n-      )}\n-\n-      {/* Overlay de escaneo */}\n-      {cameraState === 'ready' && (\n-        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0\">\n-          <div className=\"border-4 border-blue-500 rounded-lg w-64 h-64 animate-pulse\"></div>\n-        </div>\n-      )}\n-    </div>\n-  );\n-};\n-\n-export default CameraOptimized;\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764023857887,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +0,0 @@\n-\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764023952072,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +0,0 @@\n-\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764024032071,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +0,0 @@\n-\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764024189681,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +0,0 @@\n-\n\\ No newline at end of file\n"
                },
                {
                    "date": 1764024277424,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,1 @@\n+ \n\\ No newline at end of file\n"
                },
                {
                    "date": 1764024300479,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,330 @@\n- \n\\ No newline at end of file\n+// CameraOptimized.jsx - Componente de cámara optimizado para escaneo QR\r\n+import React, { useState, useEffect, useRef } from 'react';\r\n+import { Html5Qrcode } from 'html5-qrcode';\r\n+import CameraErrorRecovery from './CameraErrorRecovery';\r\n+\r\n+const CameraOptimized = ({ \r\n+  scannerId = 'qr-reader',\r\n+  onScanSuccess, \r\n+  onScanFailure,\r\n+  onCameraError,\r\n+  isActive,\r\n+  config = {}\r\n+}) => {\r\n+  const [cameraState, setCameraState] = useState('idle');\r\n+  const [errorDetails, setErrorDetails] = useState(null);\r\n+  const scannerRef = useRef(null);\r\n+  const containerRef = useRef(null);\r\n+  const isActiveRef = useRef(isActive);\r\n+\r\n+  const defaultConfig = {\r\n+    fps: 30,\r\n+    qrbox: { width: 200, height: 200 },\r\n+    aspectRatio: 1.0,\r\n+    videoConstraints: {\r\n+      facingMode: 'environment',\r\n+      width: { ideal: 1280 },\r\n+      height: { ideal: 720 }\r\n+    },\r\n+    ...config\r\n+  };\r\n+\r\n+  useEffect(() => {\r\n+    isActiveRef.current = isActive;\r\n+  }, [isActive]);\r\n+\r\n+  useEffect(() => {\r\n+    if (isActive && (cameraState === 'idle' || cameraState === 'error')) {\r\n+      initializeCamera();\r\n+    } else if (!isActive) {\r\n+      stopCamera();\r\n+      if (cameraState !== 'idle' && cameraState !== 'checking') {\r\n+        setCameraState('idle');\r\n+      }\r\n+    }\r\n+\r\n+    return () => {\r\n+      if (!isActive && scannerRef.current) {\r\n+        stopCamera();\r\n+      }\r\n+    };\r\n+  }, [isActive, cameraState]);\r\n+\r\n+  const initializeCamera = async () => {\r\n+    if (!isActiveRef.current) {\r\n+      return;\r\n+    }\r\n+\r\n+    try {\r\n+      setCameraState('checking');\r\n+      setErrorDetails(null);\r\n+      \r\n+      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n+        throw new Error('NAVEGADOR_NO_COMPATIBLE');\r\n+      }\r\n+\r\n+      let cameras = [];\r\n+      \r\n+      try {\r\n+        let stream = null;\r\n+        try {\r\n+          stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n+          stream.getTracks().forEach(track => track.stop());\r\n+          await new Promise(resolve => setTimeout(resolve, 200));\r\n+        } catch (permError) {\r\n+          if (permError.name === 'NotAllowedError' || permError.name === 'PermissionDeniedError') {\r\n+            throw new Error('PERMISSION_DENIED');\r\n+          }\r\n+          if (permError.name === 'NotFoundError' || permError.name === 'DevicesNotFoundError') {\r\n+            throw new Error('NO_CAMERA_AVAILABLE');\r\n+          }\r\n+          throw new Error('PERMISSION_DENIED');\r\n+        }\r\n+\r\n+        try {\r\n+          cameras = await Html5Qrcode.getCameras();\r\n+        } catch (html5Error) {\r\n+          const devices = await navigator.mediaDevices.enumerateDevices();\r\n+          const videoDevices = devices.filter(device => device.kind === 'videoinput');\r\n+          \r\n+          if (videoDevices.length === 0) {\r\n+            throw new Error('NO_CAMERA_AVAILABLE');\r\n+          }\r\n+          \r\n+          cameras = videoDevices.map(device => ({\r\n+            id: device.deviceId,\r\n+            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\r\n+          }));\r\n+        }\r\n+\r\n+        if (!cameras || cameras.length === 0) {\r\n+          throw new Error('NO_CAMERA_AVAILABLE');\r\n+        }\r\n+      } catch (error) {\r\n+        if (error.message === 'PERMISSION_DENIED' || error.message === 'NO_CAMERA_AVAILABLE') {\r\n+          throw error;\r\n+        }\r\n+        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\r\n+          throw new Error('PERMISSION_DENIED');\r\n+        }\r\n+        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\r\n+          throw new Error('NO_CAMERA_AVAILABLE');\r\n+        }\r\n+        throw new Error('NO_CAMERA_AVAILABLE');\r\n+      }\r\n+\r\n+      if (!isActiveRef.current) {\r\n+        setCameraState('idle');\r\n+        return;\r\n+      }\r\n+\r\n+      await initializeScanner(cameras);\r\n+    } catch (error) {\r\n+      if (isActiveRef.current) {\r\n+        handleCameraError(error);\r\n+      } else {\r\n+        setCameraState('idle');\r\n+      }\r\n+    }\r\n+  };\r\n+\r\n+  const initializeScanner = async (cameras) => {\r\n+    try {\r\n+      const html5QrCode = new Html5Qrcode(scannerId);\r\n+      scannerRef.current = html5QrCode;\r\n+\r\n+      let cameraId = cameras[0].id;\r\n+      const backCamera = cameras.find(camera => \r\n+        camera.label && (\r\n+          camera.label.toLowerCase().includes('back') || \r\n+          camera.label.toLowerCase().includes('rear') ||\r\n+          camera.label.toLowerCase().includes('environment')\r\n+        )\r\n+      );\r\n+      \r\n+      if (backCamera && backCamera.id) {\r\n+        cameraId = backCamera.id;\r\n+      }\r\n+\r\n+      let startSuccess = false;\r\n+      let lastError = null;\r\n+      \r\n+      try {\r\n+        await html5QrCode.start(\r\n+          cameraId,\r\n+          defaultConfig,\r\n+          onScanSuccess,\r\n+          onScanFailure\r\n+        );\r\n+        startSuccess = true;\r\n+        setCameraState('ready');\r\n+      } catch (startError) {\r\n+        lastError = startError;\r\n+        \r\n+        try {\r\n+          await html5QrCode.clear();\r\n+        } catch (clearError) {\r\n+          // Ignorar\r\n+        }\r\n+        \r\n+        for (let i = 0; i < cameras.length; i++) {\r\n+          if (cameras[i].id === cameraId) continue;\r\n+          \r\n+          try {\r\n+            const newHtml5QrCode = new Html5Qrcode(scannerId);\r\n+            await newHtml5QrCode.start(\r\n+              cameras[i].id,\r\n+              defaultConfig,\r\n+              onScanSuccess,\r\n+              onScanFailure\r\n+            );\r\n+            scannerRef.current = newHtml5QrCode;\r\n+            startSuccess = true;\r\n+            setCameraState('ready');\r\n+            break;\r\n+          } catch (fallbackError) {\r\n+            lastError = fallbackError;\r\n+            try {\r\n+              await html5QrCode.clear();\r\n+            } catch (e) {\r\n+              // Ignorar\r\n+            }\r\n+            continue;\r\n+          }\r\n+        }\r\n+      }\r\n+      \r\n+      if (!startSuccess) {\r\n+        throw new Error(`SCANNER_INIT_FAILED: ${lastError?.message || 'No se pudo iniciar ninguna cámara'}`);\r\n+      }\r\n+    } catch (error) {\r\n+      throw new Error(`SCANNER_INIT_FAILED: ${error.message}`);\r\n+    }\r\n+  };\r\n+\r\n+  const handleCameraError = (error) => {\r\n+    let errorType = 'unknown';\r\n+    let userMessage = 'Error desconocido con la cámara';\r\n+    let recoverySteps = [];\r\n+\r\n+    if (error.message.includes('PERMISSION_DENIED') || error.message.includes('NotAllowedError')) {\r\n+      errorType = 'permission_denied';\r\n+      userMessage = 'Permisos de cámara denegados';\r\n+      recoverySteps = [\r\n+        'Haz clic en el ícono de candado o cámara en la barra de direcciones',\r\n+        'Selecciona \"Permitir\" para el acceso a la cámara',\r\n+        'Recarga la página después de permitir los permisos'\r\n+      ];\r\n+    } else if (error.message.includes('NO_CAMERA_AVAILABLE') || error.message.includes('NotFoundError')) {\r\n+      errorType = 'no_camera';\r\n+      userMessage = 'No se encontró cámara disponible';\r\n+      recoverySteps = [\r\n+        'Verifica que tu dispositivo tenga una cámara conectada',\r\n+        'Asegúrate de que la cámara no esté siendo usada por otra aplicación'\r\n+      ];\r\n+    } else if (error.message.includes('SCANNER_INIT_FAILED')) {\r\n+      errorType = 'scanner_failed';\r\n+      userMessage = 'Error al inicializar el escáner';\r\n+      recoverySteps = ['Recarga la página e intenta nuevamente'];\r\n+    } else if (error.message.includes('NAVEGADOR_NO_COMPATIBLE')) {\r\n+      errorType = 'browser_not_supported';\r\n+      userMessage = 'Navegador no compatible';\r\n+      recoverySteps = ['Actualiza tu navegador a la última versión'];\r\n+    }\r\n+\r\n+    setCameraState('error');\r\n+    setErrorDetails({\r\n+      type: errorType,\r\n+      message: userMessage,\r\n+      recoverySteps,\r\n+      originalError: error.message\r\n+    });\r\n+\r\n+    if (onCameraError) {\r\n+      onCameraError({ type: errorType, message: userMessage });\r\n+    }\r\n+  };\r\n+\r\n+  const retryCamera = async () => {\r\n+    setCameraState('idle');\r\n+    setErrorDetails(null);\r\n+    await initializeCamera();\r\n+  };\r\n+\r\n+  const requestCameraPermission = async () => {\r\n+    try {\r\n+      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n+      stream.getTracks().forEach(track => track.stop());\r\n+      await retryCamera();\r\n+    } catch (error) {\r\n+      handleCameraError(error);\r\n+    }\r\n+  };\r\n+\r\n+  const stopCamera = async () => {\r\n+    if (scannerRef.current) {\r\n+      try {\r\n+        if (scannerRef.current.isScanning) {\r\n+          await scannerRef.current.stop();\r\n+        }\r\n+        await scannerRef.current.clear();\r\n+      } catch (error) {\r\n+        console.error('Error deteniendo cámara:', error);\r\n+      } finally {\r\n+        scannerRef.current = null;\r\n+      }\r\n+    }\r\n+  };\r\n+\r\n+  if (!isActive) {\r\n+    return (\r\n+      <div className=\"bg-gray-100 rounded-lg p-12 text-center\">\r\n+        <svg className=\"w-24 h-24 mx-auto text-gray-400 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n+          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z\" />\r\n+        </svg>\r\n+        <p className=\"text-gray-600 text-lg mb-2\">Cámara inactiva</p>\r\n+        <p className=\"text-gray-500 text-sm\">Activa el scanner para comenzar</p>\r\n+      </div>\r\n+    );\r\n+  }\r\n+\r\n+  return (\r\n+    <div className=\"relative w-full bg-gray-100 rounded-lg overflow-hidden\" style={{ maxHeight: 'calc(100vh - 300px)', aspectRatio: '16/9' }}>\r\n+      <div \r\n+        id={scannerId} \r\n+        ref={containerRef}\r\n+        className=\"w-full h-full\"\r\n+      />\r\n+      \r\n+      {cameraState === 'checking' && (\r\n+        <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\r\n+          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-600 mb-4\"></div>\r\n+          <p className=\"text-yellow-800 font-medium\">Inicializando cámara...</p>\r\n+        </div>\r\n+      )}\r\n+\r\n+      {cameraState === 'error' && errorDetails && (\r\n+        <CameraErrorRecovery \r\n+          errorDetails={errorDetails}\r\n+          onRetry={retryCamera}\r\n+          onRequestPermission={requestCameraPermission}\r\n+        />\r\n+      )}\r\n+\r\n+      {cameraState === 'ready' && (\r\n+        <div className=\"absolute top-4 left-4 bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 z-10\">\r\n+          <span>✅</span>\r\n+          <span>Cámara lista</span>\r\n+        </div>\r\n+      )}\r\n+\r\n+      {cameraState === 'ready' && (\r\n+        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\r\n+          <div className=\"border-4 border-blue-500 rounded-lg w-40 h-40 md:w-44 md:h-44 lg:w-48 lg:h-48 animate-pulse\" style={{ maxWidth: 'min(60%, 200px)', maxHeight: 'min(60%, 200px)' }}></div>\r\n+        </div>\r\n+      )}\r\n+    </div>\r\n+  );\r\n+};\r\n+\r\n+export default CameraOptimized;\r\n"
                },
                {
                    "date": 1764024391804,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,5 +1,5 @@\n-// CameraOptimized.jsx - Componente de cámara optimizado para escaneo QR\r\n+// CameraOptimized.jsx - Versión Corregida y Robusta\r\n import React, { useState, useEffect, useRef } from 'react';\r\n import { Html5Qrcode } from 'html5-qrcode';\r\n import CameraErrorRecovery from './CameraErrorRecovery';\r\n \r\n@@ -10,17 +10,17 @@\n   onCameraError,\r\n   isActive,\r\n   config = {}\r\n }) => {\r\n-  const [cameraState, setCameraState] = useState('idle');\r\n+  const [cameraState, setCameraState] = useState('idle'); // 'idle', 'checking', 'ready', 'error'\r\n   const [errorDetails, setErrorDetails] = useState(null);\r\n   const scannerRef = useRef(null);\r\n   const containerRef = useRef(null);\r\n-  const isActiveRef = useRef(isActive);\r\n+  const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\r\n \r\n   const defaultConfig = {\r\n-    fps: 30,\r\n-    qrbox: { width: 200, height: 200 },\r\n+    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\r\n+    qrbox: { width: 300, height: 300 }, // Aumentado de 250x250 para mejor detección\r\n     aspectRatio: 1.0,\r\n     videoConstraints: {\r\n       facingMode: 'environment',\r\n       width: { ideal: 1280 },\r\n@@ -28,112 +28,178 @@\n     },\r\n     ...config\r\n   };\r\n \r\n+  // Actualizar ref cuando isActive cambia\r\n   useEffect(() => {\r\n     isActiveRef.current = isActive;\r\n   }, [isActive]);\r\n \r\n   useEffect(() => {\r\n+    // Solo inicializar si isActive es true y estamos en estado idle o error\r\n     if (isActive && (cameraState === 'idle' || cameraState === 'error')) {\r\n       initializeCamera();\r\n     } else if (!isActive) {\r\n+      // Si no está activo, detener la cámara y resetear estado\r\n       stopCamera();\r\n       if (cameraState !== 'idle' && cameraState !== 'checking') {\r\n         setCameraState('idle');\r\n       }\r\n     }\r\n \r\n     return () => {\r\n+      // Cleanup: detener cámara si el componente se desmonta o isActive cambia a false\r\n       if (!isActive && scannerRef.current) {\r\n         stopCamera();\r\n       }\r\n     };\r\n-  }, [isActive, cameraState]);\r\n+    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n+  }, [isActive]);\r\n \r\n   const initializeCamera = async () => {\r\n+    // Verificar que isActive sigue siendo true antes de continuar (usar ref para valor actualizado)\r\n     if (!isActiveRef.current) {\r\n+      console.log('Inicialización cancelada: isActive es false');\r\n       return;\r\n     }\r\n \r\n     try {\r\n       setCameraState('checking');\r\n       setErrorDetails(null);\r\n       \r\n+      // 1. Verificar si el navegador soporta la API\r\n       if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n         throw new Error('NAVEGADOR_NO_COMPATIBLE');\r\n       }\r\n \r\n+      // 2. Verificar permisos existentes (si está disponible)\r\n+      // Nota: La API de permisos puede no estar disponible en todos los navegadores\r\n+      let permissionState = 'prompt';\r\n+      try {\r\n+        if (navigator.permissions && navigator.permissions.query) {\r\n+          const permission = await navigator.permissions.query({ name: 'camera' });\r\n+          permissionState = permission.state;\r\n+          \r\n+          if (permission.state === 'denied') {\r\n+            throw new Error('PERMISSION_DENIED');\r\n+          }\r\n+        }\r\n+      } catch (permError) {\r\n+        // Si el error es específicamente PERMISSION_DENIED, propagarlo\r\n+        if (permError.message === 'PERMISSION_DENIED') {\r\n+          throw permError;\r\n+        }\r\n+        // Si la API de permisos no está disponible, continuar e intentar getUserMedia\r\n+        console.log('API de permisos no disponible, intentando getUserMedia directamente');\r\n+      }\r\n+\r\n+      // 3. Obtener cámaras disponibles\r\n+      // Estrategia: primero solicitar permisos, luego enumerar dispositivos\r\n       let cameras = [];\r\n       \r\n       try {\r\n+        // Primero intentar obtener permisos (necesario para enumerar dispositivos en algunos navegadores)\r\n         let stream = null;\r\n         try {\r\n           stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n+          // Limpiar stream inmediatamente después de obtener permisos\r\n           stream.getTracks().forEach(track => track.stop());\r\n+          \r\n+          // Esperar un momento para que los permisos se propaguen\r\n           await new Promise(resolve => setTimeout(resolve, 200));\r\n         } catch (permError) {\r\n+          // Si getUserMedia falla, es un problema de permisos\r\n           if (permError.name === 'NotAllowedError' || permError.name === 'PermissionDeniedError') {\r\n             throw new Error('PERMISSION_DENIED');\r\n           }\r\n+          // Si es NotFoundError, puede ser que no haya cámara\r\n           if (permError.name === 'NotFoundError' || permError.name === 'DevicesNotFoundError') {\r\n             throw new Error('NO_CAMERA_AVAILABLE');\r\n           }\r\n+          // Otros errores también pueden ser de permisos\r\n           throw new Error('PERMISSION_DENIED');\r\n         }\r\n \r\n+        // Intentar obtener cámaras usando Html5Qrcode (método preferido)\r\n         try {\r\n           cameras = await Html5Qrcode.getCameras();\r\n         } catch (html5Error) {\r\n+          console.warn('Html5Qrcode.getCameras() falló, usando enumerateDevices como alternativa:', html5Error);\r\n+          \r\n+          // Fallback: usar enumerateDevices directamente\r\n           const devices = await navigator.mediaDevices.enumerateDevices();\r\n           const videoDevices = devices.filter(device => device.kind === 'videoinput');\r\n           \r\n           if (videoDevices.length === 0) {\r\n             throw new Error('NO_CAMERA_AVAILABLE');\r\n           }\r\n           \r\n+          // Convertir dispositivos al formato que espera Html5Qrcode\r\n           cameras = videoDevices.map(device => ({\r\n             id: device.deviceId,\r\n             label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\r\n           }));\r\n         }\r\n \r\n+        // Verificar que tenemos cámaras disponibles\r\n         if (!cameras || cameras.length === 0) {\r\n-          throw new Error('NO_CAMERA_AVAILABLE');\r\n+          // Último intento: usar enumerateDevices directamente\r\n+          const devices = await navigator.mediaDevices.enumerateDevices();\r\n+          const videoDevices = devices.filter(device => device.kind === 'videoinput');\r\n+          \r\n+          if (videoDevices.length === 0) {\r\n+            throw new Error('NO_CAMERA_AVAILABLE');\r\n+          }\r\n+          \r\n+          cameras = videoDevices.map(device => ({\r\n+            id: device.deviceId,\r\n+            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\r\n+          }));\r\n         }\r\n       } catch (error) {\r\n+        // Si el error ya es PERMISSION_DENIED o NO_CAMERA_AVAILABLE, propagarlo\r\n         if (error.message === 'PERMISSION_DENIED' || error.message === 'NO_CAMERA_AVAILABLE') {\r\n           throw error;\r\n         }\r\n+        // Para otros errores, intentar determinar la causa\r\n         if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\r\n           throw new Error('PERMISSION_DENIED');\r\n         }\r\n         if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\r\n           throw new Error('NO_CAMERA_AVAILABLE');\r\n         }\r\n+        // Si no podemos determinar, asumir que no hay cámara\r\n+        console.error('Error desconocido al obtener cámaras:', error);\r\n         throw new Error('NO_CAMERA_AVAILABLE');\r\n       }\r\n \r\n+      // Verificar nuevamente que isActive sigue siendo true antes de inicializar scanner\r\n       if (!isActiveRef.current) {\r\n+        console.log('Inicialización cancelada: isActive cambió a false durante la verificación');\r\n         setCameraState('idle');\r\n         return;\r\n       }\r\n \r\n+      // 4. Inicializar scanner con configuración robusta\r\n       await initializeScanner(cameras);\r\n     } catch (error) {\r\n+      // Solo manejar el error si isActive sigue siendo true (usar ref para valor actualizado)\r\n       if (isActiveRef.current) {\r\n         handleCameraError(error);\r\n       } else {\r\n+        console.log('Error ignorado porque isActive es false:', error);\r\n         setCameraState('idle');\r\n       }\r\n     }\r\n   };\r\n \r\n   const initializeScanner = async (cameras) => {\r\n     try {\r\n+      // Crear instancia de Html5Qrcode\r\n       const html5QrCode = new Html5Qrcode(scannerId);\r\n       scannerRef.current = html5QrCode;\r\n \r\n+      // Seleccionar mejor cámara (trasera si está disponible)\r\n       let cameraId = cameras[0].id;\r\n       const backCamera = cameras.find(camera => \r\n         camera.label && (\r\n           camera.label.toLowerCase().includes('back') || \r\n@@ -145,11 +211,13 @@\n       if (backCamera && backCamera.id) {\r\n         cameraId = backCamera.id;\r\n       }\r\n \r\n+      // Intentar iniciar con la cámara seleccionada\r\n       let startSuccess = false;\r\n       let lastError = null;\r\n       \r\n+      // Intentar con la cámara preferida primero\r\n       try {\r\n         await html5QrCode.start(\r\n           cameraId,\r\n           defaultConfig,\r\n@@ -157,21 +225,26 @@\n           onScanFailure\r\n         );\r\n         startSuccess = true;\r\n         setCameraState('ready');\r\n+        console.log('Cámara iniciada correctamente:', cameraId);\r\n       } catch (startError) {\r\n+        console.warn(`Error iniciando con cámara ${cameraId}, intentando otras cámaras:`, startError);\r\n         lastError = startError;\r\n         \r\n+        // Limpiar antes de intentar otras cámaras\r\n         try {\r\n           await html5QrCode.clear();\r\n         } catch (clearError) {\r\n-          // Ignorar\r\n+          // Ignorar errores al limpiar\r\n         }\r\n         \r\n+        // Si falla, intentar con otras cámaras disponibles\r\n         for (let i = 0; i < cameras.length; i++) {\r\n-          if (cameras[i].id === cameraId) continue;\r\n+          if (cameras[i].id === cameraId) continue; // Ya intentamos esta\r\n           \r\n           try {\r\n+            // Crear nueva instancia para cada intento\r\n             const newHtml5QrCode = new Html5Qrcode(scannerId);\r\n             await newHtml5QrCode.start(\r\n               cameras[i].id,\r\n               defaultConfig,\r\n@@ -180,11 +253,14 @@\n             );\r\n             scannerRef.current = newHtml5QrCode;\r\n             startSuccess = true;\r\n             setCameraState('ready');\r\n+            console.log('Cámara iniciada correctamente (fallback):', cameras[i].id);\r\n             break;\r\n           } catch (fallbackError) {\r\n+            console.warn(`Error con cámara ${cameras[i].id}:`, fallbackError);\r\n             lastError = fallbackError;\r\n+            // Limpiar antes del siguiente intento\r\n             try {\r\n               await html5QrCode.clear();\r\n             } catch (e) {\r\n               // Ignorar\r\n@@ -202,35 +278,30 @@\n     }\r\n   };\r\n \r\n   const handleCameraError = (error) => {\r\n+    console.error('Error de cámara:', error);\r\n+    \r\n     let errorType = 'unknown';\r\n     let userMessage = 'Error desconocido con la cámara';\r\n     let recoverySteps = [];\r\n \r\n     if (error.message.includes('PERMISSION_DENIED') || error.message.includes('NotAllowedError')) {\r\n       errorType = 'permission_denied';\r\n       userMessage = 'Permisos de cámara denegados';\r\n-      recoverySteps = [\r\n-        'Haz clic en el ícono de candado o cámara en la barra de direcciones',\r\n-        'Selecciona \"Permitir\" para el acceso a la cámara',\r\n-        'Recarga la página después de permitir los permisos'\r\n-      ];\r\n+      recoverySteps = getPermissionRecoverySteps();\r\n     } else if (error.message.includes('NO_CAMERA_AVAILABLE') || error.message.includes('NotFoundError')) {\r\n       errorType = 'no_camera';\r\n       userMessage = 'No se encontró cámara disponible';\r\n-      recoverySteps = [\r\n-        'Verifica que tu dispositivo tenga una cámara conectada',\r\n-        'Asegúrate de que la cámara no esté siendo usada por otra aplicación'\r\n-      ];\r\n+      recoverySteps = getNoCameraRecoverySteps();\r\n     } else if (error.message.includes('SCANNER_INIT_FAILED')) {\r\n       errorType = 'scanner_failed';\r\n       userMessage = 'Error al inicializar el escáner';\r\n-      recoverySteps = ['Recarga la página e intenta nuevamente'];\r\n+      recoverySteps = getScannerRecoverySteps();\r\n     } else if (error.message.includes('NAVEGADOR_NO_COMPATIBLE')) {\r\n       errorType = 'browser_not_supported';\r\n       userMessage = 'Navegador no compatible';\r\n-      recoverySteps = ['Actualiza tu navegador a la última versión'];\r\n+      recoverySteps = getBrowserRecoverySteps();\r\n     }\r\n \r\n     setCameraState('error');\r\n     setErrorDetails({\r\n@@ -244,18 +315,51 @@\n       onCameraError({ type: errorType, message: userMessage });\r\n     }\r\n   };\r\n \r\n+  const getPermissionRecoverySteps = () => [\r\n+    'Haz clic en el ícono de candado o cámara en la barra de direcciones',\r\n+    'Selecciona \"Permitir\" para el acceso a la cámara',\r\n+    'Recarga la página después de permitir los permisos',\r\n+    'Si no ves la opción, revisa la configuración de privacidad de tu navegador'\r\n+  ];\r\n+\r\n+  const getNoCameraRecoverySteps = () => [\r\n+    'Verifica que tu dispositivo tenga una cámara conectada y funcionando',\r\n+    'Asegúrate de que la cámara no esté siendo usada por otra aplicación',\r\n+    'Si estás en una computadora, verifica que la cámara esté conectada correctamente',\r\n+    'Si estás en un dispositivo móvil, verifica que la cámara funcione en otras aplicaciones',\r\n+    'Intenta recargar la página después de conectar la cámara',\r\n+    'Usa el modo de entrada manual como alternativa mientras resuelves el problema'\r\n+  ];\r\n+\r\n+  const getScannerRecoverySteps = () => [\r\n+    'Recarga la página e intenta nuevamente',\r\n+    'Prueba con un navegador diferente (Chrome, Firefox)',\r\n+    'Verifica que tu cámara funcione en otras aplicaciones',\r\n+    'Contacta al soporte técnico si el problema persiste'\r\n+  ];\r\n+\r\n+  const getBrowserRecoverySteps = () => [\r\n+    'Actualiza tu navegador a la última versión',\r\n+    'Usa Google Chrome, Mozilla Firefox o Microsoft Edge',\r\n+    'Verifica que JavaScript esté habilitado',\r\n+    'Contacta al administrador del sistema si el problema persiste'\r\n+  ];\r\n+\r\n   const retryCamera = async () => {\r\n     setCameraState('idle');\r\n     setErrorDetails(null);\r\n     await initializeCamera();\r\n   };\r\n \r\n   const requestCameraPermission = async () => {\r\n     try {\r\n+      // Solicitar permisos de manera directa\r\n       const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n+      // Limpiar stream inmediatamente\r\n       stream.getTracks().forEach(track => track.stop());\r\n+      // Reintentar inicialización\r\n       await retryCamera();\r\n     } catch (error) {\r\n       handleCameraError(error);\r\n     }\r\n@@ -288,9 +392,9 @@\n     );\r\n   }\r\n \r\n   return (\r\n-    <div className=\"relative w-full bg-gray-100 rounded-lg overflow-hidden\" style={{ maxHeight: 'calc(100vh - 300px)', aspectRatio: '16/9' }}>\r\n+    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\r\n       <div \r\n         id={scannerId} \r\n         ref={containerRef}\r\n         className=\"w-full h-full\"\r\n@@ -317,11 +421,12 @@\n           <span>Cámara lista</span>\r\n         </div>\r\n       )}\r\n \r\n+      {/* Overlay de escaneo */}\r\n       {cameraState === 'ready' && (\r\n         <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\r\n-          <div className=\"border-4 border-blue-500 rounded-lg w-40 h-40 md:w-44 md:h-44 lg:w-48 lg:h-48 animate-pulse\" style={{ maxWidth: 'min(60%, 200px)', maxHeight: 'min(60%, 200px)' }}></div>\r\n+          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\r\n         </div>\r\n       )}\r\n     </div>\r\n   );\r\n"
                },
                {
                    "date": 1764108083058,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,435 +1,435 @@\n-// CameraOptimized.jsx - Versión Corregida y Robusta\r\n-import React, { useState, useEffect, useRef } from 'react';\r\n-import { Html5Qrcode } from 'html5-qrcode';\r\n-import CameraErrorRecovery from './CameraErrorRecovery';\r\n-\r\n-const CameraOptimized = ({ \r\n-  scannerId = 'qr-reader',\r\n-  onScanSuccess, \r\n-  onScanFailure,\r\n-  onCameraError,\r\n-  isActive,\r\n-  config = {}\r\n-}) => {\r\n-  const [cameraState, setCameraState] = useState('idle'); // 'idle', 'checking', 'ready', 'error'\r\n-  const [errorDetails, setErrorDetails] = useState(null);\r\n-  const scannerRef = useRef(null);\r\n-  const containerRef = useRef(null);\r\n-  const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\r\n-\r\n-  const defaultConfig = {\r\n-    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\r\n-    qrbox: { width: 300, height: 300 }, // Aumentado de 250x250 para mejor detección\r\n-    aspectRatio: 1.0,\r\n-    videoConstraints: {\r\n-      facingMode: 'environment',\r\n-      width: { ideal: 1280 },\r\n-      height: { ideal: 720 }\r\n-    },\r\n-    ...config\r\n-  };\r\n-\r\n-  // Actualizar ref cuando isActive cambia\r\n-  useEffect(() => {\r\n-    isActiveRef.current = isActive;\r\n-  }, [isActive]);\r\n-\r\n-  useEffect(() => {\r\n-    // Solo inicializar si isActive es true y estamos en estado idle o error\r\n-    if (isActive && (cameraState === 'idle' || cameraState === 'error')) {\r\n-      initializeCamera();\r\n-    } else if (!isActive) {\r\n-      // Si no está activo, detener la cámara y resetear estado\r\n-      stopCamera();\r\n-      if (cameraState !== 'idle' && cameraState !== 'checking') {\r\n-        setCameraState('idle');\r\n-      }\r\n-    }\r\n-\r\n-    return () => {\r\n-      // Cleanup: detener cámara si el componente se desmonta o isActive cambia a false\r\n-      if (!isActive && scannerRef.current) {\r\n-        stopCamera();\r\n-      }\r\n-    };\r\n-    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n-  }, [isActive]);\r\n-\r\n-  const initializeCamera = async () => {\r\n-    // Verificar que isActive sigue siendo true antes de continuar (usar ref para valor actualizado)\r\n-    if (!isActiveRef.current) {\r\n-      console.log('Inicialización cancelada: isActive es false');\r\n-      return;\r\n-    }\r\n-\r\n-    try {\r\n-      setCameraState('checking');\r\n-      setErrorDetails(null);\r\n-      \r\n-      // 1. Verificar si el navegador soporta la API\r\n-      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\r\n-        throw new Error('NAVEGADOR_NO_COMPATIBLE');\r\n-      }\r\n-\r\n-      // 2. Verificar permisos existentes (si está disponible)\r\n-      // Nota: La API de permisos puede no estar disponible en todos los navegadores\r\n-      let permissionState = 'prompt';\r\n-      try {\r\n-        if (navigator.permissions && navigator.permissions.query) {\r\n-          const permission = await navigator.permissions.query({ name: 'camera' });\r\n-          permissionState = permission.state;\r\n-          \r\n-          if (permission.state === 'denied') {\r\n-            throw new Error('PERMISSION_DENIED');\r\n-          }\r\n-        }\r\n-      } catch (permError) {\r\n-        // Si el error es específicamente PERMISSION_DENIED, propagarlo\r\n-        if (permError.message === 'PERMISSION_DENIED') {\r\n-          throw permError;\r\n-        }\r\n-        // Si la API de permisos no está disponible, continuar e intentar getUserMedia\r\n-        console.log('API de permisos no disponible, intentando getUserMedia directamente');\r\n-      }\r\n-\r\n-      // 3. Obtener cámaras disponibles\r\n-      // Estrategia: primero solicitar permisos, luego enumerar dispositivos\r\n-      let cameras = [];\r\n-      \r\n-      try {\r\n-        // Primero intentar obtener permisos (necesario para enumerar dispositivos en algunos navegadores)\r\n-        let stream = null;\r\n-        try {\r\n-          stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n-          // Limpiar stream inmediatamente después de obtener permisos\r\n-          stream.getTracks().forEach(track => track.stop());\r\n-          \r\n-          // Esperar un momento para que los permisos se propaguen\r\n-          await new Promise(resolve => setTimeout(resolve, 200));\r\n-        } catch (permError) {\r\n-          // Si getUserMedia falla, es un problema de permisos\r\n-          if (permError.name === 'NotAllowedError' || permError.name === 'PermissionDeniedError') {\r\n-            throw new Error('PERMISSION_DENIED');\r\n-          }\r\n-          // Si es NotFoundError, puede ser que no haya cámara\r\n-          if (permError.name === 'NotFoundError' || permError.name === 'DevicesNotFoundError') {\r\n-            throw new Error('NO_CAMERA_AVAILABLE');\r\n-          }\r\n-          // Otros errores también pueden ser de permisos\r\n-          throw new Error('PERMISSION_DENIED');\r\n-        }\r\n-\r\n-        // Intentar obtener cámaras usando Html5Qrcode (método preferido)\r\n-        try {\r\n-          cameras = await Html5Qrcode.getCameras();\r\n-        } catch (html5Error) {\r\n-          console.warn('Html5Qrcode.getCameras() falló, usando enumerateDevices como alternativa:', html5Error);\r\n-          \r\n-          // Fallback: usar enumerateDevices directamente\r\n-          const devices = await navigator.mediaDevices.enumerateDevices();\r\n-          const videoDevices = devices.filter(device => device.kind === 'videoinput');\r\n-          \r\n-          if (videoDevices.length === 0) {\r\n-            throw new Error('NO_CAMERA_AVAILABLE');\r\n-          }\r\n-          \r\n-          // Convertir dispositivos al formato que espera Html5Qrcode\r\n-          cameras = videoDevices.map(device => ({\r\n-            id: device.deviceId,\r\n-            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\r\n-          }));\r\n-        }\r\n-\r\n-        // Verificar que tenemos cámaras disponibles\r\n-        if (!cameras || cameras.length === 0) {\r\n-          // Último intento: usar enumerateDevices directamente\r\n-          const devices = await navigator.mediaDevices.enumerateDevices();\r\n-          const videoDevices = devices.filter(device => device.kind === 'videoinput');\r\n-          \r\n-          if (videoDevices.length === 0) {\r\n-            throw new Error('NO_CAMERA_AVAILABLE');\r\n-          }\r\n-          \r\n-          cameras = videoDevices.map(device => ({\r\n-            id: device.deviceId,\r\n-            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\r\n-          }));\r\n-        }\r\n-      } catch (error) {\r\n-        // Si el error ya es PERMISSION_DENIED o NO_CAMERA_AVAILABLE, propagarlo\r\n-        if (error.message === 'PERMISSION_DENIED' || error.message === 'NO_CAMERA_AVAILABLE') {\r\n-          throw error;\r\n-        }\r\n-        // Para otros errores, intentar determinar la causa\r\n-        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\r\n-          throw new Error('PERMISSION_DENIED');\r\n-        }\r\n-        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\r\n-          throw new Error('NO_CAMERA_AVAILABLE');\r\n-        }\r\n-        // Si no podemos determinar, asumir que no hay cámara\r\n-        console.error('Error desconocido al obtener cámaras:', error);\r\n-        throw new Error('NO_CAMERA_AVAILABLE');\r\n-      }\r\n-\r\n-      // Verificar nuevamente que isActive sigue siendo true antes de inicializar scanner\r\n-      if (!isActiveRef.current) {\r\n-        console.log('Inicialización cancelada: isActive cambió a false durante la verificación');\r\n-        setCameraState('idle');\r\n-        return;\r\n-      }\r\n-\r\n-      // 4. Inicializar scanner con configuración robusta\r\n-      await initializeScanner(cameras);\r\n-    } catch (error) {\r\n-      // Solo manejar el error si isActive sigue siendo true (usar ref para valor actualizado)\r\n-      if (isActiveRef.current) {\r\n-        handleCameraError(error);\r\n-      } else {\r\n-        console.log('Error ignorado porque isActive es false:', error);\r\n-        setCameraState('idle');\r\n-      }\r\n-    }\r\n-  };\r\n-\r\n-  const initializeScanner = async (cameras) => {\r\n-    try {\r\n-      // Crear instancia de Html5Qrcode\r\n-      const html5QrCode = new Html5Qrcode(scannerId);\r\n-      scannerRef.current = html5QrCode;\r\n-\r\n-      // Seleccionar mejor cámara (trasera si está disponible)\r\n-      let cameraId = cameras[0].id;\r\n-      const backCamera = cameras.find(camera => \r\n-        camera.label && (\r\n-          camera.label.toLowerCase().includes('back') || \r\n-          camera.label.toLowerCase().includes('rear') ||\r\n-          camera.label.toLowerCase().includes('environment')\r\n-        )\r\n-      );\r\n-      \r\n-      if (backCamera && backCamera.id) {\r\n-        cameraId = backCamera.id;\r\n-      }\r\n-\r\n-      // Intentar iniciar con la cámara seleccionada\r\n-      let startSuccess = false;\r\n-      let lastError = null;\r\n-      \r\n-      // Intentar con la cámara preferida primero\r\n-      try {\r\n-        await html5QrCode.start(\r\n-          cameraId,\r\n-          defaultConfig,\r\n-          onScanSuccess,\r\n-          onScanFailure\r\n-        );\r\n-        startSuccess = true;\r\n-        setCameraState('ready');\r\n-        console.log('Cámara iniciada correctamente:', cameraId);\r\n-      } catch (startError) {\r\n-        console.warn(`Error iniciando con cámara ${cameraId}, intentando otras cámaras:`, startError);\r\n-        lastError = startError;\r\n-        \r\n-        // Limpiar antes de intentar otras cámaras\r\n-        try {\r\n-          await html5QrCode.clear();\r\n-        } catch (clearError) {\r\n-          // Ignorar errores al limpiar\r\n-        }\r\n-        \r\n-        // Si falla, intentar con otras cámaras disponibles\r\n-        for (let i = 0; i < cameras.length; i++) {\r\n-          if (cameras[i].id === cameraId) continue; // Ya intentamos esta\r\n-          \r\n-          try {\r\n-            // Crear nueva instancia para cada intento\r\n-            const newHtml5QrCode = new Html5Qrcode(scannerId);\r\n-            await newHtml5QrCode.start(\r\n-              cameras[i].id,\r\n-              defaultConfig,\r\n-              onScanSuccess,\r\n-              onScanFailure\r\n-            );\r\n-            scannerRef.current = newHtml5QrCode;\r\n-            startSuccess = true;\r\n-            setCameraState('ready');\r\n-            console.log('Cámara iniciada correctamente (fallback):', cameras[i].id);\r\n-            break;\r\n-          } catch (fallbackError) {\r\n-            console.warn(`Error con cámara ${cameras[i].id}:`, fallbackError);\r\n-            lastError = fallbackError;\r\n-            // Limpiar antes del siguiente intento\r\n-            try {\r\n-              await html5QrCode.clear();\r\n-            } catch (e) {\r\n-              // Ignorar\r\n-            }\r\n-            continue;\r\n-          }\r\n-        }\r\n-      }\r\n-      \r\n-      if (!startSuccess) {\r\n-        throw new Error(`SCANNER_INIT_FAILED: ${lastError?.message || 'No se pudo iniciar ninguna cámara'}`);\r\n-      }\r\n-    } catch (error) {\r\n-      throw new Error(`SCANNER_INIT_FAILED: ${error.message}`);\r\n-    }\r\n-  };\r\n-\r\n-  const handleCameraError = (error) => {\r\n-    console.error('Error de cámara:', error);\r\n-    \r\n-    let errorType = 'unknown';\r\n-    let userMessage = 'Error desconocido con la cámara';\r\n-    let recoverySteps = [];\r\n-\r\n-    if (error.message.includes('PERMISSION_DENIED') || error.message.includes('NotAllowedError')) {\r\n-      errorType = 'permission_denied';\r\n-      userMessage = 'Permisos de cámara denegados';\r\n-      recoverySteps = getPermissionRecoverySteps();\r\n-    } else if (error.message.includes('NO_CAMERA_AVAILABLE') || error.message.includes('NotFoundError')) {\r\n-      errorType = 'no_camera';\r\n-      userMessage = 'No se encontró cámara disponible';\r\n-      recoverySteps = getNoCameraRecoverySteps();\r\n-    } else if (error.message.includes('SCANNER_INIT_FAILED')) {\r\n-      errorType = 'scanner_failed';\r\n-      userMessage = 'Error al inicializar el escáner';\r\n-      recoverySteps = getScannerRecoverySteps();\r\n-    } else if (error.message.includes('NAVEGADOR_NO_COMPATIBLE')) {\r\n-      errorType = 'browser_not_supported';\r\n-      userMessage = 'Navegador no compatible';\r\n-      recoverySteps = getBrowserRecoverySteps();\r\n-    }\r\n-\r\n-    setCameraState('error');\r\n-    setErrorDetails({\r\n-      type: errorType,\r\n-      message: userMessage,\r\n-      recoverySteps,\r\n-      originalError: error.message\r\n-    });\r\n-\r\n-    if (onCameraError) {\r\n-      onCameraError({ type: errorType, message: userMessage });\r\n-    }\r\n-  };\r\n-\r\n-  const getPermissionRecoverySteps = () => [\r\n-    'Haz clic en el ícono de candado o cámara en la barra de direcciones',\r\n-    'Selecciona \"Permitir\" para el acceso a la cámara',\r\n-    'Recarga la página después de permitir los permisos',\r\n-    'Si no ves la opción, revisa la configuración de privacidad de tu navegador'\r\n-  ];\r\n-\r\n-  const getNoCameraRecoverySteps = () => [\r\n-    'Verifica que tu dispositivo tenga una cámara conectada y funcionando',\r\n-    'Asegúrate de que la cámara no esté siendo usada por otra aplicación',\r\n-    'Si estás en una computadora, verifica que la cámara esté conectada correctamente',\r\n-    'Si estás en un dispositivo móvil, verifica que la cámara funcione en otras aplicaciones',\r\n-    'Intenta recargar la página después de conectar la cámara',\r\n-    'Usa el modo de entrada manual como alternativa mientras resuelves el problema'\r\n-  ];\r\n-\r\n-  const getScannerRecoverySteps = () => [\r\n-    'Recarga la página e intenta nuevamente',\r\n-    'Prueba con un navegador diferente (Chrome, Firefox)',\r\n-    'Verifica que tu cámara funcione en otras aplicaciones',\r\n-    'Contacta al soporte técnico si el problema persiste'\r\n-  ];\r\n-\r\n-  const getBrowserRecoverySteps = () => [\r\n-    'Actualiza tu navegador a la última versión',\r\n-    'Usa Google Chrome, Mozilla Firefox o Microsoft Edge',\r\n-    'Verifica que JavaScript esté habilitado',\r\n-    'Contacta al administrador del sistema si el problema persiste'\r\n-  ];\r\n-\r\n-  const retryCamera = async () => {\r\n-    setCameraState('idle');\r\n-    setErrorDetails(null);\r\n-    await initializeCamera();\r\n-  };\r\n-\r\n-  const requestCameraPermission = async () => {\r\n-    try {\r\n-      // Solicitar permisos de manera directa\r\n-      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\r\n-      // Limpiar stream inmediatamente\r\n-      stream.getTracks().forEach(track => track.stop());\r\n-      // Reintentar inicialización\r\n-      await retryCamera();\r\n-    } catch (error) {\r\n-      handleCameraError(error);\r\n-    }\r\n-  };\r\n-\r\n-  const stopCamera = async () => {\r\n-    if (scannerRef.current) {\r\n-      try {\r\n-        if (scannerRef.current.isScanning) {\r\n-          await scannerRef.current.stop();\r\n-        }\r\n-        await scannerRef.current.clear();\r\n-      } catch (error) {\r\n-        console.error('Error deteniendo cámara:', error);\r\n-      } finally {\r\n-        scannerRef.current = null;\r\n-      }\r\n-    }\r\n-  };\r\n-\r\n-  if (!isActive) {\r\n-    return (\r\n-      <div className=\"bg-gray-100 rounded-lg p-12 text-center\">\r\n-        <svg className=\"w-24 h-24 mx-auto text-gray-400 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\r\n-          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z\" />\r\n-        </svg>\r\n-        <p className=\"text-gray-600 text-lg mb-2\">Cámara inactiva</p>\r\n-        <p className=\"text-gray-500 text-sm\">Activa el scanner para comenzar</p>\r\n-      </div>\r\n-    );\r\n-  }\r\n-\r\n-  return (\r\n-    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\r\n-      <div \r\n-        id={scannerId} \r\n-        ref={containerRef}\r\n-        className=\"w-full h-full\"\r\n-      />\r\n-      \r\n-      {cameraState === 'checking' && (\r\n-        <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\r\n-          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-600 mb-4\"></div>\r\n-          <p className=\"text-yellow-800 font-medium\">Inicializando cámara...</p>\r\n-        </div>\r\n-      )}\r\n-\r\n-      {cameraState === 'error' && errorDetails && (\r\n-        <CameraErrorRecovery \r\n-          errorDetails={errorDetails}\r\n-          onRetry={retryCamera}\r\n-          onRequestPermission={requestCameraPermission}\r\n-        />\r\n-      )}\r\n-\r\n-      {cameraState === 'ready' && (\r\n-        <div className=\"absolute top-4 left-4 bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 z-10\">\r\n-          <span>✅</span>\r\n-          <span>Cámara lista</span>\r\n-        </div>\r\n-      )}\r\n-\r\n-      {/* Overlay de escaneo */}\r\n-      {cameraState === 'ready' && (\r\n-        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\r\n-          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\r\n-        </div>\r\n-      )}\r\n-    </div>\r\n-  );\r\n-};\r\n-\r\n-export default CameraOptimized;\r\n+// CameraOptimized.jsx - Versión Corregida y Robusta\n+import React, { useState, useEffect, useRef } from 'react';\n+import { Html5Qrcode } from 'html5-qrcode';\n+import CameraErrorRecovery from './CameraErrorRecovery';\n+\n+const CameraOptimized = ({ \n+  scannerId = 'qr-reader',\n+  onScanSuccess, \n+  onScanFailure,\n+  onCameraError,\n+  isActive,\n+  config = {}\n+}) => {\n+  const [cameraState, setCameraState] = useState('idle'); // 'idle', 'checking', 'ready', 'error'\n+  const [errorDetails, setErrorDetails] = useState(null);\n+  const scannerRef = useRef(null);\n+  const containerRef = useRef(null);\n+  const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n+\n+  const defaultConfig = {\n+    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n+    qrbox: { width: 300, height: 300 }, // Aumentado de 250x250 para mejor detección\n+    aspectRatio: 1.0,\n+    videoConstraints: {\n+      facingMode: 'environment',\n+      width: { ideal: 1280 },\n+      height: { ideal: 720 }\n+    },\n+    ...config\n+  };\n+\n+  // Actualizar ref cuando isActive cambia\n+  useEffect(() => {\n+    isActiveRef.current = isActive;\n+  }, [isActive]);\n+\n+  useEffect(() => {\n+    // Solo inicializar si isActive es true y estamos en estado idle o error\n+    if (isActive && (cameraState === 'idle' || cameraState === 'error')) {\n+      initializeCamera();\n+    } else if (!isActive) {\n+      // Si no está activo, detener la cámara y resetear estado\n+      stopCamera();\n+      if (cameraState !== 'idle' && cameraState !== 'checking') {\n+        setCameraState('idle');\n+      }\n+    }\n+\n+    return () => {\n+      // Cleanup: detener cámara si el componente se desmonta o isActive cambia a false\n+      if (!isActive && scannerRef.current) {\n+        stopCamera();\n+      }\n+    };\n+    // eslint-disable-next-line react-hooks/exhaustive-deps\n+  }, [isActive]);\n+\n+  const initializeCamera = async () => {\n+    // Verificar que isActive sigue siendo true antes de continuar (usar ref para valor actualizado)\n+    if (!isActiveRef.current) {\n+      console.log('Inicialización cancelada: isActive es false');\n+      return;\n+    }\n+\n+    try {\n+      setCameraState('checking');\n+      setErrorDetails(null);\n+      \n+      // 1. Verificar si el navegador soporta la API\n+      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n+        throw new Error('NAVEGADOR_NO_COMPATIBLE');\n+      }\n+\n+      // 2. Verificar permisos existentes (si está disponible)\n+      // Nota: La API de permisos puede no estar disponible en todos los navegadores\n+      let permissionState = 'prompt';\n+      try {\n+        if (navigator.permissions && navigator.permissions.query) {\n+          const permission = await navigator.permissions.query({ name: 'camera' });\n+          permissionState = permission.state;\n+          \n+          if (permission.state === 'denied') {\n+            throw new Error('PERMISSION_DENIED');\n+          }\n+        }\n+      } catch (permError) {\n+        // Si el error es específicamente PERMISSION_DENIED, propagarlo\n+        if (permError.message === 'PERMISSION_DENIED') {\n+          throw permError;\n+        }\n+        // Si la API de permisos no está disponible, continuar e intentar getUserMedia\n+        console.log('API de permisos no disponible, intentando getUserMedia directamente');\n+      }\n+\n+      // 3. Obtener cámaras disponibles\n+      // Estrategia: primero solicitar permisos, luego enumerar dispositivos\n+      let cameras = [];\n+      \n+      try {\n+        // Primero intentar obtener permisos (necesario para enumerar dispositivos en algunos navegadores)\n+        let stream = null;\n+        try {\n+          stream = await navigator.mediaDevices.getUserMedia({ video: true });\n+          // Limpiar stream inmediatamente después de obtener permisos\n+          stream.getTracks().forEach(track => track.stop());\n+          \n+          // Esperar un momento para que los permisos se propaguen\n+          await new Promise(resolve => setTimeout(resolve, 200));\n+        } catch (permError) {\n+          // Si getUserMedia falla, es un problema de permisos\n+          if (permError.name === 'NotAllowedError' || permError.name === 'PermissionDeniedError') {\n+            throw new Error('PERMISSION_DENIED');\n+          }\n+          // Si es NotFoundError, puede ser que no haya cámara\n+          if (permError.name === 'NotFoundError' || permError.name === 'DevicesNotFoundError') {\n+            throw new Error('NO_CAMERA_AVAILABLE');\n+          }\n+          // Otros errores también pueden ser de permisos\n+          throw new Error('PERMISSION_DENIED');\n+        }\n+\n+        // Intentar obtener cámaras usando Html5Qrcode (método preferido)\n+        try {\n+          cameras = await Html5Qrcode.getCameras();\n+        } catch (html5Error) {\n+          console.warn('Html5Qrcode.getCameras() falló, usando enumerateDevices como alternativa:', html5Error);\n+          \n+          // Fallback: usar enumerateDevices directamente\n+          const devices = await navigator.mediaDevices.enumerateDevices();\n+          const videoDevices = devices.filter(device => device.kind === 'videoinput');\n+          \n+          if (videoDevices.length === 0) {\n+            throw new Error('NO_CAMERA_AVAILABLE');\n+          }\n+          \n+          // Convertir dispositivos al formato que espera Html5Qrcode\n+          cameras = videoDevices.map(device => ({\n+            id: device.deviceId,\n+            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\n+          }));\n+        }\n+\n+        // Verificar que tenemos cámaras disponibles\n+        if (!cameras || cameras.length === 0) {\n+          // Último intento: usar enumerateDevices directamente\n+          const devices = await navigator.mediaDevices.enumerateDevices();\n+          const videoDevices = devices.filter(device => device.kind === 'videoinput');\n+          \n+          if (videoDevices.length === 0) {\n+            throw new Error('NO_CAMERA_AVAILABLE');\n+          }\n+          \n+          cameras = videoDevices.map(device => ({\n+            id: device.deviceId,\n+            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\n+          }));\n+        }\n+      } catch (error) {\n+        // Si el error ya es PERMISSION_DENIED o NO_CAMERA_AVAILABLE, propagarlo\n+        if (error.message === 'PERMISSION_DENIED' || error.message === 'NO_CAMERA_AVAILABLE') {\n+          throw error;\n+        }\n+        // Para otros errores, intentar determinar la causa\n+        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n+          throw new Error('PERMISSION_DENIED');\n+        }\n+        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n+          throw new Error('NO_CAMERA_AVAILABLE');\n+        }\n+        // Si no podemos determinar, asumir que no hay cámara\n+        console.error('Error desconocido al obtener cámaras:', error);\n+        throw new Error('NO_CAMERA_AVAILABLE');\n+      }\n+\n+      // Verificar nuevamente que isActive sigue siendo true antes de inicializar scanner\n+      if (!isActiveRef.current) {\n+        console.log('Inicialización cancelada: isActive cambió a false durante la verificación');\n+        setCameraState('idle');\n+        return;\n+      }\n+\n+      // 4. Inicializar scanner con configuración robusta\n+      await initializeScanner(cameras);\n+    } catch (error) {\n+      // Solo manejar el error si isActive sigue siendo true (usar ref para valor actualizado)\n+      if (isActiveRef.current) {\n+        handleCameraError(error);\n+      } else {\n+        console.log('Error ignorado porque isActive es false:', error);\n+        setCameraState('idle');\n+      }\n+    }\n+  };\n+\n+  const initializeScanner = async (cameras) => {\n+    try {\n+      // Crear instancia de Html5Qrcode\n+      const html5QrCode = new Html5Qrcode(scannerId);\n+      scannerRef.current = html5QrCode;\n+\n+      // Seleccionar mejor cámara (trasera si está disponible)\n+      let cameraId = cameras[0].id;\n+      const backCamera = cameras.find(camera => \n+        camera.label && (\n+          camera.label.toLowerCase().includes('back') || \n+          camera.label.toLowerCase().includes('rear') ||\n+          camera.label.toLowerCase().includes('environment')\n+        )\n+      );\n+      \n+      if (backCamera && backCamera.id) {\n+        cameraId = backCamera.id;\n+      }\n+\n+      // Intentar iniciar con la cámara seleccionada\n+      let startSuccess = false;\n+      let lastError = null;\n+      \n+      // Intentar con la cámara preferida primero\n+      try {\n+        await html5QrCode.start(\n+          cameraId,\n+          defaultConfig,\n+          onScanSuccess,\n+          onScanFailure\n+        );\n+        startSuccess = true;\n+        setCameraState('ready');\n+        console.log('Cámara iniciada correctamente:', cameraId);\n+      } catch (startError) {\n+        console.warn(`Error iniciando con cámara ${cameraId}, intentando otras cámaras:`, startError);\n+        lastError = startError;\n+        \n+        // Limpiar antes de intentar otras cámaras\n+        try {\n+          await html5QrCode.clear();\n+        } catch (clearError) {\n+          // Ignorar errores al limpiar\n+        }\n+        \n+        // Si falla, intentar con otras cámaras disponibles\n+        for (let i = 0; i < cameras.length; i++) {\n+          if (cameras[i].id === cameraId) continue; // Ya intentamos esta\n+          \n+          try {\n+            // Crear nueva instancia para cada intento\n+            const newHtml5QrCode = new Html5Qrcode(scannerId);\n+            await newHtml5QrCode.start(\n+              cameras[i].id,\n+              defaultConfig,\n+              onScanSuccess,\n+              onScanFailure\n+            );\n+            scannerRef.current = newHtml5QrCode;\n+            startSuccess = true;\n+            setCameraState('ready');\n+            console.log('Cámara iniciada correctamente (fallback):', cameras[i].id);\n+            break;\n+          } catch (fallbackError) {\n+            console.warn(`Error con cámara ${cameras[i].id}:`, fallbackError);\n+            lastError = fallbackError;\n+            // Limpiar antes del siguiente intento\n+            try {\n+              await html5QrCode.clear();\n+            } catch (e) {\n+              // Ignorar\n+            }\n+            continue;\n+          }\n+        }\n+      }\n+      \n+      if (!startSuccess) {\n+        throw new Error(`SCANNER_INIT_FAILED: ${lastError?.message || 'No se pudo iniciar ninguna cámara'}`);\n+      }\n+    } catch (error) {\n+      throw new Error(`SCANNER_INIT_FAILED: ${error.message}`);\n+    }\n+  };\n+\n+  const handleCameraError = (error) => {\n+    console.error('Error de cámara:', error);\n+    \n+    let errorType = 'unknown';\n+    let userMessage = 'Error desconocido con la cámara';\n+    let recoverySteps = [];\n+\n+    if (error.message.includes('PERMISSION_DENIED') || error.message.includes('NotAllowedError')) {\n+      errorType = 'permission_denied';\n+      userMessage = 'Permisos de cámara denegados';\n+      recoverySteps = getPermissionRecoverySteps();\n+    } else if (error.message.includes('NO_CAMERA_AVAILABLE') || error.message.includes('NotFoundError')) {\n+      errorType = 'no_camera';\n+      userMessage = 'No se encontró cámara disponible';\n+      recoverySteps = getNoCameraRecoverySteps();\n+    } else if (error.message.includes('SCANNER_INIT_FAILED')) {\n+      errorType = 'scanner_failed';\n+      userMessage = 'Error al inicializar el escáner';\n+      recoverySteps = getScannerRecoverySteps();\n+    } else if (error.message.includes('NAVEGADOR_NO_COMPATIBLE')) {\n+      errorType = 'browser_not_supported';\n+      userMessage = 'Navegador no compatible';\n+      recoverySteps = getBrowserRecoverySteps();\n+    }\n+\n+    setCameraState('error');\n+    setErrorDetails({\n+      type: errorType,\n+      message: userMessage,\n+      recoverySteps,\n+      originalError: error.message\n+    });\n+\n+    if (onCameraError) {\n+      onCameraError({ type: errorType, message: userMessage });\n+    }\n+  };\n+\n+  const getPermissionRecoverySteps = () => [\n+    'Haz clic en el ícono de candado o cámara en la barra de direcciones',\n+    'Selecciona \"Permitir\" para el acceso a la cámara',\n+    'Recarga la página después de permitir los permisos',\n+    'Si no ves la opción, revisa la configuración de privacidad de tu navegador'\n+  ];\n+\n+  const getNoCameraRecoverySteps = () => [\n+    'Verifica que tu dispositivo tenga una cámara conectada y funcionando',\n+    'Asegúrate de que la cámara no esté siendo usada por otra aplicación',\n+    'Si estás en una computadora, verifica que la cámara esté conectada correctamente',\n+    'Si estás en un dispositivo móvil, verifica que la cámara funcione en otras aplicaciones',\n+    'Intenta recargar la página después de conectar la cámara',\n+    'Usa el modo de entrada manual como alternativa mientras resuelves el problema'\n+  ];\n+\n+  const getScannerRecoverySteps = () => [\n+    'Recarga la página e intenta nuevamente',\n+    'Prueba con un navegador diferente (Chrome, Firefox)',\n+    'Verifica que tu cámara funcione en otras aplicaciones',\n+    'Contacta al soporte técnico si el problema persiste'\n+  ];\n+\n+  const getBrowserRecoverySteps = () => [\n+    'Actualiza tu navegador a la última versión',\n+    'Usa Google Chrome, Mozilla Firefox o Microsoft Edge',\n+    'Verifica que JavaScript esté habilitado',\n+    'Contacta al administrador del sistema si el problema persiste'\n+  ];\n+\n+  const retryCamera = async () => {\n+    setCameraState('idle');\n+    setErrorDetails(null);\n+    await initializeCamera();\n+  };\n+\n+  const requestCameraPermission = async () => {\n+    try {\n+      // Solicitar permisos de manera directa\n+      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n+      // Limpiar stream inmediatamente\n+      stream.getTracks().forEach(track => track.stop());\n+      // Reintentar inicialización\n+      await retryCamera();\n+    } catch (error) {\n+      handleCameraError(error);\n+    }\n+  };\n+\n+  const stopCamera = async () => {\n+    if (scannerRef.current) {\n+      try {\n+        if (scannerRef.current.isScanning) {\n+          await scannerRef.current.stop();\n+        }\n+        await scannerRef.current.clear();\n+      } catch (error) {\n+        console.error('Error deteniendo cámara:', error);\n+      } finally {\n+        scannerRef.current = null;\n+      }\n+    }\n+  };\n+\n+  if (!isActive) {\n+    return (\n+      <div className=\"bg-gray-100 rounded-lg p-12 text-center\">\n+        <svg className=\"w-24 h-24 mx-auto text-gray-400 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n+          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z\" />\n+        </svg>\n+        <p className=\"text-gray-600 text-lg mb-2\">Cámara inactiva</p>\n+        <p className=\"text-gray-500 text-sm\">Activa el scanner para comenzar</p>\n+      </div>\n+    );\n+  }\n+\n+  return (\n+    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n+      <div \n+        id={scannerId} \n+        ref={containerRef}\n+        className=\"w-full h-full\"\n+      />\n+      \n+      {cameraState === 'checking' && (\n+        <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\n+          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-600 mb-4\"></div>\n+          <p className=\"text-yellow-800 font-medium\">Inicializando cámara...</p>\n+        </div>\n+      )}\n+\n+      {cameraState === 'error' && errorDetails && (\n+        <CameraErrorRecovery \n+          errorDetails={errorDetails}\n+          onRetry={retryCamera}\n+          onRequestPermission={requestCameraPermission}\n+        />\n+      )}\n+\n+      {cameraState === 'ready' && (\n+        <div className=\"absolute top-4 left-4 bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 z-10\">\n+          <span>✅</span>\n+          <span>Cámara lista</span>\n+        </div>\n+      )}\n+\n+      {/* Overlay de escaneo */}\n+      {cameraState === 'ready' && (\n+        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\n+          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\n+        </div>\n+      )}\n+    </div>\n+  );\n+};\n+\n+export default CameraOptimized;\n"
                }
            ],
            "date": 1764022678785,
            "name": "Commit-0",
            "content": "// CameraOptimized.jsx - Versión Corregida y Robusta\nimport React, { useState, useEffect, useRef } from 'react';\nimport { Html5Qrcode } from 'html5-qrcode';\nimport CameraErrorRecovery from './CameraErrorRecovery';\n\nconst CameraOptimized = ({ \n  scannerId = 'qr-reader',\n  onScanSuccess, \n  onScanFailure,\n  onCameraError,\n  isActive,\n  config = {}\n}) => {\n  const [cameraState, setCameraState] = useState('idle'); // 'idle', 'checking', 'ready', 'error'\n  const [errorDetails, setErrorDetails] = useState(null);\n  const scannerRef = useRef(null);\n  const containerRef = useRef(null);\n  const isActiveRef = useRef(isActive); // Ref para verificar isActive durante operaciones asíncronas\n\n  const defaultConfig = {\n    fps: 30, // Aumentado de 10 a 30 para mejor rendimiento\n    qrbox: { width: 200, height: 200 }, // Reducido para que quepa completamente en la vista\n    aspectRatio: 1.0,\n    videoConstraints: {\n      facingMode: 'environment',\n      width: { ideal: 1280 },\n      height: { ideal: 720 }\n    },\n    ...config\n  };\n\n  // Actualizar ref cuando isActive cambia\n  useEffect(() => {\n    isActiveRef.current = isActive;\n  }, [isActive]);\n\n  useEffect(() => {\n    // Solo inicializar si isActive es true y estamos en estado idle o error\n    if (isActive && (cameraState === 'idle' || cameraState === 'error')) {\n      initializeCamera();\n    } else if (!isActive) {\n      // Si no está activo, detener la cámara y resetear estado\n      stopCamera();\n      if (cameraState !== 'idle' && cameraState !== 'checking') {\n        setCameraState('idle');\n      }\n    }\n\n    return () => {\n      // Cleanup: detener cámara si el componente se desmonta o isActive cambia a false\n      if (!isActive && scannerRef.current) {\n        stopCamera();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isActive]);\n\n  const initializeCamera = async () => {\n    // Verificar que isActive sigue siendo true antes de continuar (usar ref para valor actualizado)\n    if (!isActiveRef.current) {\n      console.log('Inicialización cancelada: isActive es false');\n      return;\n    }\n\n    try {\n      setCameraState('checking');\n      setErrorDetails(null);\n      \n      // 1. Verificar si el navegador soporta la API\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('NAVEGADOR_NO_COMPATIBLE');\n      }\n\n      // 2. Verificar permisos existentes (si está disponible)\n      // Nota: La API de permisos puede no estar disponible en todos los navegadores\n      let permissionState = 'prompt';\n      try {\n        if (navigator.permissions && navigator.permissions.query) {\n          const permission = await navigator.permissions.query({ name: 'camera' });\n          permissionState = permission.state;\n          \n          if (permission.state === 'denied') {\n            throw new Error('PERMISSION_DENIED');\n          }\n        }\n      } catch (permError) {\n        // Si el error es específicamente PERMISSION_DENIED, propagarlo\n        if (permError.message === 'PERMISSION_DENIED') {\n          throw permError;\n        }\n        // Si la API de permisos no está disponible, continuar e intentar getUserMedia\n        console.log('API de permisos no disponible, intentando getUserMedia directamente');\n      }\n\n      // 3. Obtener cámaras disponibles\n      // Estrategia: primero solicitar permisos, luego enumerar dispositivos\n      let cameras = [];\n      \n      try {\n        // Primero intentar obtener permisos (necesario para enumerar dispositivos en algunos navegadores)\n        let stream = null;\n        try {\n          stream = await navigator.mediaDevices.getUserMedia({ video: true });\n          // Limpiar stream inmediatamente después de obtener permisos\n          stream.getTracks().forEach(track => track.stop());\n          \n          // Esperar un momento para que los permisos se propaguen\n          await new Promise(resolve => setTimeout(resolve, 200));\n        } catch (permError) {\n          // Si getUserMedia falla, es un problema de permisos\n          if (permError.name === 'NotAllowedError' || permError.name === 'PermissionDeniedError') {\n            throw new Error('PERMISSION_DENIED');\n          }\n          // Si es NotFoundError, puede ser que no haya cámara\n          if (permError.name === 'NotFoundError' || permError.name === 'DevicesNotFoundError') {\n            throw new Error('NO_CAMERA_AVAILABLE');\n          }\n          // Otros errores también pueden ser de permisos\n          throw new Error('PERMISSION_DENIED');\n        }\n\n        // Intentar obtener cámaras usando Html5Qrcode (método preferido)\n        try {\n          cameras = await Html5Qrcode.getCameras();\n        } catch (html5Error) {\n          console.warn('Html5Qrcode.getCameras() falló, usando enumerateDevices como alternativa:', html5Error);\n          \n          // Fallback: usar enumerateDevices directamente\n          const devices = await navigator.mediaDevices.enumerateDevices();\n          const videoDevices = devices.filter(device => device.kind === 'videoinput');\n          \n          if (videoDevices.length === 0) {\n            throw new Error('NO_CAMERA_AVAILABLE');\n          }\n          \n          // Convertir dispositivos al formato que espera Html5Qrcode\n          cameras = videoDevices.map(device => ({\n            id: device.deviceId,\n            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\n          }));\n        }\n\n        // Verificar que tenemos cámaras disponibles\n        if (!cameras || cameras.length === 0) {\n          // Último intento: usar enumerateDevices directamente\n          const devices = await navigator.mediaDevices.enumerateDevices();\n          const videoDevices = devices.filter(device => device.kind === 'videoinput');\n          \n          if (videoDevices.length === 0) {\n            throw new Error('NO_CAMERA_AVAILABLE');\n          }\n          \n          cameras = videoDevices.map(device => ({\n            id: device.deviceId,\n            label: device.label || `Cámara ${device.deviceId.substring(0, 8)}`\n          }));\n        }\n      } catch (error) {\n        // Si el error ya es PERMISSION_DENIED o NO_CAMERA_AVAILABLE, propagarlo\n        if (error.message === 'PERMISSION_DENIED' || error.message === 'NO_CAMERA_AVAILABLE') {\n          throw error;\n        }\n        // Para otros errores, intentar determinar la causa\n        if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {\n          throw new Error('PERMISSION_DENIED');\n        }\n        if (error.name === 'NotFoundError' || error.name === 'DevicesNotFoundError') {\n          throw new Error('NO_CAMERA_AVAILABLE');\n        }\n        // Si no podemos determinar, asumir que no hay cámara\n        console.error('Error desconocido al obtener cámaras:', error);\n        throw new Error('NO_CAMERA_AVAILABLE');\n      }\n\n      // Verificar nuevamente que isActive sigue siendo true antes de inicializar scanner\n      if (!isActiveRef.current) {\n        console.log('Inicialización cancelada: isActive cambió a false durante la verificación');\n        setCameraState('idle');\n        return;\n      }\n\n      // 4. Inicializar scanner con configuración robusta\n      await initializeScanner(cameras);\n    } catch (error) {\n      // Solo manejar el error si isActive sigue siendo true (usar ref para valor actualizado)\n      if (isActiveRef.current) {\n        handleCameraError(error);\n      } else {\n        console.log('Error ignorado porque isActive es false:', error);\n        setCameraState('idle');\n      }\n    }\n  };\n\n  const initializeScanner = async (cameras) => {\n    try {\n      // Crear instancia de Html5Qrcode\n      const html5QrCode = new Html5Qrcode(scannerId);\n      scannerRef.current = html5QrCode;\n\n      // Seleccionar mejor cámara (trasera si está disponible)\n      let cameraId = cameras[0].id;\n      const backCamera = cameras.find(camera => \n        camera.label && (\n          camera.label.toLowerCase().includes('back') || \n          camera.label.toLowerCase().includes('rear') ||\n          camera.label.toLowerCase().includes('environment')\n        )\n      );\n      \n      if (backCamera && backCamera.id) {\n        cameraId = backCamera.id;\n      }\n\n      // Intentar iniciar con la cámara seleccionada\n      let startSuccess = false;\n      let lastError = null;\n      \n      // Intentar con la cámara preferida primero\n      try {\n        await html5QrCode.start(\n          cameraId,\n          defaultConfig,\n          onScanSuccess,\n          onScanFailure\n        );\n        startSuccess = true;\n        setCameraState('ready');\n        console.log('Cámara iniciada correctamente:', cameraId);\n      } catch (startError) {\n        console.warn(`Error iniciando con cámara ${cameraId}, intentando otras cámaras:`, startError);\n        lastError = startError;\n        \n        // Limpiar antes de intentar otras cámaras\n        try {\n          await html5QrCode.clear();\n        } catch (clearError) {\n          // Ignorar errores al limpiar\n        }\n        \n        // Si falla, intentar con otras cámaras disponibles\n        for (let i = 0; i < cameras.length; i++) {\n          if (cameras[i].id === cameraId) continue; // Ya intentamos esta\n          \n          try {\n            // Crear nueva instancia para cada intento\n            const newHtml5QrCode = new Html5Qrcode(scannerId);\n            await newHtml5QrCode.start(\n              cameras[i].id,\n              defaultConfig,\n              onScanSuccess,\n              onScanFailure\n            );\n            scannerRef.current = newHtml5QrCode;\n            startSuccess = true;\n            setCameraState('ready');\n            console.log('Cámara iniciada correctamente (fallback):', cameras[i].id);\n            break;\n          } catch (fallbackError) {\n            console.warn(`Error con cámara ${cameras[i].id}:`, fallbackError);\n            lastError = fallbackError;\n            // Limpiar antes del siguiente intento\n            try {\n              await html5QrCode.clear();\n            } catch (e) {\n              // Ignorar\n            }\n            continue;\n          }\n        }\n      }\n      \n      if (!startSuccess) {\n        throw new Error(`SCANNER_INIT_FAILED: ${lastError?.message || 'No se pudo iniciar ninguna cámara'}`);\n      }\n    } catch (error) {\n      throw new Error(`SCANNER_INIT_FAILED: ${error.message}`);\n    }\n  };\n\n  const handleCameraError = (error) => {\n    console.error('Error de cámara:', error);\n    \n    let errorType = 'unknown';\n    let userMessage = 'Error desconocido con la cámara';\n    let recoverySteps = [];\n\n    if (error.message.includes('PERMISSION_DENIED') || error.message.includes('NotAllowedError')) {\n      errorType = 'permission_denied';\n      userMessage = 'Permisos de cámara denegados';\n      recoverySteps = getPermissionRecoverySteps();\n    } else if (error.message.includes('NO_CAMERA_AVAILABLE') || error.message.includes('NotFoundError')) {\n      errorType = 'no_camera';\n      userMessage = 'No se encontró cámara disponible';\n      recoverySteps = getNoCameraRecoverySteps();\n    } else if (error.message.includes('SCANNER_INIT_FAILED')) {\n      errorType = 'scanner_failed';\n      userMessage = 'Error al inicializar el escáner';\n      recoverySteps = getScannerRecoverySteps();\n    } else if (error.message.includes('NAVEGADOR_NO_COMPATIBLE')) {\n      errorType = 'browser_not_supported';\n      userMessage = 'Navegador no compatible';\n      recoverySteps = getBrowserRecoverySteps();\n    }\n\n    setCameraState('error');\n    setErrorDetails({\n      type: errorType,\n      message: userMessage,\n      recoverySteps,\n      originalError: error.message\n    });\n\n    if (onCameraError) {\n      onCameraError({ type: errorType, message: userMessage });\n    }\n  };\n\n  const getPermissionRecoverySteps = () => [\n    'Haz clic en el ícono de candado o cámara en la barra de direcciones',\n    'Selecciona \"Permitir\" para el acceso a la cámara',\n    'Recarga la página después de permitir los permisos',\n    'Si no ves la opción, revisa la configuración de privacidad de tu navegador'\n  ];\n\n  const getNoCameraRecoverySteps = () => [\n    'Verifica que tu dispositivo tenga una cámara conectada y funcionando',\n    'Asegúrate de que la cámara no esté siendo usada por otra aplicación',\n    'Si estás en una computadora, verifica que la cámara esté conectada correctamente',\n    'Si estás en un dispositivo móvil, verifica que la cámara funcione en otras aplicaciones',\n    'Intenta recargar la página después de conectar la cámara',\n    'Usa el modo de entrada manual como alternativa mientras resuelves el problema'\n  ];\n\n  const getScannerRecoverySteps = () => [\n    'Recarga la página e intenta nuevamente',\n    'Prueba con un navegador diferente (Chrome, Firefox)',\n    'Verifica que tu cámara funcione en otras aplicaciones',\n    'Contacta al soporte técnico si el problema persiste'\n  ];\n\n  const getBrowserRecoverySteps = () => [\n    'Actualiza tu navegador a la última versión',\n    'Usa Google Chrome, Mozilla Firefox o Microsoft Edge',\n    'Verifica que JavaScript esté habilitado',\n    'Contacta al administrador del sistema si el problema persiste'\n  ];\n\n  const retryCamera = async () => {\n    setCameraState('idle');\n    setErrorDetails(null);\n    await initializeCamera();\n  };\n\n  const requestCameraPermission = async () => {\n    try {\n      // Solicitar permisos de manera directa\n      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n      // Limpiar stream inmediatamente\n      stream.getTracks().forEach(track => track.stop());\n      // Reintentar inicialización\n      await retryCamera();\n    } catch (error) {\n      handleCameraError(error);\n    }\n  };\n\n  const stopCamera = async () => {\n    if (scannerRef.current) {\n      try {\n        if (scannerRef.current.isScanning) {\n          await scannerRef.current.stop();\n        }\n        await scannerRef.current.clear();\n      } catch (error) {\n        console.error('Error deteniendo cámara:', error);\n      } finally {\n        scannerRef.current = null;\n      }\n    }\n  };\n\n  if (!isActive) {\n    return (\n      <div className=\"bg-gray-100 rounded-lg p-12 text-center\">\n        <svg className=\"w-24 h-24 mx-auto text-gray-400 mb-4\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n          <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 4v1m6 11h2m-6 0h-2v4m0-11v3m0 0h.01M12 12h4.01M16 20h4M4 12h4m12 0h.01M5 8h2a1 1 0 001-1V5a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1zm12 0h2a1 1 0 001-1V5a1 1 0 00-1-1h-2a1 1 0 00-1 1v2a1 1 0 001 1zM5 20h2a1 1 0 001-1v-2a1 1 0 00-1-1H5a1 1 0 00-1 1v2a1 1 0 001 1z\" />\n        </svg>\n        <p className=\"text-gray-600 text-lg mb-2\">Cámara inactiva</p>\n        <p className=\"text-gray-500 text-sm\">Activa el scanner para comenzar</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"relative w-full min-h-[400px] bg-gray-100 rounded-lg overflow-hidden\">\n      <div \n        id={scannerId} \n        ref={containerRef}\n        className=\"w-full h-full\"\n      />\n      \n      {cameraState === 'checking' && (\n        <div className=\"absolute inset-0 bg-yellow-50 flex flex-col items-center justify-center z-10\">\n          <div className=\"animate-spin rounded-full h-12 w-12 border-b-2 border-yellow-600 mb-4\"></div>\n          <p className=\"text-yellow-800 font-medium\">Inicializando cámara...</p>\n        </div>\n      )}\n\n      {cameraState === 'error' && errorDetails && (\n        <CameraErrorRecovery \n          errorDetails={errorDetails}\n          onRetry={retryCamera}\n          onRequestPermission={requestCameraPermission}\n        />\n      )}\n\n      {cameraState === 'ready' && (\n        <div className=\"absolute top-4 left-4 bg-green-500 text-white px-3 py-1 rounded-full text-xs font-semibold flex items-center gap-2 z-10\">\n          <span>✅</span>\n          <span>Cámara lista</span>\n        </div>\n      )}\n\n      {/* Overlay de escaneo */}\n      {cameraState === 'ready' && (\n        <div className=\"absolute inset-0 pointer-events-none flex items-center justify-center z-0 p-4\">\n          <div className=\"border-4 border-blue-500 rounded-lg w-48 h-48 md:w-52 md:h-52 lg:w-56 lg:h-56 animate-pulse\" style={{ maxWidth: 'min(70%, 240px)', maxHeight: 'min(70%, 240px)' }}></div>\n        </div>\n      )}\n    </div>\n  );\n};\n\nexport default CameraOptimized;\n"
        }
    ]
}