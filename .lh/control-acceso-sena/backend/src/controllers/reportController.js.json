{
    "sourceFile": "control-acceso-sena/backend/src/controllers/reportController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1764228719267,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764232818315,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,21 +1,23 @@\n // Report Controller - Generación de reportes\n import pool from '../utils/dbPool.js';\n import Access from '../models/Access.js';\n+import { getRegistroIdField } from '../utils/columnResolver.js';\n \n // Reporte diario de accesos\n export const getDailyReport = async (req, res) => {\n   try {\n     const { fecha } = req.query;\n     const targetDate = fecha || new Date().toISOString().split('T')[0];\n+    const idColumn = await getRegistroIdField();\n \n     // Estadísticas generales del día\n     const dailyStats = await Access.getDailyStats(targetDate);\n \n     // Accesos detallados del día\n     const [accessRows] = await pool.execute(\n       `SELECT \n-        r.id_registro_entrada_salida as id_acceso,\n+        r.${idColumn} as id_acceso,\n         r.tipo as tipo_acceso,\n         r.fecha_hora as fecha_entrada,\n         NULL as fecha_salida,\n         COALESCE(CONCAT(p.nombres, ' ', p.apellidos), p.nombre) as persona_nombre,\n@@ -226,12 +228,13 @@\n // Reporte de accesos por rol\n export const getRoleReport = async (req, res) => {\n   try {\n     const { rol, desde, hasta } = req.query;\n+    const idColumn = await getRegistroIdField();\n     \n-    let query = `\n+      let query = `\n       SELECT \n-        r.id_registro_entrada_salida as id_acceso,\n+        r.${idColumn} as id_acceso,\n         r.tipo as tipo_acceso,\n         r.fecha_hora as fecha_entrada,\n         NULL as fecha_salida,\n         COALESCE(CONCAT(p.nombres, ' ', p.apellidos), p.nombre) as persona_nombre,\n"
                }
            ],
            "date": 1764228719266,
            "name": "Commit-0",
            "content": "// Report Controller - Generación de reportes\nimport pool from '../utils/dbPool.js';\nimport Access from '../models/Access.js';\n\n// Reporte diario de accesos\nexport const getDailyReport = async (req, res) => {\n  try {\n    const { fecha } = req.query;\n    const targetDate = fecha || new Date().toISOString().split('T')[0];\n\n    // Estadísticas generales del día\n    const dailyStats = await Access.getDailyStats(targetDate);\n\n    // Accesos detallados del día\n    const [accessRows] = await pool.execute(\n      `SELECT \n        r.id_registro_entrada_salida as id_acceso,\n        r.tipo as tipo_acceso,\n        r.fecha_hora as fecha_entrada,\n        NULL as fecha_salida,\n        COALESCE(CONCAT(p.nombres, ' ', p.apellidos), p.nombre) as persona_nombre,\n        p.documento,\n        COALESCE(role.nombre_rol, 'sin rol') as rol,\n        u.nombre as registrado_por\n       FROM registros_entrada_salida r\n       INNER JOIN Personas p ON r.id_persona = p.id_persona\n       LEFT JOIN Roles role ON p.id_rol = role.id_rol\n       LEFT JOIN Usuarios u ON r.id_usuario_registro = u.id_usuario\n       WHERE DATE(r.fecha_hora) = ?\n       ORDER BY r.fecha_hora DESC`,\n      [targetDate]\n    );\n\n    // Accesos por rol\n    const [roleStats] = await pool.execute(\n      `SELECT \n        COALESCE(role.nombre_rol, 'sin rol') as rol,\n        COUNT(*) as total,\n        SUM(CASE WHEN r.tipo = 'ENTRADA' THEN 1 ELSE 0 END) as entradas,\n        SUM(CASE WHEN r.tipo = 'SALIDA' THEN 1 ELSE 0 END) as salidas\n       FROM registros_entrada_salida r\n       INNER JOIN Personas p ON r.id_persona = p.id_persona\n       LEFT JOIN Roles role ON p.id_rol = role.id_rol\n       WHERE DATE(r.fecha_hora) = ?\n       GROUP BY role.nombre_rol`,\n      [targetDate]\n    );\n\n    res.json({\n      success: true,\n      data: {\n        fecha: targetDate,\n        estadisticas: dailyStats,\n        accesos: accessRows,\n        porRol: roleStats,\n        totalRegistros: accessRows.length\n      }\n    });\n  } catch (error) {\n    console.error('❌ Error en getDailyReport:', error);\n    console.error('❌ Stack:', error.stack);\n    res.status(500).json({\n      success: false,\n      message: 'Error al generar reporte diario',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      details: process.env.NODE_ENV === 'development' ? error.stack : undefined\n    });\n  }\n};\n\n// Reporte semanal de accesos\nexport const getWeeklyReport = async (req, res) => {\n  try {\n    const { semana } = req.query; // Formato: YYYY-WW o fecha de inicio\n    \n    // Calcular rango de fechas de la semana\n    let startDate, endDate;\n    if (semana) {\n      // Si viene formato YYYY-WW, calcular fechas\n      const [year, week] = semana.split('-W');\n      const date = new Date(year, 0, 1 + (week - 1) * 7);\n      startDate = new Date(date.setDate(date.getDate() - date.getDay()));\n      endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + 6);\n    } else {\n      // Semana actual\n      const today = new Date();\n      startDate = new Date(today.setDate(today.getDate() - today.getDay()));\n      endDate = new Date(startDate);\n      endDate.setDate(endDate.getDate() + 6);\n    }\n\n    const startDateStr = startDate.toISOString().split('T')[0];\n    const endDateStr = endDate.toISOString().split('T')[0];\n\n    // Estadísticas por día de la semana\n    const [dailyStats] = await pool.execute(\n      `SELECT \n        DATE(r.fecha_hora) as fecha,\n        COUNT(*) as total_accesos,\n        SUM(CASE WHEN r.tipo = 'ENTRADA' THEN 1 ELSE 0 END) as entradas,\n        SUM(CASE WHEN r.tipo = 'SALIDA' THEN 1 ELSE 0 END) as salidas\n       FROM registros_entrada_salida r\n       WHERE DATE(r.fecha_hora) BETWEEN ? AND ?\n       GROUP BY DATE(r.fecha_hora)\n       ORDER BY fecha ASC`,\n      [startDateStr, endDateStr]\n    );\n\n    // Estadísticas por rol\n    const [roleStats] = await pool.execute(\n      `SELECT \n        COALESCE(role.nombre_rol, 'sin rol') as rol,\n        COUNT(*) as total,\n        SUM(CASE WHEN r.tipo = 'ENTRADA' THEN 1 ELSE 0 END) as entradas,\n        SUM(CASE WHEN r.tipo = 'SALIDA' THEN 1 ELSE 0 END) as salidas\n       FROM registros_entrada_salida r\n       INNER JOIN Personas p ON r.id_persona = p.id_persona\n       LEFT JOIN Roles role ON p.id_rol = role.id_rol\n       WHERE DATE(r.fecha_hora) BETWEEN ? AND ?\n       GROUP BY role.nombre_rol`,\n      [startDateStr, endDateStr]\n    );\n\n    // Total de la semana\n    const [totalStats] = await pool.execute(\n      `SELECT \n        COUNT(*) as total_accesos,\n        SUM(CASE WHEN r.tipo = 'ENTRADA' THEN 1 ELSE 0 END) as total_entradas,\n        SUM(CASE WHEN r.tipo = 'SALIDA' THEN 1 ELSE 0 END) as total_salidas\n       FROM registros_entrada_salida r\n       WHERE DATE(r.fecha_hora) BETWEEN ? AND ?`,\n      [startDateStr, endDateStr]\n    );\n\n    res.json({\n      success: true,\n      data: {\n        semana: semana || 'actual',\n        fechaInicio: startDateStr,\n        fechaFin: endDateStr,\n        totales: totalStats[0],\n        porDia: dailyStats,\n        porRol: roleStats\n      }\n    });\n  } catch (error) {\n    console.error('Error en getWeeklyReport:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al generar reporte semanal',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n\n// Reporte de visitantes\nexport const getVisitorsReport = async (req, res) => {\n  try {\n    const { desde, hasta } = req.query;\n    \n    let query = `\n      SELECT \n        v.id_visitante,\n        v.fecha_inicio,\n        v.fecha_fin,\n        v.estado,\n        v.motivo_visita,\n        v.contacto,\n        v.persona_visita,\n        COALESCE(CONCAT(p.nombres, ' ', p.apellidos), p.nombre) as persona_nombre,\n        p.documento,\n        p.tipo_documento\n      FROM Visitantes v\n      INNER JOIN Personas p ON v.id_persona = p.id_persona\n      WHERE 1=1\n    `;\n    const params = [];\n\n    if (desde) {\n      query += ' AND DATE(v.fecha_inicio) >= ?';\n      params.push(desde);\n    }\n\n    if (hasta) {\n      query += ' AND DATE(v.fecha_inicio) <= ?';\n      params.push(hasta);\n    }\n\n    query += ' ORDER BY v.fecha_inicio DESC';\n\n    const [visitors] = await pool.execute(query, params);\n\n    // Estadísticas\n    const [stats] = await pool.execute(\n      `SELECT \n        COUNT(*) as total,\n        SUM(CASE WHEN estado = 'activo' THEN 1 ELSE 0 END) as activos,\n        SUM(CASE WHEN estado = 'finalizado' THEN 1 ELSE 0 END) as finalizados,\n        SUM(CASE WHEN estado = 'expirado' THEN 1 ELSE 0 END) as expirados\n       FROM Visitantes v\n       WHERE 1=1\n       ${desde ? 'AND DATE(v.fecha_inicio) >= ?' : ''}\n       ${hasta ? 'AND DATE(v.fecha_inicio) <= ?' : ''}`,\n      params\n    );\n\n    res.json({\n      success: true,\n      data: {\n        visitantes: visitors,\n        estadisticas: stats[0],\n        rango: { desde: desde || 'inicio', hasta: hasta || 'actual' }\n      }\n    });\n  } catch (error) {\n    console.error('Error en getVisitorsReport:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al generar reporte de visitantes',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n\n// Reporte de accesos por rol\nexport const getRoleReport = async (req, res) => {\n  try {\n    const { rol, desde, hasta } = req.query;\n    \n    let query = `\n      SELECT \n        r.id_registro_entrada_salida as id_acceso,\n        r.tipo as tipo_acceso,\n        r.fecha_hora as fecha_entrada,\n        NULL as fecha_salida,\n        COALESCE(CONCAT(p.nombres, ' ', p.apellidos), p.nombre) as persona_nombre,\n        p.documento,\n        COALESCE(role.nombre_rol, 'sin rol') as rol,\n        u.nombre as registrado_por\n      FROM registros_entrada_salida r\n      INNER JOIN Personas p ON r.id_persona = p.id_persona\n      LEFT JOIN Roles role ON p.id_rol = role.id_rol\n      LEFT JOIN Usuarios u ON r.id_usuario_registro = u.id_usuario\n      WHERE 1=1\n    `;\n    const params = [];\n\n    if (rol) {\n      query += ' AND role.nombre_rol = ?';\n      params.push(rol);\n    }\n\n    if (desde) {\n      query += ' AND DATE(a.fecha_entrada) >= ?';\n      params.push(desde);\n    }\n\n    if (hasta) {\n      query += ' AND DATE(a.fecha_entrada) <= ?';\n      params.push(hasta);\n    }\n\n    query += ' ORDER BY a.fecha_entrada DESC';\n\n    const [accesses] = await pool.execute(query, params);\n\n    // Estadísticas del rol\n    const [stats] = await pool.execute(\n      `SELECT \n        COUNT(*) as total,\n        SUM(CASE WHEN r.tipo = 'ENTRADA' THEN 1 ELSE 0 END) as entradas,\n        SUM(CASE WHEN r.tipo = 'SALIDA' THEN 1 ELSE 0 END) as salidas\n       FROM registros_entrada_salida r\n       INNER JOIN Personas p ON r.id_persona = p.id_persona\n       LEFT JOIN Roles role ON p.id_rol = role.id_rol\n       WHERE 1=1\n       ${rol ? 'AND role.nombre_rol = ?' : ''}\n       ${desde ? 'AND DATE(r.fecha_hora) >= ?' : ''}\n       ${hasta ? 'AND DATE(r.fecha_hora) <= ?' : ''}`,\n      params\n    );\n\n    res.json({\n      success: true,\n      data: {\n        rol: rol || 'todos',\n        accesos: accesses,\n        estadisticas: stats[0],\n        rango: { desde: desde || 'inicio', hasta: hasta || 'actual' }\n      }\n    });\n  } catch (error) {\n    console.error('Error en getRoleReport:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al generar reporte por rol',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n\n// Exportar reporte a CSV (para Excel)\nexport const exportReportCSV = async (req, res) => {\n  try {\n    const { tipo, fecha, semana, desde, hasta, rol } = req.body;\n\n    let data = [];\n    let filename = 'reporte';\n    let headers = [];\n\n    switch (tipo) {\n      case 'daily':\n        const dailyStats = await Access.getDailyStats(fecha || new Date().toISOString().split('T')[0]);\n        const [dailyAccesses] = await pool.execute(\n          `SELECT \n            r.fecha_hora,\n            r.tipo,\n            COALESCE(CONCAT(p.nombres, ' ', p.apellidos), p.nombre) as persona_nombre,\n            p.documento,\n            COALESCE(role.nombre_rol, 'sin rol') as rol,\n            u.nombre as registrado_por\n           FROM registros_entrada_salida r\n           INNER JOIN Personas p ON r.id_persona = p.id_persona\n           LEFT JOIN Roles role ON p.id_rol = role.id_rol\n           LEFT JOIN Usuarios u ON r.id_usuario_registro = u.id_usuario\n           WHERE DATE(r.fecha_hora) = ?\n           ORDER BY r.fecha_hora DESC`,\n          [fecha || new Date().toISOString().split('T')[0]]\n        );\n        data = dailyAccesses;\n        headers = ['Fecha', 'Tipo', 'Persona', 'Documento', 'Rol', 'Registrado Por'];\n        filename = `reporte_diario_${fecha || new Date().toISOString().split('T')[0]}`;\n        break;\n        \n      case 'weekly':\n        const today = new Date();\n        const startDate = new Date(today.setDate(today.getDate() - today.getDay()));\n        const endDate = new Date(startDate);\n        endDate.setDate(endDate.getDate() + 6);\n        const startDateStr = startDate.toISOString().split('T')[0];\n        const endDateStr = endDate.toISOString().split('T')[0];\n        \n        const [weeklyData] = await pool.execute(\n          `SELECT \n            DATE(r.fecha_hora) as fecha,\n            COUNT(*) as total_accesos,\n            SUM(CASE WHEN r.tipo = 'ENTRADA' THEN 1 ELSE 0 END) as entradas,\n            SUM(CASE WHEN r.tipo = 'SALIDA' THEN 1 ELSE 0 END) as salidas\n           FROM registros_entrada_salida r\n           WHERE DATE(r.fecha_hora) BETWEEN ? AND ?\n           GROUP BY DATE(r.fecha_hora)\n           ORDER BY fecha ASC`,\n          [startDateStr, endDateStr]\n        );\n        data = weeklyData;\n        headers = ['Fecha', 'Total Accesos', 'Entradas', 'Salidas'];\n        filename = `reporte_semanal_${startDateStr}_${endDateStr}`;\n        break;\n        \n      case 'visitors':\n        let visitorQuery = `\n          SELECT \n            v.fecha_inicio,\n            v.fecha_fin,\n            v.estado,\n            v.motivo_visita,\n            p.nombre as persona_nombre,\n            p.documento\n          FROM Visitantes v\n          INNER JOIN Personas p ON v.id_persona = p.id_persona\n          WHERE 1=1\n        `;\n        const visitorParams = [];\n        \n        if (desde) {\n          visitorQuery += ' AND DATE(v.fecha_inicio) >= ?';\n          visitorParams.push(desde);\n        }\n        if (hasta) {\n          visitorQuery += ' AND DATE(v.fecha_inicio) <= ?';\n          visitorParams.push(hasta);\n        }\n        visitorQuery += ' ORDER BY v.fecha_inicio DESC';\n        \n        const [visitorData] = await pool.execute(visitorQuery, visitorParams);\n        data = visitorData;\n        headers = ['Fecha Inicio', 'Fecha Fin', 'Estado', 'Motivo Visita', 'Persona', 'Documento'];\n        filename = `reporte_visitantes_${desde || 'inicio'}_${hasta || 'actual'}`;\n        break;\n        \n      default:\n        return res.status(400).json({\n          success: false,\n          message: 'Tipo de reporte no válido'\n        });\n    }\n\n    if (data.length === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'No hay datos para exportar'\n      });\n    }\n\n    // Convertir a CSV\n    const csvRows = [\n      headers.join(','),\n      ...data.map(row => {\n        const values = headers.map(header => {\n          // Mapear headers a campos de row\n          let value = '';\n          if (header === 'Fecha' || header === 'Fecha Inicio') {\n            value = row.fecha || row.fecha_inicio || '';\n          } else if (header === 'Fecha Fin') {\n            value = row.fecha_fin || '';\n          } else if (header === 'Tipo') {\n            value = row.tipo_acceso || '';\n          } else if (header === 'Persona') {\n            value = row.persona_nombre || '';\n          } else if (header === 'Documento') {\n            value = row.documento || '';\n          } else if (header === 'Rol') {\n            value = row.rol || '';\n          } else if (header === 'Registrado Por') {\n            value = row.registrado_por || 'Sistema';\n          } else if (header === 'Total Accesos') {\n            value = row.total_accesos || 0;\n          } else if (header === 'Entradas') {\n            value = row.entradas || 0;\n          } else if (header === 'Salidas') {\n            value = row.salidas || 0;\n          } else if (header === 'Estado') {\n            value = row.estado || '';\n          } else if (header === 'Motivo Visita') {\n            value = row.motivo_visita || '';\n          }\n          \n          return typeof value === 'string' ? `\"${value.replace(/\"/g, '\"\"')}\"` : value;\n        });\n        return values.join(',');\n      })\n    ];\n\n    const csv = csvRows.join('\\n');\n    const BOM = '\\uFEFF'; // Para Excel UTF-8\n\n    res.setHeader('Content-Type', 'text/csv; charset=utf-8');\n    res.setHeader('Content-Disposition', `attachment; filename=\"${filename}.csv\"`);\n    res.send(BOM + csv);\n  } catch (error) {\n    console.error('Error en exportReportCSV:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al exportar reporte',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n\n"
        }
    ]
}