{
    "sourceFile": "control-acceso-sena/backend/src/controllers/userController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764317089921,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764317089921,
            "name": "Commit-0",
            "content": "// User Controller\nimport User from '../models/User.js';\nimport pool from '../utils/dbPool.js';\nimport LogService from '../services/LogService.js';\n\nlet cachedPasswordColumns = null;\n\nconst getPasswordColumnInfo = async () => {\n  if (cachedPasswordColumns) {\n    return cachedPasswordColumns;\n  }\n\n  const [columns] = await pool.execute('SHOW COLUMNS FROM Usuarios');\n  const columnNames = columns.map(col => col.Field.toLowerCase());\n  cachedPasswordColumns = {\n    hasPasswordHash: columnNames.includes('password_hash'),\n    hasPasswords: columnNames.includes('passwords')\n  };\n\n  return cachedPasswordColumns;\n};\n\nconst isDigitString = (value) => /^\\d+$/.test(value);\n\nconst isSequentialDigits = (value) => {\n  if (!isDigitString(value) || value.length < 2) {\n    return false;\n  }\n\n  let ascending = true;\n  let descending = true;\n\n  for (let i = 1; i < value.length; i++) {\n    const prev = parseInt(value[i - 1], 10);\n    const current = parseInt(value[i], 10);\n    const diff = current - prev;\n    if (diff !== 1) ascending = false;\n    if (diff !== -1) descending = false;\n  }\n\n  return ascending || descending;\n};\n\nconst isRepeatedDigit = (value) => {\n  if (!isDigitString(value) || value.length < 8) {\n    return false;\n  }\n\n  const uniqueDigits = new Set(value.split(''));\n  return uniqueDigits.size === 1;\n};\n\nconst getPasswordPolicyError = (password) => {\n  if (!password || typeof password !== 'string') {\n    return 'La contraseña es requerida';\n  }\n  if (password.length < 8) {\n    return 'La contraseña debe tener al menos 8 caracteres';\n  }\n  if (isDigitString(password) && isSequentialDigits(password)) {\n    return 'La contraseña no puede ser una secuencia numérica consecutiva';\n  }\n  if (isRepeatedDigit(password)) {\n    return 'La contraseña no puede repetir el mismo número 8 veces o más';\n  }\n  return null;\n};\n\nlet cachedBcrypt = null;\nconst getBcrypt = async () => {\n  if (!cachedBcrypt) {\n    const bcryptModule = await import('bcryptjs');\n    cachedBcrypt = bcryptModule.default;\n  }\n  return cachedBcrypt;\n};\n\nexport const getUsers = async (req, res) => {\n  try {\n    const { rol, estado, search } = req.query;\n    \n    let query = 'SELECT id_usuario, nombre, email, rol, estado, fecha_creacion FROM Usuarios WHERE 1=1';\n    const params = [];\n\n    if (rol) {\n      query += ' AND rol = ?';\n      params.push(rol);\n    }\n\n    if (estado) {\n      query += ' AND estado = ?';\n      params.push(estado);\n    }\n\n    if (search) {\n      query += ' AND (nombre LIKE ? OR email LIKE ?)';\n      params.push(`%${search}%`, `%${search}%`);\n    }\n\n    query += ' ORDER BY fecha_creacion DESC';\n\n    const [rows] = await pool.execute(query, params);\n\n    res.json({\n      success: true,\n      count: rows.length,\n      users: rows\n    });\n  } catch (error) {\n    console.error('Error en getUsers:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al obtener usuarios'\n    });\n  }\n};\n\nexport const createUser = async (req, res) => {\n  try {\n    const { nombre, email, password, rol } = req.body;\n\n    if (!nombre || !email || !password || !rol) {\n      return res.status(400).json({\n        success: false,\n        message: 'Todos los campos son requeridos'\n      });\n    }\n\n    const passwordError = getPasswordPolicyError(password);\n    if (passwordError) {\n      return res.status(400).json({\n        success: false,\n        message: passwordError\n      });\n    }\n\n    // Verificar si el email ya existe\n    const existingUser = await User.findByEmail(email);\n    if (existingUser) {\n      return res.status(409).json({\n        success: false,\n        message: 'El email ya está registrado'\n      });\n    }\n\n    const userId = await User.create({ nombre, email, password, rol });\n\n    // Registrar en auditoría\n    await LogService.auditoria(\n      'Usuarios',\n      userId,\n      'INSERT',\n      null,\n      { nombre, email, rol },\n      req.user?.id,\n      req\n    );\n\n    // Registrar en logs de seguridad\n    await LogService.modificacionUsuario(\n      req.user?.id,\n      `Usuario creado: ${email}`,\n      { nuevo_usuario_id: userId, nombre, email, rol },\n      req\n    );\n\n    res.status(201).json({\n      success: true,\n      message: 'Usuario creado exitosamente',\n      user: {\n        id: userId,\n        nombre,\n        email,\n        rol\n      }\n    });\n  } catch (error) {\n    console.error('Error en createUser:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al crear usuario'\n    });\n  }\n};\n\nexport const updateUser = async (req, res) => {\n  try {\n    const { id } = req.params;\n    const { nombre, email, password, rol, estado, currentPassword } = req.body;\n    const targetId = parseInt(id, 10);\n    const passwordColumns = await getPasswordColumnInfo();\n    const selectFields = ['rol'];\n    if (passwordColumns.hasPasswordHash) selectFields.push('password_hash');\n    if (passwordColumns.hasPasswords) selectFields.push('passwords');\n\n    const [targetRows] = await pool.execute(\n      `SELECT ${selectFields.join(', ')} FROM Usuarios WHERE id_usuario = ?`,\n      [targetId]\n    );\n\n    if (targetRows.length === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Usuario no encontrado'\n      });\n    }\n\n    const targetRole = (targetRows[0].rol || '').toUpperCase();\n    const normalizedTargetRole = targetRole === 'ADMIN' ? 'ADMINISTRADOR' : targetRole;\n    const currentUserId = req.user?.id;\n    const storedPasswordHash = targetRows[0].password_hash || targetRows[0].passwords;\n    const isEditingSelf = currentUserId === targetId;\n\n    if (\n      normalizedTargetRole === 'ADMINISTRADOR' &&\n      currentUserId !== parseInt(id, 10)\n    ) {\n      return res.status(403).json({\n        success: false,\n        message: 'No puedes modificar a otro administrador'\n      });\n    }\n\n    const updates = [];\n    const params = [];\n\n    if (nombre) {\n      updates.push('nombre = ?');\n      params.push(nombre);\n    }\n\n    if (email) {\n      updates.push('email = ?');\n      params.push(email);\n    }\n\n    if (password) {\n      const passwordError = getPasswordPolicyError(password);\n      if (passwordError) {\n        return res.status(400).json({\n          success: false,\n          message: passwordError\n        });\n      }\n\n      if (isEditingSelf) {\n        if (!currentPassword) {\n          return res.status(400).json({\n            success: false,\n            message: 'Debes proporcionar tu contraseña actual para cambiarla'\n          });\n        }\n        if (!storedPasswordHash) {\n          return res.status(400).json({\n            success: false,\n            message: 'No se encontró la contraseña actual almacenada'\n          });\n        }\n\n        const bcrypt = await getBcrypt();\n        const matches = await bcrypt.compare(currentPassword, storedPasswordHash);\n        if (!matches) {\n          return res.status(400).json({\n            success: false,\n            message: 'La contraseña actual no coincide'\n          });\n        }\n      }\n\n      const passwordColumns = await getPasswordColumnInfo();\n      if (!passwordColumns.hasPasswordHash && !passwordColumns.hasPasswords) {\n        return res.status(500).json({\n          success: false,\n          message: 'La columna de contraseña no está disponible en la base de datos'\n        });\n      }\n\n      const bcrypt = await getBcrypt();\n      const passwordHash = await bcrypt.hash(password, 10);\n\n      if (passwordColumns.hasPasswordHash) {\n        updates.push('password_hash = ?');\n        params.push(passwordHash);\n      }\n\n      if (passwordColumns.hasPasswords) {\n        updates.push('passwords = ?');\n        params.push(passwordHash);\n      }\n    }\n\n    if (rol) {\n      updates.push('rol = ?');\n      params.push(rol);\n    }\n\n    if (estado) {\n      updates.push('estado = ?');\n      params.push(estado);\n    }\n\n    if (updates.length === 0) {\n      return res.status(400).json({\n        success: false,\n        message: 'No hay campos para actualizar'\n      });\n    }\n\n    params.push(id);\n\n    const [result] = await pool.execute(\n      `UPDATE Usuarios SET ${updates.join(', ')} WHERE id_usuario = ?`,\n      params\n    );\n\n    if (result.affectedRows === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Usuario no encontrado'\n      });\n    }\n\n    // Registrar en auditoría\n    const cambios = {};\n    if (nombre) cambios.nombre = nombre;\n    if (email) cambios.email = email;\n    if (rol) cambios.rol = rol;\n    if (estado) cambios.estado = estado;\n    if (password) cambios.password = '***cambiada***';\n\n    await LogService.auditoria(\n      'Usuarios',\n      parseInt(id, 10),\n      'UPDATE',\n      { id_usuario: id },\n      cambios,\n      req.user?.id,\n      req\n    );\n\n    // Registrar cambio de contraseña específicamente\n    if (password) {\n      await LogService.cambioPassword(\n        parseInt(id, 10),\n        email || `ID:${id}`,\n        req.user?.email || 'sistema',\n        req\n      );\n    }\n\n    // Registrar modificación general\n    await LogService.modificacionUsuario(\n      req.user?.id,\n      `Usuario actualizado: ID ${id}`,\n      { usuario_modificado_id: id, cambios },\n      req\n    );\n\n    res.json({\n      success: true,\n      message: 'Usuario actualizado exitosamente'\n    });\n  } catch (error) {\n    console.error('Error en updateUser:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al actualizar usuario',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n\nexport const deleteUser = async (req, res) => {\n  try {\n    const { id } = req.params;\n\n    // No permitir eliminar el propio usuario\n    if (parseInt(id) === req.user.id) {\n      return res.status(403).json({\n        success: false,\n        message: 'No puedes eliminar tu propio usuario'\n      });\n    }\n\n    const [userCheck] = await pool.execute(\n      'SELECT id_usuario, rol FROM Usuarios WHERE id_usuario = ?',\n      [id]\n    );\n\n    if (userCheck.length === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Usuario no encontrado'\n      });\n    }\n\n    const targetRole = (userCheck[0].rol || '').toUpperCase();\n    const normalizedTargetRole = targetRole === 'ADMIN' ? 'ADMINISTRADOR' : targetRole;\n\n    if (normalizedTargetRole === 'ADMINISTRADOR') {\n      return res.status(403).json({\n        success: false,\n        message: 'No puedes eliminar a otro administrador'\n      });\n    }\n\n    // Guardar datos antes de eliminar para auditoría\n    const [userData] = await pool.execute(\n      'SELECT nombre, email, rol FROM Usuarios WHERE id_usuario = ?',\n      [id]\n    );\n    const deletedUserData = userData[0] || {};\n\n    // Eliminar físicamente el usuario de la base de datos\n    const [result] = await pool.execute(\n      'DELETE FROM Usuarios WHERE id_usuario = ?',\n      [id]\n    );\n\n    if (result.affectedRows === 0) {\n      return res.status(404).json({\n        success: false,\n        message: 'Usuario no encontrado'\n      });\n    }\n\n    // Registrar en auditoría\n    await LogService.auditoria(\n      'Usuarios',\n      parseInt(id, 10),\n      'DELETE',\n      deletedUserData,\n      null,\n      req.user?.id,\n      req\n    );\n\n    // Registrar en logs de seguridad\n    await LogService.modificacionUsuario(\n      req.user?.id,\n      `Usuario eliminado: ${deletedUserData.email || id}`,\n      { usuario_eliminado_id: id, ...deletedUserData },\n      req\n    );\n\n    res.json({\n      success: true,\n      message: 'Usuario eliminado exitosamente'\n    });\n  } catch (error) {\n    console.error('Error en deleteUser:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al eliminar usuario',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n"
        }
    ]
}