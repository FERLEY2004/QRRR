{
    "sourceFile": "control-acceso-sena/backend/src/controllers/dashboardController.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1764017519086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764021352710,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -405,10 +405,92 @@\n     // 3. Leer datos de las tablas usando nombres correctos de columnas\n     let rows = [];\n     let sourceTable = null;\n     \n-    // Estrategia: Leer de Accesos primero (donde est√°n los datos actuales)\n-    if (accesosCount > 0) {\n+    // Estrategia: Leer de registros_entrada_salida primero (tabla principal - circuito abierto)\n+    // Luego intentar Accesos como respaldo (tabla de compatibilidad)\n+    if (registrosCount > 0) {\n+      console.log(`üìä [${requestId}] Intentando leer de tabla registros_entrada_salida primero (${registrosCount} registros disponibles)...`);\n+      \n+      try {\n+        // Verificar registros hu√©rfanos\n+        try {\n+          const [orphanCheck] = await pool.execute(`\n+            SELECT COUNT(*) as total_sin_persona\n+            FROM registros_entrada_salida r\n+            LEFT JOIN Personas p ON r.id_persona = p.id_persona\n+            WHERE p.id_persona IS NULL\n+          `);\n+          const orphanCount = parseInt(orphanCheck[0]?.total_sin_persona) || 0;\n+          if (orphanCount > 0) {\n+            console.warn(`‚ö†Ô∏è  [${requestId}] ${orphanCount} registros en registros_entrada_salida sin Persona v√°lida`);\n+          }\n+        } catch (checkError) {\n+          console.warn(`‚ö†Ô∏è  [${requestId}] Error verificando registros hu√©rfanos:`, checkError.message);\n+        }\n+        \n+        // Consulta SQL usando nombres correctos de columnas seg√∫n schema.sql\n+        // Tabla registros_entrada_salida: id_registro_entrada_salida, id_persona, tipo, fecha_hora\n+        // IMPORTANTE: Usar LEFT JOIN para incluir TODOS los registros, incluso sin persona asociada\n+        const querySQL = `\n+          SELECT \n+            r.id_registro_entrada_salida as id_acceso,\n+            r.tipo as tipo_acceso,\n+            r.fecha_hora as evento_fecha,\n+            r.fecha_hora as fecha_entrada,\n+            NULL as fecha_salida,\n+            'activo' as estado,\n+            r.id_persona,\n+            CASE \n+              WHEN p.id_persona IS NOT NULL THEN\n+                COALESCE(\n+                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), ' ', COALESCE(p.apellidos, ''))), ''),\n+                  p.nombre,\n+                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), COALESCE(p.apellidos, ''))), ''),\n+                  'Sin nombre'\n+                )\n+              ELSE CONCAT('Persona ID: ', COALESCE(r.id_persona, 'N/A'))\n+            END as persona_nombre,\n+            COALESCE(\n+              NULLIF(p.documento, ''),\n+              CONCAT('Persona ', COALESCE(r.id_persona, 'N/A'))\n+            ) as documento,\n+            COALESCE(\n+              NULLIF(p.rol, ''),\n+              'sin rol'\n+            ) as rol,\n+            'Sistema' as registrado_por,\n+            LOWER(COALESCE(r.tipo, 'ENTRADA')) as evento_tipo\n+          FROM registros_entrada_salida r\n+          LEFT JOIN Personas p ON r.id_persona = p.id_persona\n+          ORDER BY r.fecha_hora DESC\n+          LIMIT ?\n+        `;\n+        \n+        console.log(`üìù [${requestId}] Ejecutando consulta SQL en tabla registros_entrada_salida...`);\n+        const [queryRows] = await pool.execute(querySQL, [safeLimit]);\n+        rows = queryRows || [];\n+        \n+        if (rows.length > 0) {\n+          sourceTable = 'registros_entrada_salida';\n+          console.log(`‚úÖ [${requestId}] Datos obtenidos de tabla registros_entrada_salida: ${rows.length} registros`);\n+          console.log(`üìã [${requestId}] Primer registro:`, JSON.stringify(rows[0], null, 2));\n+        } else {\n+          console.warn(`‚ö†Ô∏è  [${requestId}] Consulta a registros_entrada_salida retorn√≥ 0 filas aunque hay ${registrosCount} registros`);\n+        }\n+      } catch (error) {\n+        console.error(`‚ùå [${requestId}] Error leyendo de registros_entrada_salida:`, {\n+          message: error.message,\n+          code: error.code,\n+          sqlState: error.sqlState,\n+          stack: error.stack\n+        });\n+        rows = [];\n+      }\n+    }\n+    \n+    // Si no hay datos en registros_entrada_salida, intentar leer de Accesos (tabla de compatibilidad)\n+    if (rows.length === 0 && accesosCount > 0) {\n       console.log(`üìä [${requestId}] Intentando leer de tabla Accesos (${accesosCount} registros disponibles)...`);\n       \n       try {\n         // Verificar registros hu√©rfanos (sin Persona)\n@@ -520,89 +602,10 @@\n         // Continuar para intentar leer de registros_entrada_salida\n       }\n     }\n     \n-    // Si no hay datos en Accesos, intentar leer de registros_entrada_salida\n-    if (rows.length === 0 && registrosCount > 0) {\n-      console.log(`üìä [${requestId}] Intentando leer de tabla registros_entrada_salida (${registrosCount} registros disponibles)...`);\n-      \n-      try {\n-        // Verificar registros hu√©rfanos\n-        try {\n-          const [orphanCheck] = await pool.execute(`\n-            SELECT COUNT(*) as total_sin_persona\n-            FROM registros_entrada_salida r\n-            LEFT JOIN Personas p ON r.id_persona = p.id_persona\n-            WHERE p.id_persona IS NULL\n-          `);\n-          const orphanCount = parseInt(orphanCheck[0]?.total_sin_persona) || 0;\n-          if (orphanCount > 0) {\n-            console.warn(`‚ö†Ô∏è  [${requestId}] ${orphanCount} registros en registros_entrada_salida sin Persona v√°lida`);\n-          }\n-        } catch (checkError) {\n-          console.warn(`‚ö†Ô∏è  [${requestId}] Error verificando registros hu√©rfanos:`, checkError.message);\n-        }\n-        \n-        // Consulta SQL usando nombres correctos de columnas seg√∫n schema.sql\n-        // Tabla registros_entrada_salida: id_registro_entrada_salida, id_persona, tipo, fecha_hora\n-        // IMPORTANTE: Usar LEFT JOIN para incluir TODOS los registros, incluso sin persona asociada\n-        // NOTA: Removemos WHERE para incluir TODOS los registros\n-        const querySQL = `\n-          SELECT \n-            r.id_registro_entrada_salida as id_acceso,\n-            r.tipo as tipo_acceso,\n-            r.fecha_hora as evento_fecha,\n-            r.fecha_hora as fecha_entrada,\n-            NULL as fecha_salida,\n-            'activo' as estado,\n-            r.id_persona,\n-            CASE \n-              WHEN p.id_persona IS NOT NULL THEN\n-                COALESCE(\n-                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), ' ', COALESCE(p.apellidos, ''))), ''),\n-                  p.nombre,\n-                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), COALESCE(p.apellidos, ''))), ''),\n-                  'Sin nombre'\n-                )\n-              ELSE CONCAT('Persona ID: ', COALESCE(r.id_persona, 'N/A'))\n-            END as persona_nombre,\n-            COALESCE(\n-              NULLIF(p.documento, ''),\n-              CONCAT('Persona ', COALESCE(r.id_persona, 'N/A'))\n-            ) as documento,\n-            COALESCE(\n-              NULLIF(p.rol, ''),\n-              'sin rol'\n-            ) as rol,\n-            'Sistema' as registrado_por,\n-            LOWER(COALESCE(r.tipo, 'ENTRADA')) as evento_tipo\n-          FROM registros_entrada_salida r\n-          LEFT JOIN Personas p ON r.id_persona = p.id_persona\n-          ORDER BY COALESCE(r.fecha_hora, NOW()) DESC\n-          LIMIT ?\n-        `;\n-        \n-        console.log(`üìù [${requestId}] Ejecutando consulta SQL en tabla registros_entrada_salida...`);\n-        const [queryRows] = await pool.execute(querySQL, [safeLimit]);\n-        rows = queryRows || [];\n-        \n-        if (rows.length > 0) {\n-          sourceTable = 'registros_entrada_salida';\n-          console.log(`‚úÖ [${requestId}] Datos obtenidos de tabla registros_entrada_salida: ${rows.length} registros`);\n-          console.log(`üìã [${requestId}] Primer registro:`, JSON.stringify(rows[0], null, 2));\n-        } else {\n-          console.warn(`‚ö†Ô∏è  [${requestId}] Consulta a registros_entrada_salida retorn√≥ 0 filas aunque hay ${registrosCount} registros`);\n-        }\n-      } catch (error) {\n-        console.error(`‚ùå [${requestId}] Error leyendo de registros_entrada_salida:`, {\n-          message: error.message,\n-          code: error.code,\n-          sqlState: error.sqlState,\n-          stack: error.stack\n-        });\n-        rows = [];\n-      }\n-    } else if (rows.length === 0 && accesosCount === 0 && registrosCount === 0) {\n+    // Verificar si ambas tablas est√°n vac√≠as\n+    if (rows.length === 0 && accesosCount === 0 && registrosCount === 0) {\n       console.warn(`‚ö†Ô∏è  [${requestId}] Ambas tablas (Accesos y registros_entrada_salida) est√°n vac√≠as`);\n     }\n \n     // 4. Procesar y transformar datos\n"
                },
                {
                    "date": 1764227373333,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -10,21 +10,23 @@\n   try {\n     const today = new Date().toISOString().split('T')[0];\n     const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n     \n-    // Personas actualmente dentro - usar ReportService\n+    // Personas actualmente dentro (vista v_personas_dentro)\n     let totalInside = 0;\n-    let currentPeopleData = { success: false, data: [], total: 0 };\n     try {\n-      currentPeopleData = await ReportService.getCurrentPeople();\n-      totalInside = currentPeopleData.total || currentPeopleData.data?.length || 0;\n+      const [insideRows] = await pool.execute(`\n+        SELECT COUNT(*) as personas_dentro\n+        FROM v_personas_dentro\n+      `);\n+      totalInside = insideRows[0]?.personas_dentro || 0;\n     } catch (error) {\n-      console.warn('‚ö†Ô∏è  Error obteniendo personas dentro con ReportService, intentando m√©todo alternativo:', error.message);\n+      console.warn('‚ö†Ô∏è  Error obteniendo personas dentro desde v_personas_dentro, usando fallback:', error.message);\n       try {\n-        const currentPeople = await Person.getCurrentPeople();\n-        totalInside = currentPeople?.length || 0;\n-      } catch (altError) {\n-        console.warn('‚ö†Ô∏è  Error obteniendo personas dentro, usando 0:', altError.message);\n+        const insideRows = await Person.getCurrentPeople();\n+        totalInside = insideRows?.length || 0;\n+      } catch (fallbackError) {\n+        console.warn('‚ö†Ô∏è  Error obteniendo personas dentro manualmente, usando 0:', fallbackError.message);\n         totalInside = 0;\n       }\n     }\n \n@@ -84,12 +86,16 @@\n       console.warn('‚ö†Ô∏è  Error obteniendo accesos fuera de horario, usando 0:', error.message);\n       outOfScheduleAccess = 0;\n     }\n \n-    // Alertas pendientes (accesos fuera de horario + visitantes pr√≥ximos a expirar) - con manejo de errores\n-    let expiringVisitorsCount = 0;\n+    // Alertas pendientes\n+    let pendingAlerts = 0;\n     try {\n-      // Intentar con Visitantes (may√∫scula) primero\n+      const alertStats = await AlertService.getAlertStats();\n+      pendingAlerts = alertStats?.pendientes ?? 0;\n+    } catch (error) {\n+      console.warn('‚ö†Ô∏è  No se pudieron obtener estad√≠sticas de alertas, usando heur√≠stica:', error.message);\n+      let expiringVisitorsCount = 0;\n       try {\n         const [expiringVisitors] = await pool.execute(\n           `SELECT COUNT(*) as count\n            FROM Visitantes\n@@ -97,11 +103,10 @@\n            AND fecha_fin IS NULL\n            AND fecha_inicio < DATE_SUB(NOW(), INTERVAL 23 HOUR)`\n         );\n         expiringVisitorsCount = expiringVisitors[0]?.count || 0;\n-      } catch (error) {\n-        // Si falla, intentar con visitantes (min√∫scula)\n-        if (error.code === 'ER_NO_SUCH_TABLE') {\n+      } catch (fallbackError) {\n+        if (fallbackError.code === 'ER_NO_SUCH_TABLE') {\n           const [expiringVisitors] = await pool.execute(\n             `SELECT COUNT(*) as count\n              FROM visitantes\n              WHERE estado = 'activo'\n@@ -109,16 +114,13 @@\n              AND fecha_inicio < DATE_SUB(NOW(), INTERVAL 23 HOUR)`\n           );\n           expiringVisitorsCount = expiringVisitors[0]?.count || 0;\n         } else {\n-          throw error;\n+          console.warn('‚ö†Ô∏è  Error en fallback de visitantes pr√≥ximos a expirar:', fallbackError.message);\n         }\n       }\n-    } catch (error) {\n-      console.warn('‚ö†Ô∏è  Error obteniendo visitantes pr√≥ximos a expirar, usando 0:', error.message);\n-      expiringVisitorsCount = 0;\n+      pendingAlerts = outOfScheduleAccess + expiringVisitorsCount;\n     }\n-    const pendingAlerts = outOfScheduleAccess + expiringVisitorsCount;\n \n     // Obtener estad√≠sticas adicionales usando ReportService.getAccessHistory\n     let statsLast7Days = {\n       total_accesos: 0,\n"
                },
                {
                    "date": 1764232818323,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -3,8 +3,9 @@\n import Access from '../models/Access.js';\n import Person from '../models/Person.js';\n import AlertService from '../services/AlertService.js';\n import { ReportService } from '../services/ReportService.js';\n+import { getRegistroIdField } from '../utils/columnResolver.js';\n \n   // Obtener todas las m√©tricas del dashboard\n export const getMetrics = async (req, res) => {\n   try {\n@@ -289,21 +290,28 @@\n     } catch (error) {\n       console.error('‚ùå Error obteniendo registros recientes de Accesos:', error.message);\n     }\n     \n+    const idColumn = await getRegistroIdField();\n+    const fullNameExpr = \"CONCAT(p.nombres, ' ', p.apellidos)\";\n     // Obtener √∫ltimos 5 registros de registros_entrada_salida con JOIN a Personas\n     let recentRegistros = [];\n     try {\n       const [recentRegRows] = await pool.execute(`\n         SELECT \n-          r.id_registro_entrada_salida,\n+          r.${idColumn} as id_registro,\n           r.tipo,\n           r.fecha_hora,\n           p.id_persona,\n           p.documento,\n           p.nombres,\n           p.apellidos,\n-          p.nombre\n+          COALESCE(\n+            ${fullNameExpr},\n+            p.nombres,\n+            p.apellidos,\n+            'Sin nombre'\n+          ) as nombre_completo\n         FROM registros_entrada_salida r\n         LEFT JOIN Personas p ON r.id_persona = p.id_persona\n         ORDER BY r.fecha_hora DESC\n         LIMIT 5\n"
                },
                {
                    "date": 1764311031197,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -4,8 +4,9 @@\n import Person from '../models/Person.js';\n import AlertService from '../services/AlertService.js';\n import { ReportService } from '../services/ReportService.js';\n import { getRegistroIdField } from '../utils/columnResolver.js';\n+import { createSecurityLog } from './auditController.js';\n \n   // Obtener todas las m√©tricas del dashboard\n export const getMetrics = async (req, res) => {\n   try {\n@@ -87,40 +88,17 @@\n       console.warn('‚ö†Ô∏è  Error obteniendo accesos fuera de horario, usando 0:', error.message);\n       outOfScheduleAccess = 0;\n     }\n \n-    // Alertas pendientes\n+    // Alertas pendientes dinamicas\n     let pendingAlerts = 0;\n     try {\n-      const alertStats = await AlertService.getAlertStats();\n-      pendingAlerts = alertStats?.pendientes ?? 0;\n+      const dynamicAlerts = await AlertService.generateAlerts();\n+      pendingAlerts = dynamicAlerts.length;\n     } catch (error) {\n-      console.warn('‚ö†Ô∏è  No se pudieron obtener estad√≠sticas de alertas, usando heur√≠stica:', error.message);\n-      let expiringVisitorsCount = 0;\n-      try {\n-        const [expiringVisitors] = await pool.execute(\n-          `SELECT COUNT(*) as count\n-           FROM Visitantes\n-           WHERE estado = 'activo'\n-           AND fecha_fin IS NULL\n-           AND fecha_inicio < DATE_SUB(NOW(), INTERVAL 23 HOUR)`\n-        );\n-        expiringVisitorsCount = expiringVisitors[0]?.count || 0;\n-      } catch (fallbackError) {\n-        if (fallbackError.code === 'ER_NO_SUCH_TABLE') {\n-          const [expiringVisitors] = await pool.execute(\n-            `SELECT COUNT(*) as count\n-             FROM visitantes\n-             WHERE estado = 'activo'\n-             AND fecha_fin IS NULL\n-             AND fecha_inicio < DATE_SUB(NOW(), INTERVAL 23 HOUR)`\n-          );\n-          expiringVisitorsCount = expiringVisitors[0]?.count || 0;\n-        } else {\n-          console.warn('‚ö†Ô∏è  Error en fallback de visitantes pr√≥ximos a expirar:', fallbackError.message);\n-        }\n-      }\n-      pendingAlerts = outOfScheduleAccess + expiringVisitorsCount;\n+      console.warn('‚ö†Ô∏è  No se pudieron generar alertas din√°micas, usando heur√≠stica:', error.message);\n+      // fallback: usar accesos fuera de horario detectados\n+      pendingAlerts = outOfScheduleAccess;\n     }\n \n     // Obtener estad√≠sticas adicionales usando ReportService.getAccessHistory\n     let statsLast7Days = {\n@@ -202,8 +180,51 @@\n     });\n   }\n };\n \n+export const getAlerts = async (req, res) => {\n+  try {\n+    const alerts = await AlertService.generateAlerts();\n+    res.json({\n+      success: true,\n+      data: alerts\n+    });\n+  } catch (error) {\n+    console.error('Error en getAlerts:', error);\n+    res.status(500).json({\n+      success: false,\n+      message: 'Error al obtener alertas',\n+      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n+    });\n+  }\n+};\n+\n+export const resolveAlert = async (req, res) => {\n+  try {\n+    const { alertId } = req.params;\n+    await createSecurityLog({\n+      tipo: 'operacion_admin',\n+      id_usuario: req.user.id,\n+      ip_address: req.ip,\n+      user_agent: req.get('user-agent'),\n+      accion: `Resoluci√≥n manual de alerta: ${alertId}`,\n+      detalles: { alertId },\n+      exito: true\n+    });\n+    res.json({\n+      success: true,\n+      message: 'Alerta marcada como resuelta'\n+    });\n+  } catch (error) {\n+    console.error('Error en resolveAlert:', error);\n+    res.status(500).json({\n+      success: false,\n+      message: 'Error al resolver la alerta',\n+      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n+    });\n+  }\n+};\n+\n // Endpoint de diagn√≥stico - Verificar estad√≠sticas de accesos\n export const getAccessStats = async (req, res) => {\n   try {\n     console.log('üîç [BACKEND] Verificando estad√≠sticas de accesos');\n@@ -753,62 +774,4 @@\n     });\n   }\n };\n \n-// Obtener alertas\n-export const getAlerts = async (req, res) => {\n-  try {\n-    // Usar el servicio de alertas para obtener alertas reales de la base de datos\n-    const alerts = await AlertService.getAlerts({\n-      tipo: null,\n-      severidad: null,\n-      leida: null,\n-      limit: 50,\n-      offset: 0\n-    });\n-\n-    res.json({\n-      success: true,\n-      data: alerts || []\n-    });\n-  } catch (error) {\n-    console.error('‚ùå Error en getAlerts del dashboard:', error);\n-    console.error('‚ùå C√≥digo de error:', error.code);\n-    console.error('‚ùå SQL State:', error.sqlState);\n-    console.error('‚ùå Mensaje:', error.message);\n-    console.error('‚ùå Stack:', error.stack);\n-    \n-    // Si la tabla no existe o hay problemas con la base de datos, retornar array vac√≠o\n-    if (\n-      error.code === 'ER_NO_SUCH_TABLE' || \n-      error.message?.includes('no existe') ||\n-      error.message?.includes('doesn\\'t exist') ||\n-      error.code === 'ER_BAD_FIELD_ERROR' ||\n-      error.code === 'ER_NO_SUCH_TABLE'\n-    ) {\n-      console.warn('‚ö†Ô∏è  Tabla Alertas no existe o hay problemas con la estructura, retornando array vac√≠o');\n-      return res.json({\n-        success: true,\n-        data: []\n-      });\n-    }\n-    \n-    // Si es un error de conexi√≥n a la base de datos\n-    if (error.code === 'ECONNREFUSED' || error.code === 'PROTOCOL_CONNECTION_LOST') {\n-      console.error('‚ùå Error de conexi√≥n a la base de datos');\n-      return res.status(503).json({\n-        success: false,\n-        message: 'Error de conexi√≥n a la base de datos',\n-        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n-      });\n-    }\n-    \n-    res.status(500).json({\n-      success: false,\n-      message: 'Error al obtener alertas',\n-      error: process.env.NODE_ENV === 'development' ? error.message : undefined,\n-      details: process.env.NODE_ENV === 'development' ? error.stack : undefined,\n-      code: process.env.NODE_ENV === 'development' ? error.code : undefined\n-    });\n-  }\n-};\n-\n"
                },
                {
                    "date": 1764311412098,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -200,8 +200,9 @@\n \n export const resolveAlert = async (req, res) => {\n   try {\n     const { alertId } = req.params;\n+    AlertService.markResolved(alertId);\n     await createSecurityLog({\n       tipo: 'operacion_admin',\n       id_usuario: req.user.id,\n       ip_address: req.ip,\n"
                }
            ],
            "date": 1764017519086,
            "name": "Commit-0",
            "content": "// Dashboard Controller\nimport pool from '../utils/dbPool.js';\nimport Access from '../models/Access.js';\nimport Person from '../models/Person.js';\nimport AlertService from '../services/AlertService.js';\nimport { ReportService } from '../services/ReportService.js';\n\n  // Obtener todas las m√©tricas del dashboard\nexport const getMetrics = async (req, res) => {\n  try {\n    const today = new Date().toISOString().split('T')[0];\n    const yesterday = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n    \n    // Personas actualmente dentro - usar ReportService\n    let totalInside = 0;\n    let currentPeopleData = { success: false, data: [], total: 0 };\n    try {\n      currentPeopleData = await ReportService.getCurrentPeople();\n      totalInside = currentPeopleData.total || currentPeopleData.data?.length || 0;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo personas dentro con ReportService, intentando m√©todo alternativo:', error.message);\n      try {\n        const currentPeople = await Person.getCurrentPeople();\n        totalInside = currentPeople?.length || 0;\n      } catch (altError) {\n        console.warn('‚ö†Ô∏è  Error obteniendo personas dentro, usando 0:', altError.message);\n        totalInside = 0;\n      }\n    }\n\n    // Estad√≠sticas del d√≠a - con manejo de errores\n    let dailyStats = { total_registros: 0, entradas: 0, salidas: 0 };\n    try {\n      dailyStats = await Access.getDailyStats(today);\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo estad√≠sticas del d√≠a, usando valores por defecto:', error.message);\n      dailyStats = { total_registros: 0, entradas: 0, salidas: 0 };\n    }\n\n    // Visitantes activos (√∫ltimas 24 horas) - probar ambos nombres de tabla\n    let activeVisitors = 0;\n    try {\n      // Intentar con Visitantes (may√∫scula) primero\n      try {\n        const [visitorRows] = await pool.execute(\n          `SELECT COUNT(*) as count \n           FROM Visitantes \n           WHERE estado = 'activo' \n           AND fecha_inicio >= DATE_SUB(NOW(), INTERVAL 24 HOUR)`\n        );\n        activeVisitors = visitorRows[0]?.count || 0;\n      } catch (error) {\n        // Si falla, intentar con visitantes (min√∫scula)\n        if (error.code === 'ER_NO_SUCH_TABLE') {\n          const [visitorRows] = await pool.execute(\n            `SELECT COUNT(*) as count \n             FROM visitantes \n             WHERE estado = 'activo' \n             AND fecha_inicio >= DATE_SUB(NOW(), INTERVAL 24 HOUR)`\n          );\n          activeVisitors = visitorRows[0]?.count || 0;\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo visitantes activos, usando 0:', error.message);\n      activeVisitors = 0;\n    }\n\n    // Accesos recientes para detectar alertas (fuera de horario) - con manejo de errores\n    let outOfScheduleAccess = 0;\n    try {\n      const [recentAccessRows] = await pool.execute(\n        `SELECT COUNT(*) as count\n         FROM registros_entrada_salida\n         WHERE DATE(fecha_hora) = ?\n         AND HOUR(fecha_hora) NOT BETWEEN 6 AND 22\n         AND tipo = 'ENTRADA'`,\n        [today]\n      );\n      outOfScheduleAccess = recentAccessRows[0]?.count || 0;\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo accesos fuera de horario, usando 0:', error.message);\n      outOfScheduleAccess = 0;\n    }\n\n    // Alertas pendientes (accesos fuera de horario + visitantes pr√≥ximos a expirar) - con manejo de errores\n    let expiringVisitorsCount = 0;\n    try {\n      // Intentar con Visitantes (may√∫scula) primero\n      try {\n        const [expiringVisitors] = await pool.execute(\n          `SELECT COUNT(*) as count\n           FROM Visitantes\n           WHERE estado = 'activo'\n           AND fecha_fin IS NULL\n           AND fecha_inicio < DATE_SUB(NOW(), INTERVAL 23 HOUR)`\n        );\n        expiringVisitorsCount = expiringVisitors[0]?.count || 0;\n      } catch (error) {\n        // Si falla, intentar con visitantes (min√∫scula)\n        if (error.code === 'ER_NO_SUCH_TABLE') {\n          const [expiringVisitors] = await pool.execute(\n            `SELECT COUNT(*) as count\n             FROM visitantes\n             WHERE estado = 'activo'\n             AND fecha_fin IS NULL\n             AND fecha_inicio < DATE_SUB(NOW(), INTERVAL 23 HOUR)`\n          );\n          expiringVisitorsCount = expiringVisitors[0]?.count || 0;\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo visitantes pr√≥ximos a expirar, usando 0:', error.message);\n      expiringVisitorsCount = 0;\n    }\n    const pendingAlerts = outOfScheduleAccess + expiringVisitorsCount;\n\n    // Obtener estad√≠sticas adicionales usando ReportService.getAccessHistory\n    let statsLast7Days = {\n      total_accesos: 0,\n      personas_unicas: 0,\n      tiempo_promedio_minutos: 0\n    };\n    \n    try {\n      const fechaInicio7dias = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n      const accessHistory = await ReportService.getAccessHistory(\n        { fecha_desde: fechaInicio7dias, fecha_hasta: today },\n        { limit: 1000, page: 1 }\n      );\n      \n      if (accessHistory.success && accessHistory.data) {\n        const accesos = accessHistory.data;\n        const personasUnicas = new Set(accesos.map(a => a.documento)).size;\n        const duraciones = accesos\n          .filter(a => a.duracion_minutos !== null && a.duracion_minutos !== undefined)\n          .map(a => parseInt(a.duracion_minutos) || 0);\n        const tiempoPromedio = duraciones.length > 0\n          ? Math.round(duraciones.reduce((sum, d) => sum + d, 0) / duraciones.length)\n          : 0;\n        \n        statsLast7Days = {\n          total_accesos: accesos.length,\n          personas_unicas: personasUnicas,\n          tiempo_promedio_minutos: tiempoPromedio\n        };\n      }\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo estad√≠sticas de 7 d√≠as, usando valores por defecto:', error.message);\n    }\n\n    // Estad√≠sticas de ayer para comparaci√≥n\n    let yesterdayStats = { total: 0, entradas: 0, salidas: 0 };\n    try {\n      yesterdayStats = await Access.getDailyStats(yesterday);\n    } catch (error) {\n      console.warn('‚ö†Ô∏è  Error obteniendo estad√≠sticas de ayer:', error.message);\n    }\n\n    // Calcular tendencias\n    const todayTotal = dailyStats.total_registros || 0;\n    const yesterdayTotal = yesterdayStats.total_registros || 0;\n    const trendAccess = yesterdayTotal > 0\n      ? Math.round(((todayTotal - yesterdayTotal) / yesterdayTotal) * 100)\n      : 0;\n\n    res.json({\n      success: true,\n      data: {\n        currentPeople: totalInside,\n        todayAccess: {\n          total: dailyStats.total_registros || 0,\n          entradas: dailyStats.entradas || 0,\n          salidas: dailyStats.salidas || 0\n        },\n        yesterdayAccess: {\n          total: yesterdayStats.total_registros || 0,\n          entradas: yesterdayStats.entradas || 0,\n          salidas: yesterdayStats.salidas || 0\n        },\n        trendAccess, // Porcentaje de cambio respecto a ayer\n        statsLast7Days,\n        activeVisitors,\n        pendingAlerts,\n        outOfScheduleAccess,\n        lastUpdate: new Date().toISOString()\n      }\n    });\n  } catch (error) {\n    console.error('Error en getMetrics:', error);\n    res.status(500).json({\n      success: false,\n      message: 'Error al obtener m√©tricas del dashboard',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined\n    });\n  }\n};\n\n// Endpoint de diagn√≥stico - Verificar estad√≠sticas de accesos\nexport const getAccessStats = async (req, res) => {\n  try {\n    console.log('üîç [BACKEND] Verificando estad√≠sticas de accesos');\n    \n    // Verificar tabla Accesos\n    let accesosStats = {\n      total_registros: 0,\n      primer_registro: null,\n      ultimo_registro: null,\n      ultimas_24h: 0\n    };\n    \n    try {\n      const [statsRows] = await pool.execute(`\n        SELECT \n          COUNT(*) as total_registros,\n          MIN(fecha_entrada) as primer_registro,\n          MAX(fecha_entrada) as ultimo_registro,\n          COUNT(CASE WHEN fecha_entrada >= DATE_SUB(NOW(), INTERVAL 24 HOUR) THEN 1 END) as ultimas_24h\n        FROM Accesos\n      `);\n      \n      if (statsRows && statsRows[0]) {\n        accesosStats = {\n          total_registros: parseInt(statsRows[0].total_registros) || 0,\n          primer_registro: statsRows[0].primer_registro,\n          ultimo_registro: statsRows[0].ultimo_registro,\n          ultimas_24h: parseInt(statsRows[0].ultimas_24h) || 0\n        };\n      }\n    } catch (error) {\n      console.error('‚ùå Error verificando tabla Accesos:', error.message);\n    }\n    \n    // Verificar tabla registros_entrada_salida\n    let registrosStats = {\n      total_registros: 0,\n      primer_registro: null,\n      ultimo_registro: null,\n      ultimas_24h: 0\n    };\n    \n    try {\n      const [registrosRows] = await pool.execute(`\n        SELECT \n          COUNT(*) as total_registros,\n          MIN(fecha_hora) as primer_registro,\n          MAX(fecha_hora) as ultimo_registro,\n          COUNT(CASE WHEN fecha_hora >= DATE_SUB(NOW(), INTERVAL 24 HOUR) THEN 1 END) as ultimas_24h\n        FROM registros_entrada_salida\n      `);\n      \n      if (registrosRows && registrosRows[0]) {\n        registrosStats = {\n          total_registros: parseInt(registrosRows[0].total_registros) || 0,\n          primer_registro: registrosRows[0].primer_registro,\n          ultimo_registro: registrosRows[0].ultimo_registro,\n          ultimas_24h: parseInt(registrosRows[0].ultimas_24h) || 0\n        };\n      }\n    } catch (error) {\n      console.error('‚ùå Error verificando tabla registros_entrada_salida:', error.message);\n    }\n    \n    // Obtener √∫ltimos 5 registros de Accesos con JOIN a Personas\n    let recentAccesos = [];\n    try {\n      const [recentRows] = await pool.execute(`\n        SELECT \n          a.id_acceso,\n          a.tipo_acceso,\n          a.fecha_entrada,\n          p.id_persona,\n          p.documento,\n          p.nombres,\n          p.apellidos,\n          p.nombre\n        FROM Accesos a\n        LEFT JOIN Personas p ON a.id_persona = p.id_persona\n        ORDER BY a.fecha_entrada DESC\n        LIMIT 5\n      `);\n      recentAccesos = recentRows || [];\n    } catch (error) {\n      console.error('‚ùå Error obteniendo registros recientes de Accesos:', error.message);\n    }\n    \n    // Obtener √∫ltimos 5 registros de registros_entrada_salida con JOIN a Personas\n    let recentRegistros = [];\n    try {\n      const [recentRegRows] = await pool.execute(`\n        SELECT \n          r.id_registro_entrada_salida,\n          r.tipo,\n          r.fecha_hora,\n          p.id_persona,\n          p.documento,\n          p.nombres,\n          p.apellidos,\n          p.nombre\n        FROM registros_entrada_salida r\n        LEFT JOIN Personas p ON r.id_persona = p.id_persona\n        ORDER BY r.fecha_hora DESC\n        LIMIT 5\n      `);\n      recentRegistros = recentRegRows || [];\n    } catch (error) {\n      console.error('‚ùå Error obteniendo registros recientes de registros_entrada_salida:', error.message);\n    }\n    \n    res.json({\n      success: true,\n      accesos: accesosStats,\n      registros_entrada_salida: registrosStats,\n      recent_accesos: recentAccesos,\n      recent_registros: recentRegistros,\n      database_time: new Date().toISOString(),\n      message: `Accesos: ${accesosStats.total_registros} total, ${accesosStats.ultimas_24h} √∫ltimas 24h | Registros: ${registrosStats.total_registros} total, ${registrosStats.ultimas_24h} √∫ltimas 24h`\n    });\n    \n  } catch (error) {\n    console.error('‚ùå Error en getAccessStats:', error);\n    res.status(500).json({\n      success: false,\n      error: error.message\n    });\n  }\n};\n\n// Obtener accesos recientes - Versi√≥n mejorada con diagn√≥stico y manejo robusto de errores\nexport const getRecentAccess = async (req, res) => {\n  const startTime = Date.now();\n  const requestId = `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  \n  try {\n    console.log(`\\nüîç [${requestId}] ========== INICIO getRecentAccess ==========`);\n    \n    // 1. Validar y procesar par√°metros\n    const limit = parseInt(req.query.limit) || 20;\n    const safeLimit = Math.floor(Math.min(Math.max(1, limit), 100));\n    \n    console.log(`üìä [${requestId}] Par√°metros recibidos:`, {\n      limit: req.query.limit,\n      safeLimit,\n      tipo: typeof safeLimit\n    });\n    \n    // 2. Diagn√≥stico inicial: Verificar estructura de tablas\n    console.log(`üìã [${requestId}] Verificando estructura de tablas...`);\n    \n    let accesosCount = 0;\n    let registrosCount = 0;\n    let accesosStructure = null;\n    let registrosStructure = null;\n    \n    // Verificar tabla Accesos\n    try {\n      const [countAccesos] = await pool.execute('SELECT COUNT(*) as total FROM Accesos');\n      accesosCount = parseInt(countAccesos[0]?.total) || 0;\n      \n      const [structureAccesos] = await pool.execute(`\n        SELECT COLUMN_NAME, DATA_TYPE \n        FROM INFORMATION_SCHEMA.COLUMNS \n        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'Accesos'\n        ORDER BY ORDINAL_POSITION\n      `);\n      accesosStructure = structureAccesos.map(col => col.COLUMN_NAME);\n      \n      console.log(`‚úÖ [${requestId}] Tabla Accesos: ${accesosCount} registros`);\n      console.log(`   Columnas: ${accesosStructure.join(', ')}`);\n    } catch (error) {\n      console.error(`‚ùå [${requestId}] Error verificando tabla Accesos:`, {\n        message: error.message,\n        code: error.code,\n        sqlState: error.sqlState\n      });\n    }\n    \n    // Verificar tabla registros_entrada_salida\n    try {\n      const [countRegistros] = await pool.execute('SELECT COUNT(*) as total FROM registros_entrada_salida');\n      registrosCount = parseInt(countRegistros[0]?.total) || 0;\n      \n      const [structureRegistros] = await pool.execute(`\n        SELECT COLUMN_NAME, DATA_TYPE \n        FROM INFORMATION_SCHEMA.COLUMNS \n        WHERE TABLE_SCHEMA = DATABASE() AND TABLE_NAME = 'registros_entrada_salida'\n        ORDER BY ORDINAL_POSITION\n      `);\n      registrosStructure = structureRegistros.map(col => col.COLUMN_NAME);\n      \n      console.log(`‚úÖ [${requestId}] Tabla registros_entrada_salida: ${registrosCount} registros`);\n      console.log(`   Columnas: ${registrosStructure.join(', ')}`);\n    } catch (error) {\n      console.error(`‚ùå [${requestId}] Error verificando tabla registros_entrada_salida:`, {\n        message: error.message,\n        code: error.code,\n        sqlState: error.sqlState\n      });\n    }\n    \n    // 3. Leer datos de las tablas usando nombres correctos de columnas\n    let rows = [];\n    let sourceTable = null;\n    \n    // Estrategia: Leer de Accesos primero (donde est√°n los datos actuales)\n    if (accesosCount > 0) {\n      console.log(`üìä [${requestId}] Intentando leer de tabla Accesos (${accesosCount} registros disponibles)...`);\n      \n      try {\n        // Verificar registros hu√©rfanos (sin Persona)\n        try {\n          const [orphanCheck] = await pool.execute(`\n            SELECT COUNT(*) as total_sin_persona\n            FROM Accesos a\n            LEFT JOIN Personas p ON a.id_persona = p.id_persona\n            WHERE p.id_persona IS NULL\n          `);\n          const orphanCount = parseInt(orphanCheck[0]?.total_sin_persona) || 0;\n          if (orphanCount > 0) {\n            console.warn(`‚ö†Ô∏è  [${requestId}] ${orphanCount} registros en Accesos sin Persona v√°lida (se mostrar√°n con datos b√°sicos)`);\n          }\n        } catch (checkError) {\n          console.warn(`‚ö†Ô∏è  [${requestId}] Error verificando registros hu√©rfanos:`, checkError.message);\n        }\n        \n        // Consulta SQL usando nombres correctos de columnas seg√∫n schema.sql\n        // Tabla Accesos: id_acceso, id_persona, tipo_acceso, fecha_entrada, fecha_salida, estado\n        // IMPORTANTE: Usar LEFT JOIN para incluir TODOS los accesos, incluso sin persona asociada\n        // NOTA: Removemos WHERE para incluir TODOS los registros, incluso si fecha_entrada es NULL\n        const querySQL = `\n          SELECT \n            a.id_acceso,\n            a.tipo_acceso,\n            a.fecha_entrada as evento_fecha,\n            a.fecha_entrada,\n            a.fecha_salida,\n            a.estado,\n            a.id_persona,\n            CASE \n              WHEN p.id_persona IS NOT NULL THEN\n                COALESCE(\n                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), ' ', COALESCE(p.apellidos, ''))), ''),\n                  p.nombre,\n                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), COALESCE(p.apellidos, ''))), ''),\n                  'Sin nombre'\n                )\n              ELSE CONCAT('Persona ID: ', COALESCE(a.id_persona, 'N/A'))\n            END as persona_nombre,\n            COALESCE(\n              NULLIF(p.documento, ''),\n              CONCAT('Persona ', COALESCE(a.id_persona, 'N/A'))\n            ) as documento,\n            COALESCE(\n              NULLIF(p.rol, ''),\n              'sin rol'\n            ) as rol,\n            'Sistema' as registrado_por,\n            LOWER(COALESCE(a.tipo_acceso, 'entrada')) as evento_tipo\n          FROM Accesos a\n          LEFT JOIN Personas p ON a.id_persona = p.id_persona\n          ORDER BY a.fecha_entrada DESC, a.id_acceso DESC\n          LIMIT ?\n        `;\n        \n        console.log(`üìù [${requestId}] Ejecutando consulta SQL en tabla Accesos...`);\n        const [queryRows] = await pool.execute(querySQL, [safeLimit]);\n        rows = queryRows || [];\n        \n        if (rows.length > 0) {\n          sourceTable = 'Accesos';\n          console.log(`‚úÖ [${requestId}] Datos obtenidos de tabla Accesos: ${rows.length} registros`);\n          console.log(`üìã [${requestId}] Primer registro:`, JSON.stringify(rows[0], null, 2));\n        } else {\n          console.warn(`‚ö†Ô∏è  [${requestId}] Consulta a Accesos retorn√≥ 0 filas aunque hay ${accesosCount} registros`);\n          \n          // Diagn√≥stico detallado\n          try {\n            const [rawRows] = await pool.execute(`\n              SELECT id_acceso, id_persona, tipo_acceso, fecha_entrada \n              FROM Accesos \n              ORDER BY fecha_entrada DESC \n              LIMIT 5\n            `);\n            console.log(`üìã [${requestId}] Muestra de registros raw de Accesos:`, JSON.stringify(rawRows, null, 2));\n            \n            if (rawRows && rawRows.length > 0) {\n              const idsPersonas = rawRows.map(r => r.id_persona).filter(id => id !== null && id !== undefined);\n              if (idsPersonas.length > 0) {\n                const placeholders = idsPersonas.map(() => '?').join(',');\n                const [personasCheck] = await pool.execute(\n                  `SELECT id_persona FROM Personas WHERE id_persona IN (${placeholders})`,\n                  idsPersonas\n                );\n                console.log(`üìã [${requestId}] Personas encontradas: ${personasCheck.length} de ${idsPersonas.length}`);\n                \n                if (personasCheck.length < idsPersonas.length) {\n                  const personasEncontradas = personasCheck.map(p => p.id_persona);\n                  const personasNoEncontradas = idsPersonas.filter(id => !personasEncontradas.includes(id));\n                  console.warn(`‚ö†Ô∏è  [${requestId}] Personas NO encontradas en BD: ${personasNoEncontradas.join(', ')}`);\n                }\n              } else {\n                console.warn(`‚ö†Ô∏è  [${requestId}] Todos los registros de Accesos tienen id_persona NULL`);\n              }\n            }\n          } catch (diagError) {\n            console.error(`‚ùå [${requestId}] Error en diagn√≥stico:`, diagError.message);\n          }\n        }\n      } catch (error) {\n        console.error(`‚ùå [${requestId}] Error leyendo de Accesos:`, {\n          message: error.message,\n          code: error.code,\n          sqlState: error.sqlState,\n          stack: error.stack\n        });\n        // Continuar para intentar leer de registros_entrada_salida\n      }\n    }\n    \n    // Si no hay datos en Accesos, intentar leer de registros_entrada_salida\n    if (rows.length === 0 && registrosCount > 0) {\n      console.log(`üìä [${requestId}] Intentando leer de tabla registros_entrada_salida (${registrosCount} registros disponibles)...`);\n      \n      try {\n        // Verificar registros hu√©rfanos\n        try {\n          const [orphanCheck] = await pool.execute(`\n            SELECT COUNT(*) as total_sin_persona\n            FROM registros_entrada_salida r\n            LEFT JOIN Personas p ON r.id_persona = p.id_persona\n            WHERE p.id_persona IS NULL\n          `);\n          const orphanCount = parseInt(orphanCheck[0]?.total_sin_persona) || 0;\n          if (orphanCount > 0) {\n            console.warn(`‚ö†Ô∏è  [${requestId}] ${orphanCount} registros en registros_entrada_salida sin Persona v√°lida`);\n          }\n        } catch (checkError) {\n          console.warn(`‚ö†Ô∏è  [${requestId}] Error verificando registros hu√©rfanos:`, checkError.message);\n        }\n        \n        // Consulta SQL usando nombres correctos de columnas seg√∫n schema.sql\n        // Tabla registros_entrada_salida: id_registro_entrada_salida, id_persona, tipo, fecha_hora\n        // IMPORTANTE: Usar LEFT JOIN para incluir TODOS los registros, incluso sin persona asociada\n        // NOTA: Removemos WHERE para incluir TODOS los registros\n        const querySQL = `\n          SELECT \n            r.id_registro_entrada_salida as id_acceso,\n            r.tipo as tipo_acceso,\n            r.fecha_hora as evento_fecha,\n            r.fecha_hora as fecha_entrada,\n            NULL as fecha_salida,\n            'activo' as estado,\n            r.id_persona,\n            CASE \n              WHEN p.id_persona IS NOT NULL THEN\n                COALESCE(\n                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), ' ', COALESCE(p.apellidos, ''))), ''),\n                  p.nombre,\n                  NULLIF(TRIM(CONCAT(COALESCE(p.nombres, ''), COALESCE(p.apellidos, ''))), ''),\n                  'Sin nombre'\n                )\n              ELSE CONCAT('Persona ID: ', COALESCE(r.id_persona, 'N/A'))\n            END as persona_nombre,\n            COALESCE(\n              NULLIF(p.documento, ''),\n              CONCAT('Persona ', COALESCE(r.id_persona, 'N/A'))\n            ) as documento,\n            COALESCE(\n              NULLIF(p.rol, ''),\n              'sin rol'\n            ) as rol,\n            'Sistema' as registrado_por,\n            LOWER(COALESCE(r.tipo, 'ENTRADA')) as evento_tipo\n          FROM registros_entrada_salida r\n          LEFT JOIN Personas p ON r.id_persona = p.id_persona\n          ORDER BY COALESCE(r.fecha_hora, NOW()) DESC\n          LIMIT ?\n        `;\n        \n        console.log(`üìù [${requestId}] Ejecutando consulta SQL en tabla registros_entrada_salida...`);\n        const [queryRows] = await pool.execute(querySQL, [safeLimit]);\n        rows = queryRows || [];\n        \n        if (rows.length > 0) {\n          sourceTable = 'registros_entrada_salida';\n          console.log(`‚úÖ [${requestId}] Datos obtenidos de tabla registros_entrada_salida: ${rows.length} registros`);\n          console.log(`üìã [${requestId}] Primer registro:`, JSON.stringify(rows[0], null, 2));\n        } else {\n          console.warn(`‚ö†Ô∏è  [${requestId}] Consulta a registros_entrada_salida retorn√≥ 0 filas aunque hay ${registrosCount} registros`);\n        }\n      } catch (error) {\n        console.error(`‚ùå [${requestId}] Error leyendo de registros_entrada_salida:`, {\n          message: error.message,\n          code: error.code,\n          sqlState: error.sqlState,\n          stack: error.stack\n        });\n        rows = [];\n      }\n    } else if (rows.length === 0 && accesosCount === 0 && registrosCount === 0) {\n      console.warn(`‚ö†Ô∏è  [${requestId}] Ambas tablas (Accesos y registros_entrada_salida) est√°n vac√≠as`);\n    }\n\n    // 4. Procesar y transformar datos\n    console.log(`üîÑ [${requestId}] Procesando ${rows.length} registros...`);\n    \n    const accesses = rows.map((access, index) => {\n      try {\n        // Asegurar que tenemos al menos un campo de fecha\n        const fechaEvento = access.evento_fecha || access.fecha_entrada || access.fecha_hora;\n        let fueraHorario = false;\n        \n        if (fechaEvento) {\n          try {\n            const fecha = new Date(fechaEvento);\n            if (!isNaN(fecha.getTime())) {\n              const hora = fecha.getHours();\n              fueraHorario = hora < 6 || hora > 22;\n            }\n          } catch (e) {\n            console.warn(`‚ö†Ô∏è  [${requestId}] Error procesando fecha en registro ${index + 1}:`, e.message);\n          }\n        }\n        \n        // Normalizar tipo de acceso: ENTRADA/SALIDA -> entrada/salida\n        let tipoNormalizado = (access.evento_tipo || access.tipo_acceso || 'entrada').toLowerCase();\n        // Limpiar y normalizar el tipo - manejar diferentes variaciones\n        if (tipoNormalizado.includes('entrada') || tipoNormalizado === 'entrada' || tipoNormalizado === 'ENTRADA') {\n          tipoNormalizado = 'entrada';\n        } else if (tipoNormalizado.includes('salida') || tipoNormalizado === 'salida' || tipoNormalizado === 'SALIDA') {\n          tipoNormalizado = 'salida';\n        } else {\n          // Por defecto, si no se puede determinar, usar 'entrada'\n          tipoNormalizado = 'entrada';\n        }\n        \n        // Asegurar que todos los campos requeridos tengan valores v√°lidos\n        const personaNombre = access.persona_nombre || `Persona ID: ${access.id_persona || 'N/A'}`;\n        const documento = access.documento || `Persona ${access.id_persona || 'N/A'}`;\n        const rol = access.rol || 'sin rol';\n        const idRegistro = access.id_acceso || access.id_registro_entrada_salida || index;\n        \n        return {\n          id_registro: idRegistro,\n          persona_nombre: personaNombre,\n          documento: documento,\n          tipo: tipoNormalizado,\n          fecha_entrada: access.fecha_entrada ? new Date(access.fecha_entrada).toISOString() : null,\n          fecha_salida: access.fecha_salida ? new Date(access.fecha_salida).toISOString() : null,\n          fecha_evento: fechaEvento ? new Date(fechaEvento).toISOString() : null,\n          metodo_acceso: 'qr',\n          fuera_horario: fueraHorario,\n          rol: rol,\n          registrado_por: access.registrado_por || 'Sistema',\n          id_persona: access.id_persona || null\n        };\n      } catch (error) {\n        console.error(`‚ùå [${requestId}] Error procesando registro ${index + 1}:`, error.message);\n        console.error(`‚ùå [${requestId}] Datos del registro problem√°tico:`, JSON.stringify(access, null, 2));\n        return null;\n      }\n    }).filter(access => access !== null); // Filtrar registros con error\n    \n    const processingTime = Date.now() - startTime;\n    \n    console.log(`‚úÖ [${requestId}] Procesamiento completado:`);\n    console.log(`   - Registros obtenidos: ${rows.length}`);\n    console.log(`   - Registros procesados: ${accesses.length}`);\n    console.log(`   - Tabla fuente: ${sourceTable || 'ninguna'}`);\n    console.log(`   - Tiempo de procesamiento: ${processingTime}ms`);\n    \n    if (accesses.length > 0) {\n      console.log(`üìã [${requestId}] Primer acceso procesado:`, JSON.stringify(accesses[0], null, 2));\n    }\n    \n    // 5. Enviar respuesta - Asegurar que siempre devolvemos un array, incluso si est√° vac√≠o\n    const response = {\n      success: true,\n      data: accesses || [], // Asegurar que siempre sea un array\n      metadata: {\n        total: accesses.length || 0,\n        source_table: sourceTable || 'ninguna',\n        processing_time_ms: processingTime,\n        request_id: requestId,\n        accesos_count: accesosCount,\n        registros_count: registrosCount,\n        diagnostic: {\n          accesos_table_exists: accesosCount >= 0,\n          registros_table_exists: registrosCount >= 0,\n          rows_found: rows.length,\n          accesses_processed: accesses.length\n        }\n      }\n    };\n    \n    if (accesses.length === 0) {\n      console.warn(`‚ö†Ô∏è  [${requestId}] NO SE ENCONTRARON ACCESOS:`);\n      console.warn(`   - Tabla Accesos: ${accesosCount} registros`);\n      console.warn(`   - Tabla registros_entrada_salida: ${registrosCount} registros`);\n      console.warn(`   - Filas obtenidas de consulta: ${rows.length}`);\n      console.warn(`   - Accesos procesados: ${accesses.length}`);\n      \n      if (accesosCount === 0 && registrosCount === 0) {\n        console.warn(`   ‚ö†Ô∏è  Ambas tablas est√°n vac√≠as. ¬øHay datos en la base de datos?`);\n      } else if (rows.length === 0 && (accesosCount > 0 || registrosCount > 0)) {\n        console.warn(`   ‚ö†Ô∏è  Hay ${accesosCount + registrosCount} registros en las tablas pero la consulta retorn√≥ 0 filas`);\n        console.warn(`   ‚ö†Ô∏è  Posible problema con los JOINs o filtros en la consulta SQL`);\n      }\n    }\n    \n    console.log(`üì§ [${requestId}] Enviando respuesta con ${accesses.length} accesos`);\n    console.log(`‚úÖ [${requestId}] ========== FIN getRecentAccess (${processingTime}ms) ==========\\n`);\n    \n    res.json(response);\n    \n  } catch (error) {\n    const processingTime = Date.now() - startTime;\n    console.error(`\\n‚ùå [${requestId}] ========== ERROR en getRecentAccess ==========`);\n    console.error(`‚ùå [${requestId}] Mensaje:`, error.message);\n    console.error(`‚ùå [${requestId}] C√≥digo:`, error.code);\n    console.error(`‚ùå [${requestId}] SQL State:`, error.sqlState);\n    console.error(`‚ùå [${requestId}] Stack:`, error.stack);\n    console.error(`‚ùå [${requestId}] Tiempo antes del error: ${processingTime}ms`);\n    console.error(`‚ùå [${requestId}] ============================================\\n`);\n    \n    res.status(500).json({\n      success: false,\n      message: 'Error al obtener accesos recientes',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      details: process.env.NODE_ENV === 'development' ? {\n        code: error.code,\n        sqlState: error.sqlState,\n        stack: error.stack\n      } : undefined,\n      request_id: requestId\n    });\n  }\n};\n\n// Obtener alertas\nexport const getAlerts = async (req, res) => {\n  try {\n    // Usar el servicio de alertas para obtener alertas reales de la base de datos\n    const alerts = await AlertService.getAlerts({\n      tipo: null,\n      severidad: null,\n      leida: null,\n      limit: 50,\n      offset: 0\n    });\n\n    res.json({\n      success: true,\n      data: alerts || []\n    });\n  } catch (error) {\n    console.error('‚ùå Error en getAlerts del dashboard:', error);\n    console.error('‚ùå C√≥digo de error:', error.code);\n    console.error('‚ùå SQL State:', error.sqlState);\n    console.error('‚ùå Mensaje:', error.message);\n    console.error('‚ùå Stack:', error.stack);\n    \n    // Si la tabla no existe o hay problemas con la base de datos, retornar array vac√≠o\n    if (\n      error.code === 'ER_NO_SUCH_TABLE' || \n      error.message?.includes('no existe') ||\n      error.message?.includes('doesn\\'t exist') ||\n      error.code === 'ER_BAD_FIELD_ERROR' ||\n      error.code === 'ER_NO_SUCH_TABLE'\n    ) {\n      console.warn('‚ö†Ô∏è  Tabla Alertas no existe o hay problemas con la estructura, retornando array vac√≠o');\n      return res.json({\n        success: true,\n        data: []\n      });\n    }\n    \n    // Si es un error de conexi√≥n a la base de datos\n    if (error.code === 'ECONNREFUSED' || error.code === 'PROTOCOL_CONNECTION_LOST') {\n      console.error('‚ùå Error de conexi√≥n a la base de datos');\n      return res.status(503).json({\n        success: false,\n        message: 'Error de conexi√≥n a la base de datos',\n        error: process.env.NODE_ENV === 'development' ? error.message : undefined\n      });\n    }\n    \n    res.status(500).json({\n      success: false,\n      message: 'Error al obtener alertas',\n      error: process.env.NODE_ENV === 'development' ? error.message : undefined,\n      details: process.env.NODE_ENV === 'development' ? error.stack : undefined,\n      code: process.env.NODE_ENV === 'development' ? error.code : undefined\n    });\n  }\n};\n\n"
        }
    ]
}