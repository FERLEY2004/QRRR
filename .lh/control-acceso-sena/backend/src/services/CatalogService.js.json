{
    "sourceFile": "control-acceso-sena/backend/src/services/CatalogService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1764109750454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764110289920,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -51,20 +51,27 @@\n         params.push(filters.nivel);\n       }\n \n       if (filters.area && filters.area.trim() !== '') {\n-        query += ` AND area_conocimiento LIKE ?`;\n-        params.push(`%${filters.area}%`);\n+        // B√∫squeda case-insensitive para √°rea tambi√©n\n+        query += ` AND LOWER(area_conocimiento) LIKE LOWER(?)`;\n+        params.push(`%${filters.area.trim()}%`);\n       }\n \n       if (filters.estado && filters.estado.trim() !== '') {\n         query += ` AND estado = ?`;\n         params.push(filters.estado);\n       }\n \n       if (filters.search && filters.search.trim() !== '') {\n-        query += ` AND (nombre_programa LIKE ? OR codigo_programa LIKE ?)`;\n-        const searchTerm = `%${filters.search}%`;\n+        // B√∫squeda case-insensitive y flexible con acentos\n+        // Usar LOWER() y COLLATE para hacer la b√∫squeda m√°s flexible\n+        // Esto permite encontrar \"Analisis\" cuando se busca \"An√°lisis\" y viceversa\n+        query += ` AND (\n+          LOWER(nombre_programa) COLLATE utf8mb4_unicode_ci LIKE LOWER(?) COLLATE utf8mb4_unicode_ci OR \n+          codigo_programa LIKE ?\n+        )`;\n+        const searchTerm = `%${filters.search.trim()}%`;\n         params.push(searchTerm, searchTerm);\n       }\n \n       query += ` ORDER BY nivel, area_conocimiento, nombre_programa`;\n"
                },
                {
                    "date": 1764316063392,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n // Catalog Service - Servicio de cat√°logo de programas y ambientes\n import pool from '../utils/dbPool.js';\n+import { getRegistroIdField } from '../utils/columnResolver.js';\n \n export class CatalogService {\n   /**\n    * Obtener todos los programas de formaci√≥n\n@@ -135,8 +136,63 @@\n       throw error;\n     }\n   }\n \n+  static async createProgram(data) {\n+    try {\n+      const {\n+        codigo_programa,\n+        nombre_programa,\n+        nivel = 'T√©cnico',\n+        area_conocimiento = null,\n+        duracion_meses = 12,\n+        descripcion = null,\n+        estado = 'activo'\n+      } = data;\n+\n+      if (!codigo_programa || !nombre_programa) {\n+        return {\n+          success: false,\n+          message: 'C√≥digo y nombre del programa son obligatorios'\n+        };\n+      }\n+\n+      const [result] = await pool.execute(\n+        `INSERT INTO programas_formacion \n+         (codigo_programa, nombre_programa, nivel, duracion_meses, area_conocimiento, descripcion, estado)\n+         VALUES (?, ?, ?, ?, ?, ?, ?)`,\n+        [\n+          codigo_programa,\n+          nombre_programa,\n+          nivel,\n+          duracion_meses,\n+          area_conocimiento,\n+          descripcion,\n+          estado\n+        ]\n+      );\n+\n+      const [inserted] = await pool.execute(\n+        `SELECT * FROM programas_formacion WHERE id_programa = ?`,\n+        [result.insertId]\n+      );\n+\n+      return {\n+        success: true,\n+        data: inserted[0]\n+      };\n+    } catch (error) {\n+      console.error('Error en createProgram:', error);\n+      if (error.code === 'ER_DUP_ENTRY') {\n+        return {\n+          success: false,\n+          message: 'Ya existe un programa con ese c√≥digo'\n+        };\n+      }\n+      throw error;\n+    }\n+  }\n+\n   /**\n    * Obtener todas las fichas\n    */\n   static async getAllFichas(filters = {}) {\n@@ -189,34 +245,27 @@\n       let query = `\n         SELECT \n           f.id_ficha,\n           f.codigo_ficha,\n-          f.programa_formacion,\n+          f.id_programa,\n           f.jornada,\n           f.fecha_inicio,\n           f.fecha_fin,\n           f.estado,\n           f.numero_aprendices,\n           f.capacidad_maxima,\n-          COALESCE(f.observaciones, f.observacion, NULL) as observaciones,\n-          f.fecha_creacion,\n-          COALESCE(pf.codigo_programa, NULL) as codigo_programa,\n-          COALESCE(pf.nombre_programa, NULL) as nombre_programa,\n-          COALESCE(pf.nivel, NULL) as nivel,\n-          COALESCE(pf.area_conocimiento, NULL) as area_conocimiento,\n-          COALESCE(a.codigo_ambiente, NULL) as codigo_ambiente,\n-          COALESCE(a.nombre_ambiente, NULL) as nombre_ambiente,\n-          COALESCE(a.bloque, NULL) as bloque,\n+          pf.codigo_programa,\n+          pf.nombre_programa,\n+          pf.nivel,\n+          pf.area_conocimiento,\n           COALESCE((\n             SELECT COUNT(*)\n             FROM Personas p\n             WHERE p.id_ficha = f.id_ficha\n-            AND (p.rol = 'aprendiz' OR p.rol = 'APRENDIZ')\n             AND (p.estado = 'activo' OR p.estado = 'ACTIVO' OR p.estado IS NULL)\n           ), 0) as aprendices_activos\n-        FROM \\`fichas\\` f\n-        LEFT JOIN \\`Programas_Formacion\\` pf ON f.id_programa = pf.id_programa\n-        LEFT JOIN \\`Ambientes\\` a ON f.id_ambiente_principal = a.id_ambiente\n+        FROM fichas f\n+        LEFT JOIN programas_formacion pf ON f.id_programa = pf.id_programa\n         WHERE 1=1\n       `;\n \n       const params = [];\n@@ -236,16 +285,16 @@\n         console.log(`üìã [getAllFichas] Filtro jornada aplicado: ${jornadaNormalizada}`);\n       }\n \n       if (filters.programa && filters.programa.trim() !== '') {\n-        query += ` AND (f.programa_formacion LIKE ? OR pf.nombre_programa LIKE ?)`;\n+        query += ` AND pf.nombre_programa LIKE ?`;\n         const searchTerm = `%${filters.programa.trim()}%`;\n-        params.push(searchTerm, searchTerm);\n+        params.push(searchTerm);\n         console.log(`üìã [getAllFichas] Filtro programa aplicado: ${searchTerm}`);\n       }\n \n       if (filters.search && filters.search.trim() !== '') {\n-        query += ` AND (f.codigo_ficha LIKE ? OR f.programa_formacion LIKE ?)`;\n+        query += ` AND (f.codigo_ficha LIKE ? OR pf.nombre_programa LIKE ?)`;\n         const searchTerm = `%${filters.search.trim()}%`;\n         params.push(searchTerm, searchTerm);\n         console.log(`üìã [getAllFichas] Filtro b√∫squeda aplicado: ${searchTerm}`);\n       }\n@@ -335,8 +384,75 @@\n       throw error;\n     }\n   }\n \n+  static async createFicha(data) {\n+    try {\n+      const {\n+        codigo_ficha,\n+        codigo_programa,\n+        jornada = 'diurna',\n+        fecha_inicio = null,\n+        fecha_fin = null,\n+        estado = 'activa',\n+        numero_aprendices = 0,\n+        capacidad_maxima = null\n+      } = data;\n+\n+      if (!codigo_ficha || !codigo_programa) {\n+        return {\n+          success: false,\n+          message: 'C√≥digo de ficha y de programa son obligatorios'\n+        };\n+      }\n+\n+      const [programRows] = await pool.execute(\n+        `SELECT id_programa FROM programas_formacion WHERE codigo_programa = ?`,\n+        [codigo_programa]\n+      );\n+\n+      if (programRows.length === 0) {\n+        return {\n+          success: false,\n+          message: 'Programa no encontrado para el c√≥digo proporcionado'\n+        };\n+      }\n+\n+      const id_programa = programRows[0].id_programa;\n+\n+      const [result] = await pool.execute(\n+        `INSERT INTO fichas (codigo_ficha, id_programa, jornada, fecha_inicio, fecha_fin, estado, numero_aprendices, capacidad_maxima)\n+         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n+        [\n+          codigo_ficha,\n+          id_programa,\n+          jornada,\n+          fecha_inicio || null,\n+          fecha_fin || null,\n+          estado,\n+          numero_aprendices,\n+          capacidad_maxima\n+        ]\n+      );\n+\n+      const [inserted] = await pool.execute(\n+        `SELECT * FROM fichas WHERE id_ficha = ?`,\n+        [result.insertId]\n+      );\n+\n+      return {\n+        success: true,\n+        data: inserted[0]\n+      };\n+    } catch (error) {\n+      console.error('Error en createFicha:', error);\n+      if (error.code === 'ER_DUP_ENTRY') {\n+        return { success: false, message: 'Ya existe una ficha con ese c√≥digo' };\n+      }\n+      throw error;\n+    }\n+  }\n+\n   /**\n    * Obtener aprendices por ficha\n    */\n   static async getStudentsByFicha(codigoFicha, filters = {}) {\n@@ -683,59 +799,117 @@\n     }\n   }\n \n   /**\n-   * Obtener accesos por programa\n+   * Obtener accesos por programa de formaci√≥n (circuito abierto)\n    */\n   static async getAccessByProgram(codigoPrograma, filters = {}) {\n     try {\n       const fechaDesde = filters.fecha_desde || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n       const fechaHasta = filters.fecha_hasta || new Date().toISOString().split('T')[0];\n+      const idColumn = await getRegistroIdField();\n \n-      const query = `\n-        SELECT \n-          a.id_acceso,\n+      let query = `\n+        SELECT\n+          r.${idColumn} AS id_acceso,\n           p.documento,\n           p.tipo_documento,\n-          p.nombre as nombre_completo,\n-          p.ficha,\n+          CONCAT(p.nombres, ' ', p.apellidos) AS nombre_completo,\n+          f.codigo_ficha AS ficha,\n           pf.codigo_programa,\n           pf.nombre_programa,\n-          a.tipo_acceso,\n-          a.fecha_entrada,\n-          a.fecha_salida,\n-          TIMESTAMPDIFF(MINUTE, a.fecha_entrada, COALESCE(a.fecha_salida, NOW())) as duracion_minutos,\n-          a.estado\n-        FROM Accesos a\n-        INNER JOIN Personas p ON a.id_persona = p.id_persona\n-        INNER JOIN Programas_Formacion pf ON p.id_programa = pf.id_programa\n+          pf.nivel,\n+          r.tipo AS tipo_acceso,\n+          CASE WHEN r.tipo = 'ENTRADA' THEN r.fecha_hora ELSE (\n+            SELECT r2.fecha_hora\n+            FROM registros_entrada_salida r2\n+            WHERE r2.id_persona = r.id_persona\n+              AND r2.tipo = 'ENTRADA'\n+              AND r2.fecha_hora < r.fecha_hora\n+            ORDER BY r2.fecha_hora DESC\n+            LIMIT 1\n+          ) END AS fecha_entrada,\n+          CASE WHEN r.tipo = 'ENTRADA' THEN (\n+            SELECT r2.fecha_hora\n+            FROM registros_entrada_salida r2\n+            WHERE r2.id_persona = r.id_persona\n+              AND r2.tipo = 'SALIDA'\n+              AND r2.fecha_hora > r.fecha_hora\n+            ORDER BY r2.fecha_hora ASC\n+            LIMIT 1\n+          ) ELSE r.fecha_hora END AS fecha_salida,\n+          CASE WHEN r.tipo = 'ENTRADA' THEN (\n+            SELECT TIMESTAMPDIFF(MINUTE, r.fecha_hora, r2.fecha_hora)\n+            FROM registros_entrada_salida r2\n+            WHERE r2.id_persona = r.id_persona\n+              AND r2.tipo = 'SALIDA'\n+              AND r2.fecha_hora > r.fecha_hora\n+            ORDER BY r2.fecha_hora ASC\n+            LIMIT 1\n+          ) ELSE (\n+            SELECT TIMESTAMPDIFF(MINUTE, r2.fecha_hora, r.fecha_hora)\n+            FROM registros_entrada_salida r2\n+            WHERE r2.id_persona = r.id_persona\n+              AND r2.tipo = 'ENTRADA'\n+              AND r2.fecha_hora < r.fecha_hora\n+            ORDER BY r2.fecha_hora DESC\n+            LIMIT 1\n+          ) END AS duracion_minutos,\n+          CASE\n+            WHEN r.tipo = 'ENTRADA' AND EXISTS (\n+              SELECT 1\n+              FROM registros_entrada_salida r2\n+              WHERE r2.id_persona = r.id_persona\n+                AND r2.tipo = 'SALIDA'\n+                AND r2.fecha_hora > r.fecha_hora\n+            ) THEN 'completado'\n+            WHEN r.tipo = 'ENTRADA' THEN 'en curso'\n+            ELSE 'completado'\n+          END AS estado\n+        FROM registros_entrada_salida r\n+        LEFT JOIN Personas p ON r.id_persona = p.id_persona\n+        LEFT JOIN Roles role ON p.id_rol = role.id_rol\n+        LEFT JOIN fichas f ON p.id_ficha = f.id_ficha\n+        LEFT JOIN programas_formacion pf ON f.id_programa = pf.id_programa\n         WHERE pf.codigo_programa = ?\n-          AND DATE(a.fecha_entrada) BETWEEN ? AND ?\n-          AND p.rol = 'aprendiz'\n-        ORDER BY a.fecha_entrada DESC\n-        LIMIT 1000\n+          AND DATE(r.fecha_hora) BETWEEN ? AND ?\n       `;\n \n-      const [rows] = await pool.execute(query, [codigoPrograma, fechaDesde, fechaHasta]);\n+      const params = [codigoPrograma, fechaDesde, fechaHasta];\n \n-      // Estad√≠sticas\n+      if (filters.rol) {\n+        query += ` AND role.nombre_rol = ?`;\n+        params.push(filters.rol);\n+      }\n+\n+      query += ` ORDER BY r.fecha_hora DESC LIMIT 1000`;\n+\n+      const [rows] = await pool.execute(query, params);\n+\n       const estadisticas = {\n         total_accesos: rows.length,\n-        entradas: rows.filter(r => r.tipo_acceso === 'entrada').length,\n-        salidas: rows.filter(r => r.tipo_acceso === 'salida').length,\n+        entradas: rows.filter(r => r.tipo_acceso === 'ENTRADA').length,\n+        salidas: rows.filter(r => r.tipo_acceso === 'SALIDA').length,\n         aprendices_unicos: new Set(rows.map(r => r.documento)).size,\n         tiempo_promedio: rows.length > 0\n           ? Math.round(rows.reduce((sum, r) => sum + (r.duracion_minutos || 0), 0) / rows.length)\n           : 0\n       };\n \n       return {\n         success: true,\n-        data: rows,\n+        data: rows.map(row => ({\n+          ...row,\n+          tipo_acceso: row.tipo_acceso?.toLowerCase(),\n+          duracion_minutos: row.duracion_minutos !== null ? parseInt(row.duracion_minutos, 10) : null,\n+          fecha_entrada: row.fecha_entrada || null,\n+          fecha_salida: row.fecha_salida || null\n+        })),\n         estadisticas,\n         programa: rows[0] ? {\n           codigo: rows[0].codigo_programa,\n-          nombre: rows[0].nombre_programa\n+          nombre: rows[0].nombre_programa,\n+          nivel: rows[0].nivel\n         } : null,\n         periodo: {\n           fecha_desde: fechaDesde,\n           fecha_hasta: fechaHasta\n"
                },
                {
                    "date": 1764319581841,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -919,8 +919,103 @@\n       console.error('Error en getAccessByProgram:', error);\n       throw error;\n     }\n   }\n+\n+  /**\n+   * Obtener accesos por ficha\n+   */\n+  static async getAccessByFicha(codigoFicha, filters = {}) {\n+    try {\n+      const fechaDesde = filters.fecha_desde || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n+      const fechaHasta = filters.fecha_hasta || new Date().toISOString().split('T')[0];\n+      const idColumn = await getRegistroIdField();\n+\n+      const query = `\n+        SELECT\n+          r.${idColumn} AS id_acceso,\n+          p.documento,\n+          p.tipo_documento,\n+          CONCAT(p.nombres, ' ', p.apellidos) AS nombre_completo,\n+          f.codigo_ficha,\n+          pf.codigo_programa,\n+          pf.nombre_programa,\n+          pf.nivel,\n+          r.tipo AS tipo_acceso,\n+          r.fecha_hora AS fecha_registro,\n+          CASE WHEN r.tipo = 'ENTRADA' THEN (\n+            SELECT r2.fecha_hora\n+            FROM registros_entrada_salida r2\n+            WHERE r2.id_persona = r.id_persona\n+              AND r2.tipo = 'SALIDA'\n+              AND r2.fecha_hora > r.fecha_hora\n+            ORDER BY r2.fecha_hora ASC\n+            LIMIT 1\n+          ) ELSE NULL END AS fecha_salida,\n+          CASE WHEN r.tipo = 'ENTRADA' THEN (\n+            SELECT TIMESTAMPDIFF(MINUTE, r.fecha_hora, r2.fecha_hora)\n+            FROM registros_entrada_salida r2\n+            WHERE r2.id_persona = r.id_persona\n+              AND r2.tipo = 'SALIDA'\n+              AND r2.fecha_hora > r.fecha_hora\n+            ORDER BY r2.fecha_hora ASC\n+            LIMIT 1\n+          ) ELSE NULL END AS duracion_minutos,\n+          CASE\n+            WHEN r.tipo = 'ENTRADA' AND EXISTS (\n+              SELECT 1\n+              FROM registros_entrada_salida r2\n+              WHERE r2.id_persona = r.id_persona\n+                AND r2.tipo = 'SALIDA'\n+                AND r2.fecha_hora > r.fecha_hora\n+            ) THEN 'finalizado'\n+            WHEN r.tipo = 'ENTRADA' THEN 'activo'\n+            WHEN r.tipo = 'SALIDA' THEN 'finalizado'\n+            ELSE 'desconocido'\n+          END AS estado\n+        FROM registros_entrada_salida r\n+        INNER JOIN Personas p ON r.id_persona = p.id_persona\n+        LEFT JOIN fichas f ON p.id_ficha = f.id_ficha\n+        LEFT JOIN programas_formacion pf ON f.id_programa = pf.id_programa\n+        WHERE f.codigo_ficha = ?\n+          AND DATE(r.fecha_hora) BETWEEN ? AND ?\n+        ORDER BY r.fecha_hora DESC\n+        LIMIT 1000\n+      `;\n+\n+      const [rows] = await pool.execute(query, [codigoFicha, fechaDesde, fechaHasta]);\n+\n+      // Estad√≠sticas\n+      const estadisticas = {\n+        total_accesos: rows.length,\n+        entradas: rows.filter(r => r.tipo_acceso === 'ENTRADA').length,\n+        salidas: rows.filter(r => r.tipo_acceso === 'SALIDA').length,\n+        personas_unicas: new Set(rows.map(r => r.documento)).size,\n+        tiempo_promedio_minutos: rows.length > 0\n+          ? Math.round(rows.reduce((sum, r) => sum + (r.duracion_minutos || 0), 0) / rows.filter(r => r.duracion_minutos).length) || 0\n+          : 0\n+      };\n+\n+      return {\n+        success: true,\n+        data: rows,\n+        estadisticas,\n+        ficha: rows[0] ? {\n+          codigo: rows[0].codigo_ficha,\n+          programa: rows[0].nombre_programa,\n+          codigo_programa: rows[0].codigo_programa,\n+          nivel: rows[0].nivel\n+        } : null,\n+        periodo: {\n+          fecha_desde: fechaDesde,\n+          fecha_hasta: fechaHasta\n+        }\n+      };\n+    } catch (error) {\n+      console.error('Error en getAccessByFicha:', error);\n+      throw error;\n+    }\n+  }\n }\n \n \n \n"
                }
            ],
            "date": 1764109750454,
            "name": "Commit-0",
            "content": "// Catalog Service - Servicio de cat√°logo de programas y ambientes\nimport pool from '../utils/dbPool.js';\n\nexport class CatalogService {\n  /**\n   * Obtener todos los programas de formaci√≥n\n   */\n  static async getAllPrograms(filters = {}) {\n    try {\n      // Verificar si la tabla existe\n      try {\n        const [tableCheck] = await pool.execute(`\n          SELECT COUNT(*) as exists_table\n          FROM INFORMATION_SCHEMA.TABLES\n          WHERE TABLE_SCHEMA = DATABASE()\n          AND TABLE_NAME = 'Programas_Formacion'\n        `);\n        \n        if (!tableCheck || tableCheck.length === 0 || tableCheck[0].exists_table === 0) {\n          console.warn('‚ö†Ô∏è  Tabla Programas_Formacion no existe');\n          return {\n            success: true,\n            data: [],\n            total: 0,\n            message: 'La tabla Programas_Formacion no existe en la base de datos'\n          };\n        }\n      } catch (checkError) {\n        console.warn('‚ö†Ô∏è  Error verificando existencia de tabla Programas_Formacion:', checkError.message);\n      }\n\n      let query = `\n        SELECT \n          id_programa,\n          codigo_programa,\n          nombre_programa,\n          nivel,\n          duracion_meses,\n          area_conocimiento,\n          descripcion,\n          estado,\n          fecha_creacion\n        FROM Programas_Formacion\n        WHERE 1=1\n      `;\n\n      const params = [];\n\n      if (filters.nivel && filters.nivel.trim() !== '') {\n        query += ` AND nivel = ?`;\n        params.push(filters.nivel);\n      }\n\n      if (filters.area && filters.area.trim() !== '') {\n        query += ` AND area_conocimiento LIKE ?`;\n        params.push(`%${filters.area}%`);\n      }\n\n      if (filters.estado && filters.estado.trim() !== '') {\n        query += ` AND estado = ?`;\n        params.push(filters.estado);\n      }\n\n      if (filters.search && filters.search.trim() !== '') {\n        query += ` AND (nombre_programa LIKE ? OR codigo_programa LIKE ?)`;\n        const searchTerm = `%${filters.search}%`;\n        params.push(searchTerm, searchTerm);\n      }\n\n      query += ` ORDER BY nivel, area_conocimiento, nombre_programa`;\n\n      console.log('üìù Ejecutando consulta getAllPrograms:', query);\n      console.log('üìä Par√°metros:', params);\n      \n      const [rows] = await pool.execute(query, params);\n\n      console.log(`‚úÖ getAllPrograms: ${rows.length} programas encontrados`);\n\n      return {\n        success: true,\n        data: rows || [],\n        total: rows?.length || 0\n      };\n    } catch (error) {\n      console.error('‚ùå Error en getAllPrograms:', error);\n      console.error('‚ùå C√≥digo:', error.code);\n      console.error('‚ùå SQL State:', error.sqlState);\n      console.error('‚ùå Stack:', error.stack);\n      \n      // Si la tabla no existe, devolver array vac√≠o en lugar de error\n      if (error.code === 'ER_NO_SUCH_TABLE' || error.code === 1146) {\n        console.warn('‚ö†Ô∏è  Tabla Programas_Formacion no existe, retornando array vac√≠o');\n        return {\n          success: true,\n          data: [],\n          total: 0,\n          message: 'La tabla Programas_Formacion no existe en la base de datos'\n        };\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Obtener programa por c√≥digo\n   */\n  static async getProgramByCode(codigo) {\n    try {\n      const [rows] = await pool.execute(\n        `SELECT * FROM Programas_Formacion WHERE codigo_programa = ?`,\n        [codigo]\n      );\n\n      if (rows.length === 0) {\n        return {\n          success: false,\n          error: 'Programa no encontrado'\n        };\n      }\n\n      return {\n        success: true,\n        data: rows[0]\n      };\n    } catch (error) {\n      console.error('Error en getProgramByCode:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener todas las fichas\n   */\n  static async getAllFichas(filters = {}) {\n    try {\n      console.log('üîç [getAllFichas] Iniciando consulta con filtros:', filters);\n      \n      // Verificar si la tabla existe (case-insensitive)\n      try {\n        const [tableCheck] = await pool.execute(`\n          SELECT COUNT(*) as exists_table\n          FROM INFORMATION_SCHEMA.TABLES\n          WHERE TABLE_SCHEMA = DATABASE()\n          AND LOWER(TABLE_NAME) = 'fichas'\n        `);\n        \n        if (!tableCheck || tableCheck.length === 0 || tableCheck[0].exists_table === 0) {\n          console.warn('‚ö†Ô∏è  [getAllFichas] Tabla fichas no existe');\n          return {\n            success: true,\n            data: [],\n            total: 0,\n            message: 'La tabla fichas no existe en la base de datos'\n          };\n        }\n        console.log('‚úÖ [getAllFichas] Tabla fichas existe');\n      } catch (checkError) {\n        console.warn('‚ö†Ô∏è  [getAllFichas] Error verificando existencia de tabla fichas:', checkError.message);\n      }\n\n      // Verificar si hay fichas en la tabla (usar backticks para manejar case)\n      try {\n        const [countCheck] = await pool.execute('SELECT COUNT(*) as total FROM `fichas`');\n        const totalFichas = parseInt(countCheck[0]?.total) || 0;\n        console.log(`üìä [getAllFichas] Total de fichas en la tabla: ${totalFichas}`);\n        \n        if (totalFichas === 0) {\n          console.warn('‚ö†Ô∏è  [getAllFichas] No hay fichas en la tabla');\n          return {\n            success: true,\n            data: [],\n            total: 0,\n            message: 'No hay fichas registradas en la base de datos'\n          };\n        }\n      } catch (countError) {\n        console.warn('‚ö†Ô∏è  [getAllFichas] Error contando fichas:', countError.message);\n        // Continuar con la consulta principal aunque falle el conteo\n      }\n\n      let query = `\n        SELECT \n          f.id_ficha,\n          f.codigo_ficha,\n          f.programa_formacion,\n          f.jornada,\n          f.fecha_inicio,\n          f.fecha_fin,\n          f.estado,\n          f.numero_aprendices,\n          f.capacidad_maxima,\n          COALESCE(f.observaciones, f.observacion, NULL) as observaciones,\n          f.fecha_creacion,\n          COALESCE(pf.codigo_programa, NULL) as codigo_programa,\n          COALESCE(pf.nombre_programa, NULL) as nombre_programa,\n          COALESCE(pf.nivel, NULL) as nivel,\n          COALESCE(pf.area_conocimiento, NULL) as area_conocimiento,\n          COALESCE(a.codigo_ambiente, NULL) as codigo_ambiente,\n          COALESCE(a.nombre_ambiente, NULL) as nombre_ambiente,\n          COALESCE(a.bloque, NULL) as bloque,\n          COALESCE((\n            SELECT COUNT(*)\n            FROM Personas p\n            WHERE p.id_ficha = f.id_ficha\n            AND (p.rol = 'aprendiz' OR p.rol = 'APRENDIZ')\n            AND (p.estado = 'activo' OR p.estado = 'ACTIVO' OR p.estado IS NULL)\n          ), 0) as aprendices_activos\n        FROM \\`fichas\\` f\n        LEFT JOIN \\`Programas_Formacion\\` pf ON f.id_programa = pf.id_programa\n        LEFT JOIN \\`Ambientes\\` a ON f.id_ambiente_principal = a.id_ambiente\n        WHERE 1=1\n      `;\n\n      const params = [];\n\n      // Normalizar estado a min√∫sculas para comparaci√≥n\n      if (filters.estado && filters.estado.trim() !== '') {\n        const estadoNormalizado = filters.estado.trim().toLowerCase();\n        query += ` AND LOWER(f.estado) = ?`;\n        params.push(estadoNormalizado);\n        console.log(`üìã [getAllFichas] Filtro estado aplicado: ${estadoNormalizado}`);\n      }\n\n      if (filters.jornada && filters.jornada.trim() !== '') {\n        const jornadaNormalizada = filters.jornada.trim().toLowerCase();\n        query += ` AND LOWER(f.jornada) = ?`;\n        params.push(jornadaNormalizada);\n        console.log(`üìã [getAllFichas] Filtro jornada aplicado: ${jornadaNormalizada}`);\n      }\n\n      if (filters.programa && filters.programa.trim() !== '') {\n        query += ` AND (f.programa_formacion LIKE ? OR pf.nombre_programa LIKE ?)`;\n        const searchTerm = `%${filters.programa.trim()}%`;\n        params.push(searchTerm, searchTerm);\n        console.log(`üìã [getAllFichas] Filtro programa aplicado: ${searchTerm}`);\n      }\n\n      if (filters.search && filters.search.trim() !== '') {\n        query += ` AND (f.codigo_ficha LIKE ? OR f.programa_formacion LIKE ?)`;\n        const searchTerm = `%${filters.search.trim()}%`;\n        params.push(searchTerm, searchTerm);\n        console.log(`üìã [getAllFichas] Filtro b√∫squeda aplicado: ${searchTerm}`);\n      }\n\n      query += ` ORDER BY f.fecha_inicio DESC, f.codigo_ficha`;\n\n      console.log('üìù [getAllFichas] Consulta SQL:', query);\n      console.log('üìä [getAllFichas] Par√°metros:', params);\n      \n      const [rows] = await pool.execute(query, params);\n\n      console.log(`‚úÖ [getAllFichas] Consulta exitosa: ${rows.length} fichas encontradas`);\n      \n      if (rows.length > 0) {\n        console.log('üìã [getAllFichas] Primera ficha:', JSON.stringify(rows[0], null, 2));\n      }\n\n      return {\n        success: true,\n        data: rows || [],\n        total: rows?.length || 0\n      };\n    } catch (error) {\n      console.error('‚ùå [getAllFichas] Error:', error);\n      console.error('‚ùå [getAllFichas] C√≥digo:', error.code);\n      console.error('‚ùå [getAllFichas] SQL State:', error.sqlState);\n      console.error('‚ùå [getAllFichas] Mensaje:', error.message);\n      console.error('‚ùå [getAllFichas] Stack:', error.stack);\n      \n      // Si la tabla no existe, devolver array vac√≠o en lugar de error\n      if (error.code === 'ER_NO_SUCH_TABLE' || error.code === 1146) {\n        console.warn('‚ö†Ô∏è  [getAllFichas] Tabla Fichas no existe, retornando array vac√≠o');\n        return {\n          success: true,\n          data: [],\n          total: 0,\n          message: 'La tabla Fichas no existe en la base de datos'\n        };\n      }\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Obtener ficha por c√≥digo\n   */\n  static async getFichaByCode(codigo) {\n    try {\n      const [rows] = await pool.execute(\n        `SELECT \n          f.*,\n          pf.codigo_programa,\n          pf.nombre_programa,\n          pf.nivel,\n          pf.area_conocimiento,\n          a.codigo_ambiente,\n          a.nombre_ambiente,\n          a.bloque,\n          (\n            SELECT COUNT(*)\n            FROM Personas p\n            WHERE p.id_ficha = f.id_ficha\n            AND p.rol = 'aprendiz'\n            AND p.estado = 'activo'\n          ) as aprendices_activos\n         FROM \\`fichas\\` f\n         LEFT JOIN \\`Programas_Formacion\\` pf ON f.id_programa = pf.id_programa\n         LEFT JOIN \\`Ambientes\\` a ON f.id_ambiente_principal = a.id_ambiente\n         WHERE f.codigo_ficha = ?`,\n        [codigo]\n      );\n\n      if (rows.length === 0) {\n        return {\n          success: false,\n          error: 'Ficha no encontrada'\n        };\n      }\n\n      return {\n        success: true,\n        data: rows[0]\n      };\n    } catch (error) {\n      console.error('Error en getFichaByCode:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener aprendices por ficha\n   */\n  static async getStudentsByFicha(codigoFicha, filters = {}) {\n    try {\n      let query = `\n        SELECT \n          p.id_persona,\n          p.documento,\n          p.tipo_documento,\n          p.nombre,\n          p.email,\n          p.telefono,\n          p.ficha,\n          p.estado,\n          f.codigo_ficha,\n          f.programa_formacion,\n          f.jornada,\n          (\n            SELECT MAX(a.fecha_entrada)\n            FROM Accesos a\n            WHERE a.id_persona = p.id_persona\n          ) as ultimo_acceso,\n          (\n            SELECT COUNT(*)\n            FROM Accesos a\n            WHERE a.id_persona = p.id_persona\n            AND DATE(a.fecha_entrada) >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\n          ) as accesos_mes\n        FROM Personas p\n        INNER JOIN Fichas f ON p.id_ficha = f.id_ficha\n        WHERE f.codigo_ficha = ?\n          AND p.rol = 'aprendiz'\n      `;\n\n      const params = [codigoFicha];\n\n      if (filters.estado) {\n        query += ` AND p.estado = ?`;\n        params.push(filters.estado);\n      }\n\n      query += ` ORDER BY p.nombre`;\n\n      const [rows] = await pool.execute(query, params);\n\n      return {\n        success: true,\n        data: rows,\n        total: rows.length,\n        ficha: rows[0] ? {\n          codigo: rows[0].codigo_ficha,\n          programa: rows[0].programa_formacion,\n          jornada: rows[0].jornada\n        } : null\n      };\n    } catch (error) {\n      console.error('Error en getStudentsByFicha:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener todos los ambientes\n   */\n  static async getAllAmbientes(filters = {}) {\n    try {\n      let query = `\n        SELECT \n          id_ambiente,\n          codigo_ambiente,\n          nombre_ambiente,\n          tipo_ambiente,\n          capacidad,\n          bloque,\n          piso,\n          equipamiento,\n          estado,\n          fecha_creacion\n        FROM Ambientes\n        WHERE 1=1\n      `;\n\n      const params = [];\n\n      if (filters.tipo) {\n        query += ` AND tipo_ambiente = ?`;\n        params.push(filters.tipo);\n      }\n\n      if (filters.bloque) {\n        query += ` AND bloque LIKE ?`;\n        params.push(`%${filters.bloque}%`);\n      }\n\n      if (filters.estado) {\n        query += ` AND estado = ?`;\n        params.push(filters.estado);\n      }\n\n      if (filters.search) {\n        query += ` AND (nombre_ambiente LIKE ? OR codigo_ambiente LIKE ?)`;\n        const searchTerm = `%${filters.search}%`;\n        params.push(searchTerm, searchTerm);\n      }\n\n      query += ` ORDER BY bloque, piso, codigo_ambiente`;\n\n      const [rows] = await pool.execute(query, params);\n\n      // Parsear equipamiento JSON\n      const parsedRows = rows.map(row => ({\n        ...row,\n        equipamiento: row.equipamiento ? JSON.parse(row.equipamiento) : []\n      }));\n\n      return {\n        success: true,\n        data: parsedRows,\n        total: parsedRows.length\n      };\n    } catch (error) {\n      console.error('Error en getAllAmbientes:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener ambiente por c√≥digo\n   */\n  static async getAmbienteByCode(codigo) {\n    try {\n      const [rows] = await pool.execute(\n        `SELECT * FROM Ambientes WHERE codigo_ambiente = ?`,\n        [codigo]\n      );\n\n      if (rows.length === 0) {\n        return {\n          success: false,\n          error: 'Ambiente no encontrado'\n        };\n      }\n\n      const ambiente = {\n        ...rows[0],\n        equipamiento: rows[0].equipamiento ? JSON.parse(rows[0].equipamiento) : []\n      };\n\n      return {\n        success: true,\n        data: ambiente\n      };\n    } catch (error) {\n      console.error('Error en getAmbienteByCode:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener ambientes por tipo\n   */\n  static async getAmbientesByType(tipo) {\n    try {\n      const [rows] = await pool.execute(\n        `SELECT * FROM Ambientes WHERE tipo_ambiente = ? AND estado = 'activo' ORDER BY bloque, piso`,\n        [tipo]\n      );\n\n      const parsedRows = rows.map(row => ({\n        ...row,\n        equipamiento: row.equipamiento ? JSON.parse(row.equipamiento) : []\n      }));\n\n      return {\n        success: true,\n        data: parsedRows,\n        total: parsedRows.length\n      };\n    } catch (error) {\n      console.error('Error en getAmbientesByType:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener aprendices por programa\n   */\n  static async getStudentsByProgram(codigoPrograma, filters = {}) {\n    try {\n      // Primero obtener informaci√≥n del programa\n      const [programas] = await pool.execute(\n        'SELECT id_programa, codigo_programa, nombre_programa, nivel, area_conocimiento FROM Programas_Formacion WHERE codigo_programa = ?',\n        [codigoPrograma]\n      );\n\n      if (programas.length === 0) {\n        return {\n          success: false,\n          message: 'Programa no encontrado',\n          data: [],\n          total: 0,\n          programa: null\n        };\n      }\n\n      const programa = programas[0];\n\n      // Consulta mejorada: busca por id_programa O por nombre del programa\n      // Esto permite encontrar aprendices que fueron importados antes de asignar id_programa\n      let query = `\n        SELECT DISTINCT\n          p.id_persona,\n          p.documento,\n          p.tipo_documento,\n          p.nombre,\n          p.email,\n          p.telefono,\n          p.ficha,\n          p.estado,\n          COALESCE(pf.codigo_programa, ?) as codigo_programa,\n          COALESCE(pf.nombre_programa, p.programa) as nombre_programa,\n          COALESCE(pf.nivel, 'N/A') as nivel,\n          COALESCE(pf.area_conocimiento, 'N/A') as area_conocimiento,\n          (\n            SELECT MAX(a.fecha_entrada)\n            FROM Accesos a\n            WHERE a.id_persona = p.id_persona\n          ) as ultimo_acceso,\n          (\n            SELECT COUNT(*)\n            FROM Accesos a\n            WHERE a.id_persona = p.id_persona\n            AND DATE(a.fecha_entrada) >= DATE_SUB(CURDATE(), INTERVAL 30 DAY)\n          ) as accesos_mes\n        FROM Personas p\n        LEFT JOIN Programas_Formacion pf ON p.id_programa = pf.id_programa\n        WHERE p.rol = 'aprendiz'\n          AND (\n            (p.id_programa = ? AND pf.codigo_programa = ?)\n            OR \n            (p.id_programa IS NULL AND p.programa = ?)\n            OR\n            (p.id_programa IS NULL AND p.programa LIKE ?)\n          )\n      `;\n\n      const params = [\n        programa.codigo_programa,\n        programa.id_programa,\n        codigoPrograma,\n        programa.nombre_programa,\n        `%${programa.nombre_programa}%`\n      ];\n\n      if (filters.estado) {\n        query += ` AND p.estado = ?`;\n        params.push(filters.estado);\n      }\n\n      if (filters.ficha) {\n        query += ` AND p.ficha LIKE ?`;\n        params.push(`%${filters.ficha}%`);\n      }\n\n      query += ` ORDER BY p.ficha, p.nombre`;\n\n      const [rows] = await pool.execute(query, params);\n\n      return {\n        success: true,\n        data: rows,\n        total: rows.length,\n        programa: {\n          codigo: programa.codigo_programa,\n          nombre: programa.nombre_programa,\n          nivel: programa.nivel,\n          area: programa.area_conocimiento\n        }\n      };\n    } catch (error) {\n      console.error('Error en getStudentsByProgram:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener ocupaci√≥n actual de un ambiente\n   */\n  static async getAmbientOccupation(codigoAmbiente) {\n    try {\n      // Primero obtener el ambiente\n      const ambienteResult = await this.getAmbienteByCode(codigoAmbiente);\n      if (!ambienteResult.success) {\n        return ambienteResult;\n      }\n\n      const ambiente = ambienteResult.data;\n\n      // Buscar personas actualmente dentro (usando zona si existe)\n      // Por ahora usamos una aproximaci√≥n basada en accesos activos\n      const [ocupacionRows] = await pool.execute(\n        `SELECT \n          COUNT(DISTINCT a.id_persona) as ocupacion_actual,\n          GROUP_CONCAT(DISTINCT CONCAT(p.nombre, ' (', p.documento, ')') SEPARATOR ', ') as personas_presentes\n        FROM Accesos a\n        INNER JOIN Personas p ON a.id_persona = p.id_persona\n        WHERE a.fecha_salida IS NULL\n          AND a.estado = 'activo'\n          AND DATE(a.fecha_entrada) = CURDATE()\n        LIMIT 50\n        `,\n        []\n      );\n\n      const ocupacion = ocupacionRows[0]?.ocupacion_actual || 0;\n      const disponibilidad = ambiente.capacidad - ocupacion;\n      const porcentaje = ambiente.capacidad > 0 \n        ? Math.round((ocupacion / ambiente.capacidad) * 100) \n        : 0;\n\n      return {\n        success: true,\n        data: {\n          ambiente: {\n            codigo: ambiente.codigo_ambiente,\n            nombre: ambiente.nombre_ambiente,\n            tipo: ambiente.tipo_ambiente,\n            bloque: ambiente.bloque,\n            piso: ambiente.piso,\n            capacidad: ambiente.capacidad\n          },\n          ocupacion: {\n            actual: ocupacion,\n            capacidad: ambiente.capacidad,\n            disponibilidad: disponibilidad,\n            porcentaje: porcentaje\n          },\n          personas_presentes: ocupacionRows[0]?.personas_presentes || 'Ninguna'\n        }\n      };\n    } catch (error) {\n      console.error('Error en getAmbientOccupation:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Obtener accesos por programa\n   */\n  static async getAccessByProgram(codigoPrograma, filters = {}) {\n    try {\n      const fechaDesde = filters.fecha_desde || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n      const fechaHasta = filters.fecha_hasta || new Date().toISOString().split('T')[0];\n\n      const query = `\n        SELECT \n          a.id_acceso,\n          p.documento,\n          p.tipo_documento,\n          p.nombre as nombre_completo,\n          p.ficha,\n          pf.codigo_programa,\n          pf.nombre_programa,\n          a.tipo_acceso,\n          a.fecha_entrada,\n          a.fecha_salida,\n          TIMESTAMPDIFF(MINUTE, a.fecha_entrada, COALESCE(a.fecha_salida, NOW())) as duracion_minutos,\n          a.estado\n        FROM Accesos a\n        INNER JOIN Personas p ON a.id_persona = p.id_persona\n        INNER JOIN Programas_Formacion pf ON p.id_programa = pf.id_programa\n        WHERE pf.codigo_programa = ?\n          AND DATE(a.fecha_entrada) BETWEEN ? AND ?\n          AND p.rol = 'aprendiz'\n        ORDER BY a.fecha_entrada DESC\n        LIMIT 1000\n      `;\n\n      const [rows] = await pool.execute(query, [codigoPrograma, fechaDesde, fechaHasta]);\n\n      // Estad√≠sticas\n      const estadisticas = {\n        total_accesos: rows.length,\n        entradas: rows.filter(r => r.tipo_acceso === 'entrada').length,\n        salidas: rows.filter(r => r.tipo_acceso === 'salida').length,\n        aprendices_unicos: new Set(rows.map(r => r.documento)).size,\n        tiempo_promedio: rows.length > 0\n          ? Math.round(rows.reduce((sum, r) => sum + (r.duracion_minutos || 0), 0) / rows.length)\n          : 0\n      };\n\n      return {\n        success: true,\n        data: rows,\n        estadisticas,\n        programa: rows[0] ? {\n          codigo: rows[0].codigo_programa,\n          nombre: rows[0].nombre_programa\n        } : null,\n        periodo: {\n          fecha_desde: fechaDesde,\n          fecha_hasta: fechaHasta\n        }\n      };\n    } catch (error) {\n      console.error('Error en getAccessByProgram:', error);\n      throw error;\n    }\n  }\n}\n\n\n\n\n"
        }
    ]
}