{
    "sourceFile": "control-acceso-sena/backend/src/services/AlertService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 3,
            "patches": [
                {
                    "date": 1764227753645,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764232818318,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,6 +1,7 @@\n // Alert Service - Gesti√≥n de alertas autom√°ticas\n import pool from '../utils/dbPool.js';\n+import { getRegistroIdField } from '../utils/columnResolver.js';\n \n class AlertService {\n   // Crear una nueva alerta\n   static async createAlert(alertData) {\n@@ -284,16 +285,23 @@\n   }\n \n   // Verificar accesos fuera de horario\n   static async checkOffScheduleAccess() {\n+    const idColumn = await getRegistroIdField();\n+    const fullNameExpr = \"CONCAT(p.nombres, ' ', p.apellidos)\";\n     const [rows] = await pool.execute(`\n       SELECT \n-        r.id_registro_entrada_salida as id_acceso,\n+        r.${idColumn} as id_acceso,\n         r.fecha_hora,\n         p.id_persona,\n-        p.nombre,\n         p.documento,\n         COALESCE(role.nombre_rol, 'sin rol') as rol,\n+        COALESCE(\n+          ${fullNameExpr},\n+          p.nombres,\n+          p.apellidos,\n+          'Sin nombre'\n+        ) as persona_nombre,\n         TIME(r.fecha_hora) as hora_acceso\n       FROM registros_entrada_salida r\n       INNER JOIN Personas p ON r.id_persona = p.id_persona\n       LEFT JOIN Roles role ON p.id_rol = role.id_rol\n@@ -301,9 +309,9 @@\n       AND (HOUR(r.fecha_hora) < 6 OR HOUR(r.fecha_hora) > 22)\n       AND r.tipo = 'ENTRADA'\n       AND NOT EXISTS (\n         SELECT 1 FROM Alertas al \n-        WHERE al.id_acceso = r.id_registro_entrada_salida\n+        WHERE al.id_acceso = r.${idColumn}\n         AND al.tipo = 'acceso_fuera_horario'\n       )\n     `);\n \n@@ -313,9 +321,9 @@\n         const alertId = await this.createAlert({\n           tipo: 'acceso_fuera_horario',\n           severidad: 'media',\n           titulo: 'Acceso fuera de horario',\n-          mensaje: `${row.nombre} (${row.documento}) ingres√≥ fuera del horario permitido a las ${row.hora_acceso}`,\n+          mensaje: `${row.persona_nombre} (${row.documento}) ingres√≥ fuera del horario permitido a las ${row.hora_acceso}`,\n           id_persona: row.id_persona,\n           id_acceso: row.id_acceso,\n           metadata: {\n             hora_acceso: row.hora_acceso,\n@@ -336,14 +344,20 @@\n   }\n \n   // Verificar visitantes pr√≥ximos a expirar\n   static async checkExpiringVisitors() {\n+    const fullNameExpr = \"CONCAT(p.nombres, ' ', p.apellidos)\";\n     const [rows] = await pool.execute(`\n       SELECT \n         v.id_visitante,\n         v.fecha_inicio,\n         p.id_persona,\n-        p.nombre,\n+        COALESCE(\n+          ${fullNameExpr},\n+          p.nombres,\n+          p.apellidos,\n+          'Sin nombre'\n+        ) as persona_nombre,\n         p.documento,\n         TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) as horas_transcurridas\n       FROM Visitantes v\n       INNER JOIN Personas p ON v.id_persona = p.id_persona\n@@ -365,9 +379,9 @@\n         const alertId = await this.createAlert({\n           tipo: 'qr_expirado',\n           severidad: 'baja',\n           titulo: 'Visitante pr√≥ximo a expirar',\n-          mensaje: `El QR de ${row.nombre} expirar√° en menos de 1 hora`,\n+          mensaje: `El QR de ${row.persona_nombre} expirar√° en menos de 1 hora`,\n           id_persona: row.id_persona,\n           metadata: {\n             horas_transcurridas: row.horas_transcurridas,\n             id_visitante: row.id_visitante\n"
                },
                {
                    "date": 1764311031183,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -252,41 +252,43 @@\n   }\n \n   // Obtener estad√≠sticas de alertas\n   static async getAlertStats() {\n-    const [stats] = await pool.execute(`\n-      SELECT \n-        COUNT(*) as total,\n-        SUM(CASE WHEN leida = FALSE THEN 1 ELSE 0 END) as pendientes,\n-        SUM(CASE WHEN severidad = 'critica' AND leida = FALSE THEN 1 ELSE 0 END) as criticas_pendientes,\n-        SUM(CASE WHEN severidad = 'alta' AND leida = FALSE THEN 1 ELSE 0 END) as altas_pendientes,\n-        SUM(CASE WHEN DATE(fecha_creacion) = CURDATE() THEN 1 ELSE 0 END) as hoy\n-      FROM Alertas\n-    `);\n+    const alerts = await this.generateAlerts();\n+    const today = new Date().toISOString().split('T')[0];\n \n-    const [byType] = await pool.execute(`\n-      SELECT tipo, COUNT(*) as cantidad\n-      FROM Alertas\n-      WHERE leida = FALSE\n-      GROUP BY tipo\n-    `);\n+    const byTypeMap = alerts.reduce((acc, alert) => {\n+      const tipo = alert.type || 'general';\n+      acc[tipo] = (acc[tipo] || 0) + 1;\n+      return acc;\n+    }, {});\n \n-    const [bySeverity] = await pool.execute(`\n-      SELECT severidad, COUNT(*) as cantidad\n-      FROM Alertas\n-      WHERE leida = FALSE\n-      GROUP BY severidad\n-    `);\n+    const bySeverityMap = alerts.reduce((acc, alert) => {\n+      const severity = (alert.severity || alert.severidad || 'media').toLowerCase();\n+      acc[severity] = (acc[severity] || 0) + 1;\n+      return acc;\n+    }, {});\n \n+    const todayCount = alerts.filter(alert => {\n+      const created = alert.createdAt || alert.fecha_creacion;\n+      if (!created) return false;\n+      const createdDay = new Date(created).toISOString().split('T')[0];\n+      return createdDay === today;\n+    }).length;\n+\n     return {\n-      ...stats[0],\n-      porTipo: byType,\n-      porSeveridad: bySeverity\n+      total: alerts.length,\n+      pendientes: alerts.length,\n+      criticas_pendientes: bySeverityMap['critica'] || 0,\n+      altas_pendientes: bySeverityMap['alta'] || 0,\n+      hoy: todayCount,\n+      porTipo: Object.entries(byTypeMap).map(([tipo, cantidad]) => ({ tipo, cantidad })),\n+      porSeveridad: Object.entries(bySeverityMap).map(([severidad, cantidad]) => ({ severidad, cantidad }))\n     };\n   }\n \n-  // Verificar accesos fuera de horario\n-  static async checkOffScheduleAccess() {\n+  // Detectar accesos fuera de horario\n+  static async detectOffScheduleAccess() {\n     const idColumn = await getRegistroIdField();\n     const fullNameExpr = \"CONCAT(p.nombres, ' ', p.apellidos)\";\n     const [rows] = await pool.execute(`\n       SELECT \n@@ -307,99 +309,97 @@\n       LEFT JOIN Roles role ON p.id_rol = role.id_rol\n       WHERE DATE(r.fecha_hora) = CURDATE()\n       AND (HOUR(r.fecha_hora) < 6 OR HOUR(r.fecha_hora) > 22)\n       AND r.tipo = 'ENTRADA'\n-      AND NOT EXISTS (\n-        SELECT 1 FROM Alertas al \n-        WHERE al.id_acceso = r.${idColumn}\n-        AND al.tipo = 'acceso_fuera_horario'\n-      )\n+      AND r.tipo = 'ENTRADA'\n     `);\n \n-    const alertsCreated = [];\n-    for (const row of rows) {\n-      try {\n-        const alertId = await this.createAlert({\n-          tipo: 'acceso_fuera_horario',\n-          severidad: 'media',\n-          titulo: 'Acceso fuera de horario',\n-          mensaje: `${row.persona_nombre} (${row.documento}) ingres√≥ fuera del horario permitido a las ${row.hora_acceso}`,\n-          id_persona: row.id_persona,\n-          id_acceso: row.id_acceso,\n-          metadata: {\n-            hora_acceso: row.hora_acceso,\n-            rol: row.rol\n-          }\n-        });\n-        // Solo agregar si la alerta se cre√≥ exitosamente (no es null)\n-        if (alertId !== null) {\n-          alertsCreated.push(alertId);\n-        }\n-      } catch (error) {\n-        console.error(`Error al crear alerta de acceso fuera de horario para ${row.documento}:`, error.message);\n-        // Continuar con el siguiente registro aunque falle uno\n+    return rows.map(row => ({\n+      id: `out_${row.id_acceso}`,\n+      type: 'acceso_fuera_horario',\n+      severity: 'media',\n+      title: 'Acceso fuera de horario',\n+      message: `${row.persona_nombre} (${row.documento}) ingres√≥ fuera del horario permitido a las ${row.hora_acceso}`,\n+      createdAt: row.fecha_hora,\n+      metadata: {\n+        id_persona: row.id_persona,\n+        documento: row.documento,\n+        hora_acceso: row.hora_acceso,\n+        rol: row.rol || 'sin rol'\n       }\n-    }\n-\n-    return alertsCreated;\n+    }));\n   }\n \n-  // Verificar visitantes pr√≥ximos a expirar\n-  static async checkExpiringVisitors() {\n+  // Detectar visitantes pr√≥ximos a expirar\n+  static async detectExpiringVisitors() {\n     const fullNameExpr = \"CONCAT(p.nombres, ' ', p.apellidos)\";\n-    const [rows] = await pool.execute(`\n-      SELECT \n-        v.id_visitante,\n-        v.fecha_inicio,\n-        p.id_persona,\n-        COALESCE(\n-          ${fullNameExpr},\n-          p.nombres,\n-          p.apellidos,\n-          'Sin nombre'\n-        ) as persona_nombre,\n-        p.documento,\n-        TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) as horas_transcurridas\n-      FROM Visitantes v\n-      INNER JOIN Personas p ON v.id_persona = p.id_persona\n-      WHERE v.estado = 'activo'\n-      AND v.fecha_fin IS NULL\n-      AND TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) >= 23\n-      AND TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) < 24\n-      AND NOT EXISTS (\n-        SELECT 1 FROM Alertas al \n-        WHERE al.id_persona = p.id_persona \n-        AND al.tipo = 'qr_expirado'\n-        AND DATE(al.fecha_creacion) = CURDATE()\n-      )\n-    `);\n+    const tableCandidates = ['Visitantes', 'visitantes'];\n \n-    const alertsCreated = [];\n-    for (const row of rows) {\n+    for (const tableName of tableCandidates) {\n       try {\n-        const alertId = await this.createAlert({\n-          tipo: 'qr_expirado',\n-          severidad: 'baja',\n-          titulo: 'Visitante pr√≥ximo a expirar',\n-          mensaje: `El QR de ${row.persona_nombre} expirar√° en menos de 1 hora`,\n-          id_persona: row.id_persona,\n+        const [rows] = await pool.execute(`\n+          SELECT \n+            v.id_visitante,\n+            v.fecha_inicio,\n+            p.id_persona,\n+            COALESCE(\n+              ${fullNameExpr},\n+              p.nombres,\n+              p.apellidos,\n+              'Sin nombre'\n+            ) as persona_nombre,\n+            p.documento,\n+            TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) as horas_transcurridas\n+          FROM ${tableName} v\n+          INNER JOIN Personas p ON v.id_persona = p.id_persona\n+          WHERE v.estado IN ('activo', 'ACTIVO')\n+            AND (v.fecha_fin IS NULL OR v.fecha_fin > NOW())\n+            AND TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) BETWEEN 23 AND 24\n+        `);\n+\n+        if (rows.length === 0) {\n+          continue;\n+        }\n+\n+        return rows.map(row => ({\n+          id: `visitor_${row.id_visitante}`,\n+          type: 'qr_expirado',\n+          severity: 'baja',\n+          title: 'Visitante pr√≥ximo a expirar',\n+          message: `El QR de ${row.persona_nombre} expirar√° en menos de 1 hora`,\n+          createdAt: row.fecha_inicio,\n           metadata: {\n-            horas_transcurridas: row.horas_transcurridas,\n-            id_visitante: row.id_visitante\n+            id_visitante: row.id_visitante,\n+            id_persona: row.id_persona,\n+            documento: row.documento,\n+            horas_transcurridas: row.horas_transcurridas\n           }\n-        });\n-        // Solo agregar si la alerta se cre√≥ exitosamente (no es null)\n-        if (alertId !== null) {\n-          alertsCreated.push(alertId);\n+        }));\n+      } catch (error) {\n+        if (error.code === 'ER_NO_SUCH_TABLE') {\n+          continue;\n         }\n-      } catch (error) {\n-        console.error(`Error al crear alerta de visitante pr√≥ximo a expirar para ${row.documento}:`, error.message);\n-        // Continuar con el siguiente registro aunque falle uno\n+        console.error(`Error detectando visitantes en ${tableName}:`, error.message);\n+        return [];\n       }\n     }\n \n-    return alertsCreated;\n+    return [];\n   }\n+\n+  static async generateAlerts() {\n+    const [offSchedule, visitors] = await Promise.all([\n+      this.detectOffScheduleAccess(),\n+      this.detectExpiringVisitors()\n+    ]);\n+\n+    const allAlerts = [...offSchedule, ...visitors];\n+    return allAlerts.sort((a, b) => {\n+      const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;\n+      const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;\n+      return dateB - dateA;\n+    });\n+  }\n }\n \n export default AlertService;\n \n"
                },
                {
                    "date": 1764311412093,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -285,8 +285,10 @@\n       porSeveridad: Object.entries(bySeverityMap).map(([severidad, cantidad]) => ({ severidad, cantidad }))\n     };\n   }\n \n+  static resolvedAlertIds = new Set();\n+\n   // Detectar accesos fuera de horario\n   static async detectOffScheduleAccess() {\n     const idColumn = await getRegistroIdField();\n     const fullNameExpr = \"CONCAT(p.nombres, ' ', p.apellidos)\";\n@@ -319,9 +321,9 @@\n       severity: 'media',\n       title: 'Acceso fuera de horario',\n       message: `${row.persona_nombre} (${row.documento}) ingres√≥ fuera del horario permitido a las ${row.hora_acceso}`,\n       createdAt: row.fecha_hora,\n-      metadata: {\n+        metadata: {\n         id_persona: row.id_persona,\n         documento: row.documento,\n         hora_acceso: row.hora_acceso,\n         rol: row.rol || 'sin rol'\n@@ -392,14 +394,24 @@\n       this.detectExpiringVisitors()\n     ]);\n \n     const allAlerts = [...offSchedule, ...visitors];\n-    return allAlerts.sort((a, b) => {\n+    const filtered = allAlerts.filter(alert => !this.isResolved(alert.id));\n+    return filtered.sort((a, b) => {\n       const dateA = a.createdAt ? new Date(a.createdAt).getTime() : 0;\n       const dateB = b.createdAt ? new Date(b.createdAt).getTime() : 0;\n       return dateB - dateA;\n     });\n   }\n+\n+  static markResolved(alertId) {\n+    if (!alertId) return;\n+    this.resolvedAlertIds.add(alertId.toString());\n+  }\n+\n+  static isResolved(alertId) {\n+    return this.resolvedAlertIds.has(alertId?.toString());\n+  }\n }\n \n export default AlertService;\n \n"
                }
            ],
            "date": 1764227753645,
            "name": "Commit-0",
            "content": "// Alert Service - Gesti√≥n de alertas autom√°ticas\nimport pool from '../utils/dbPool.js';\n\nclass AlertService {\n  // Crear una nueva alerta\n  static async createAlert(alertData) {\n    try {\n      const {\n        tipo,\n        severidad = 'media',\n        titulo,\n        mensaje,\n        id_persona = null,\n        id_acceso = null,\n        id_usuario = null,\n        metadata = null\n      } = alertData;\n\n      // Validar campos requeridos\n      if (!tipo || !titulo || !mensaje) {\n        console.error('‚ùå Error al crear alerta: Faltan campos requeridos', { tipo, titulo, mensaje });\n        throw new Error('Faltan campos requeridos para crear la alerta');\n      }\n\n      console.log(`üìù Creando alerta: ${tipo} - ${titulo}`);\n\n      const [result] = await pool.execute(\n        `INSERT INTO Alertas \n         (tipo, severidad, titulo, mensaje, id_persona, id_acceso, id_usuario, metadata)\n         VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n        [\n          tipo,\n          severidad,\n          titulo,\n          mensaje,\n          id_persona,\n          id_acceso,\n          id_usuario,\n          metadata ? JSON.stringify(metadata) : null\n        ]\n      );\n\n      const alertId = result.insertId;\n      console.log(`‚úÖ Alerta creada exitosamente con ID: ${alertId}`);\n      return alertId;\n    } catch (error) {\n      console.error('‚ùå Error al crear alerta:', error.message);\n      console.error('Stack:', error.stack);\n      console.error('Datos de la alerta:', alertData);\n      \n      // Si es un error de tabla no existe, lanzar error espec√≠fico\n      if (error.code === 'ER_NO_SUCH_TABLE') {\n        console.error('‚ö†Ô∏è  La tabla Alertas no existe. Ejecuta el script de inicializaci√≥n de la base de datos.');\n        throw new Error('La tabla Alertas no existe. Ejecuta el script de inicializaci√≥n.');\n      }\n      \n      // Si es un error de foreign key, registrar pero no fallar completamente\n      if (error.code === 'ER_NO_REFERENCED_ROW_2' || error.code === 'ER_ROW_IS_REFERENCED_2') {\n        console.error('‚ö†Ô∏è  Error de foreign key al crear alerta. Continuando sin guardar la alerta.');\n        // Retornar null en lugar de lanzar error para no romper el flujo\n        return null;\n      }\n      \n      // Re-lanzar el error para que el llamador pueda manejarlo\n      throw error;\n    }\n  }\n\n  // Obtener alertas con filtros\n  static async getAlerts(filters = {}) {\n    try {\n      const {\n        tipo = null,\n        severidad = null,\n        leida = null,\n        limit = 50,\n        offset = 0\n      } = filters;\n\n      // Validar y convertir limit y offset a enteros\n      const safeLimit = Math.max(1, Math.min(parseInt(limit) || 50, 1000));\n      const safeOffset = Math.max(0, parseInt(offset) || 0);\n\n      // Primero verificar que la tabla existe\n      try {\n        await pool.execute('SELECT 1 FROM Alertas LIMIT 1');\n      } catch (tableError) {\n        if (tableError.code === 'ER_NO_SUCH_TABLE') {\n          console.warn('‚ö†Ô∏è  Tabla Alertas no existe, retornando array vac√≠o');\n          return [];\n        }\n        // Si es otro error, re-lanzarlo\n        throw tableError;\n      }\n\n      let query = `\n        SELECT \n          a.*,\n          p.nombre as persona_nombre,\n          p.documento,\n          u.nombre as usuario_nombre,\n          u2.nombre as usuario_lectura_nombre\n        FROM Alertas a\n        LEFT JOIN Personas p ON a.id_persona = p.id_persona\n        LEFT JOIN Usuarios u ON a.id_usuario = u.id_usuario\n        LEFT JOIN Usuarios u2 ON a.id_usuario_lectura = u2.id_usuario\n        WHERE 1=1\n      `;\n      const params = [];\n\n      if (tipo) {\n        query += ' AND a.tipo = ?';\n        params.push(tipo);\n      }\n\n      if (severidad) {\n        query += ' AND a.severidad = ?';\n        params.push(severidad);\n      }\n\n      if (leida !== null) {\n        query += ' AND a.leida = ?';\n        params.push(leida ? 1 : 0);\n      }\n\n      // Usar interpolaci√≥n segura para LIMIT y OFFSET ya que est√°n validados\n      query += ` ORDER BY a.fecha_creacion DESC LIMIT ${safeLimit} OFFSET ${safeOffset}`;\n\n      const [rows] = await pool.execute(query, params);\n\n      return rows.map(row => {\n        let metadata = null;\n        if (row.metadata) {\n          try {\n            // Si metadata es string, parsearlo\n            if (typeof row.metadata === 'string') {\n              metadata = JSON.parse(row.metadata);\n            } else {\n              // Si ya es objeto, usarlo directamente\n              metadata = row.metadata;\n            }\n          } catch (error) {\n            console.warn('‚ö†Ô∏è  Error al parsear metadata de alerta:', error.message);\n            metadata = null;\n          }\n        }\n        \n        return {\n          ...row,\n          metadata\n        };\n      });\n    } catch (error) {\n      console.error('‚ùå Error en AlertService.getAlerts:', error.message);\n      console.error('‚ùå C√≥digo de error:', error.code);\n      console.error('‚ùå SQL State:', error.sqlState);\n      console.error('‚ùå Stack:', error.stack);\n      \n      // Si la tabla no existe, retornar array vac√≠o\n      if (error.code === 'ER_NO_SUCH_TABLE' || error.message?.includes('doesn\\'t exist') || error.message?.includes('no existe')) {\n        console.warn('‚ö†Ô∏è  Tabla Alertas no existe, retornando array vac√≠o');\n        return [];\n      }\n\n      // Si hay problemas con tablas relacionadas, intentar consulta sin JOINs\n      if (error.code === 'ER_NO_SUCH_TABLE' || error.message?.includes('Personas') || error.message?.includes('Usuarios')) {\n        console.warn('‚ö†Ô∏è  Problema con tablas relacionadas, intentando consulta simple');\n        try {\n          const [rows] = await pool.execute(\n            `SELECT * FROM Alertas ORDER BY fecha_creacion DESC LIMIT ${Math.max(1, Math.min(parseInt(limit) || 50, 1000))} OFFSET ${Math.max(0, parseInt(offset) || 0)}`\n          );\n          return rows.map(row => ({\n            ...row,\n            metadata: row.metadata ? (typeof row.metadata === 'string' ? JSON.parse(row.metadata) : row.metadata) : null\n          }));\n        } catch (simpleError) {\n          console.error('‚ùå Error en consulta simple:', simpleError.message);\n          return [];\n        }\n      }\n      \n      // Re-lanzar el error para que el llamador pueda manejarlo\n      throw error;\n    }\n  }\n\n  // Marcar alerta como le√≠da\n  static async markAsRead(alertId, userId) {\n    try {\n      // Validar que la tabla existe\n      try {\n        await pool.execute('SELECT 1 FROM Alertas LIMIT 1');\n      } catch (tableError) {\n        if (tableError.code === 'ER_NO_SUCH_TABLE') {\n          console.warn('‚ö†Ô∏è  Tabla Alertas no existe');\n          throw new Error('La tabla Alertas no existe');\n        }\n        throw tableError;\n      }\n\n      // Verificar que la alerta existe\n      const [existing] = await pool.execute(\n        'SELECT id_alerta FROM Alertas WHERE id_alerta = ?',\n        [alertId]\n      );\n\n      if (existing.length === 0) {\n        throw new Error(`Alerta con ID ${alertId} no encontrada`);\n      }\n\n      // Actualizar la alerta\n      const [result] = await pool.execute(\n        `UPDATE Alertas \n         SET leida = TRUE, fecha_lectura = NOW(), id_usuario_lectura = ?\n         WHERE id_alerta = ?`,\n        [userId, alertId]\n      );\n\n      if (result.affectedRows === 0) {\n        throw new Error('No se pudo actualizar la alerta');\n      }\n\n      return result;\n    } catch (error) {\n      console.error('Error en AlertService.markAsRead:', error);\n      throw error;\n    }\n  }\n\n  // Eliminar alerta\n  static async deleteAlert(alertId) {\n    const [result] = await pool.execute(\n      'DELETE FROM Alertas WHERE id_alerta = ?',\n      [alertId]\n    );\n    return result.affectedRows > 0;\n  }\n\n  // Eliminar m√∫ltiples alertas le√≠das\n  static async deleteReadAlerts(daysOld = null) {\n    let query = 'DELETE FROM Alertas WHERE leida = TRUE';\n    const params = [];\n\n    if (daysOld) {\n      query += ' AND fecha_lectura < DATE_SUB(NOW(), INTERVAL ? DAY)';\n      params.push(daysOld);\n    }\n\n    const [result] = await pool.execute(query, params);\n    return result.affectedRows;\n  }\n\n  // Obtener estad√≠sticas de alertas\n  static async getAlertStats() {\n    const [stats] = await pool.execute(`\n      SELECT \n        COUNT(*) as total,\n        SUM(CASE WHEN leida = FALSE THEN 1 ELSE 0 END) as pendientes,\n        SUM(CASE WHEN severidad = 'critica' AND leida = FALSE THEN 1 ELSE 0 END) as criticas_pendientes,\n        SUM(CASE WHEN severidad = 'alta' AND leida = FALSE THEN 1 ELSE 0 END) as altas_pendientes,\n        SUM(CASE WHEN DATE(fecha_creacion) = CURDATE() THEN 1 ELSE 0 END) as hoy\n      FROM Alertas\n    `);\n\n    const [byType] = await pool.execute(`\n      SELECT tipo, COUNT(*) as cantidad\n      FROM Alertas\n      WHERE leida = FALSE\n      GROUP BY tipo\n    `);\n\n    const [bySeverity] = await pool.execute(`\n      SELECT severidad, COUNT(*) as cantidad\n      FROM Alertas\n      WHERE leida = FALSE\n      GROUP BY severidad\n    `);\n\n    return {\n      ...stats[0],\n      porTipo: byType,\n      porSeveridad: bySeverity\n    };\n  }\n\n  // Verificar accesos fuera de horario\n  static async checkOffScheduleAccess() {\n    const [rows] = await pool.execute(`\n      SELECT \n        r.id_registro_entrada_salida as id_acceso,\n        r.fecha_hora,\n        p.id_persona,\n        p.nombre,\n        p.documento,\n        COALESCE(role.nombre_rol, 'sin rol') as rol,\n        TIME(r.fecha_hora) as hora_acceso\n      FROM registros_entrada_salida r\n      INNER JOIN Personas p ON r.id_persona = p.id_persona\n      LEFT JOIN Roles role ON p.id_rol = role.id_rol\n      WHERE DATE(r.fecha_hora) = CURDATE()\n      AND (HOUR(r.fecha_hora) < 6 OR HOUR(r.fecha_hora) > 22)\n      AND r.tipo = 'ENTRADA'\n      AND NOT EXISTS (\n        SELECT 1 FROM Alertas al \n        WHERE al.id_acceso = r.id_registro_entrada_salida\n        AND al.tipo = 'acceso_fuera_horario'\n      )\n    `);\n\n    const alertsCreated = [];\n    for (const row of rows) {\n      try {\n        const alertId = await this.createAlert({\n          tipo: 'acceso_fuera_horario',\n          severidad: 'media',\n          titulo: 'Acceso fuera de horario',\n          mensaje: `${row.nombre} (${row.documento}) ingres√≥ fuera del horario permitido a las ${row.hora_acceso}`,\n          id_persona: row.id_persona,\n          id_acceso: row.id_acceso,\n          metadata: {\n            hora_acceso: row.hora_acceso,\n            rol: row.rol\n          }\n        });\n        // Solo agregar si la alerta se cre√≥ exitosamente (no es null)\n        if (alertId !== null) {\n          alertsCreated.push(alertId);\n        }\n      } catch (error) {\n        console.error(`Error al crear alerta de acceso fuera de horario para ${row.documento}:`, error.message);\n        // Continuar con el siguiente registro aunque falle uno\n      }\n    }\n\n    return alertsCreated;\n  }\n\n  // Verificar visitantes pr√≥ximos a expirar\n  static async checkExpiringVisitors() {\n    const [rows] = await pool.execute(`\n      SELECT \n        v.id_visitante,\n        v.fecha_inicio,\n        p.id_persona,\n        p.nombre,\n        p.documento,\n        TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) as horas_transcurridas\n      FROM Visitantes v\n      INNER JOIN Personas p ON v.id_persona = p.id_persona\n      WHERE v.estado = 'activo'\n      AND v.fecha_fin IS NULL\n      AND TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) >= 23\n      AND TIMESTAMPDIFF(HOUR, v.fecha_inicio, NOW()) < 24\n      AND NOT EXISTS (\n        SELECT 1 FROM Alertas al \n        WHERE al.id_persona = p.id_persona \n        AND al.tipo = 'qr_expirado'\n        AND DATE(al.fecha_creacion) = CURDATE()\n      )\n    `);\n\n    const alertsCreated = [];\n    for (const row of rows) {\n      try {\n        const alertId = await this.createAlert({\n          tipo: 'qr_expirado',\n          severidad: 'baja',\n          titulo: 'Visitante pr√≥ximo a expirar',\n          mensaje: `El QR de ${row.nombre} expirar√° en menos de 1 hora`,\n          id_persona: row.id_persona,\n          metadata: {\n            horas_transcurridas: row.horas_transcurridas,\n            id_visitante: row.id_visitante\n          }\n        });\n        // Solo agregar si la alerta se cre√≥ exitosamente (no es null)\n        if (alertId !== null) {\n          alertsCreated.push(alertId);\n        }\n      } catch (error) {\n        console.error(`Error al crear alerta de visitante pr√≥ximo a expirar para ${row.documento}:`, error.message);\n        // Continuar con el siguiente registro aunque falle uno\n      }\n    }\n\n    return alertsCreated;\n  }\n}\n\nexport default AlertService;\n\n\n\n\n\n\n\n\n\n\n"
        }
    ]
}