{
    "sourceFile": "control-acceso-sena/backend/src/services/BatchProcessor.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1764229660147,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764229833525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -216,30 +216,8 @@\n         const codigoFicha = row.ficha?.toString().trim() || null;\n         const programaFormacion = row.programa_formacion?.toString().trim() || null;\n         const jornada = row.jornada?.toLowerCase().trim() || null;\n         \n-        // Buscar id_programa si se proporciona el nombre del programa\n-        let idPrograma = null;\n-        if (rol === 'aprendiz' && programaFormacion) {\n-          try {\n-            // Buscar por nombre exacto primero\n-            const [programas] = await pool.execute(\n-              `SELECT id_programa FROM Programas_Formacion \n-               WHERE nombre_programa = ? OR nombre_programa LIKE ?`,\n-              [programaFormacion, `%${programaFormacion}%`]\n-            );\n-            \n-            if (programas.length > 0) {\n-              idPrograma = programas[0].id_programa;\n-              console.log(`✅ Programa encontrado: ${programaFormacion} -> id_programa: ${idPrograma}`);\n-            } else {\n-              console.warn(`⚠️  Programa no encontrado: ${programaFormacion}`);\n-            }\n-          } catch (error) {\n-            console.warn(`Error buscando programa ${programaFormacion}:`, error.message);\n-          }\n-        }\n-        \n         // Variables para fechas que vendrán de la tabla Fichas\n         let fechaInicioDesdeFicha = null;\n         let fechaFinDesdeFicha = null;\n         \n@@ -247,9 +225,9 @@\n         let idFicha = null;\n         if (rol === 'aprendiz' && codigoFicha) {\n           // Buscar ficha existente (con fechas)\n           const [fichas] = await pool.execute(\n-            'SELECT id_ficha, fecha_inicio, fecha_fin FROM Fichas WHERE codigo_ficha = ?',\n+            'SELECT id_ficha, fecha_inicio, fecha_fin FROM fichas WHERE codigo_ficha = ?',\n             [codigoFicha]\n           );\n           \n           if (fichas.length > 0) {\n@@ -291,9 +269,9 @@\n           } else if (programaFormacion) {\n             // Crear nueva ficha con las fechas del Excel\n             try {\n               const [resultFicha] = await pool.execute(\n-                `INSERT INTO Fichas (codigo_ficha, programa_formacion, jornada, fecha_inicio, fecha_fin, estado)\n+                `INSERT INTO fichas (codigo_ficha, programa_formacion, jornada, fecha_inicio, fecha_fin, estado)\n                  VALUES (?, ?, ?, ?, ?, 'activa')`,\n                 [codigoFicha, programaFormacion, jornada || 'diurna', fechaInicioFormacion, fechaFinFormacion]\n               );\n               idFicha = resultFicha.insertId;\n@@ -318,9 +296,8 @@\n            SET nombres = ?, apellidos = ?, estado = ?, id_rol = ?, \n                email = COALESCE(?, email), telefono = COALESCE(?, telefono),\n                rh = COALESCE(?, rh),\n                id_ficha = COALESCE(?, id_ficha),\n-               id_programa = COALESCE(?, id_programa),\n                fecha_inicio_formacion = ?,\n                fecha_fin_formacion = ?,\n                jornada = COALESCE(?, jornada),\n                cargo = COALESCE(?, cargo),\n@@ -335,9 +312,8 @@\n             row.email?.toString().trim() || null,\n             row.telefono?.toString().trim() || null,\n             rh,\n             idFicha,\n-            idPrograma,\n             fechaInicioFinal,\n             fechaFinFinal,\n             jornada,\n             cargo,\n@@ -354,10 +330,10 @@\n           // La persona NO existe, insertar nueva\n         const [result] = await pool.execute(\n           `INSERT INTO Personas \n            (id_rol, tipo_documento, documento, nombres, apellidos, estado, email, telefono, foto, \n-            rh, id_ficha, id_programa, fecha_inicio_formacion, fecha_fin_formacion, jornada, cargo, tipo_contrato, fecha_registro)\n-           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,\n+            rh, id_ficha, fecha_inicio_formacion, fecha_fin_formacion, jornada, cargo, tipo_contrato, fecha_registro)\n+           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,\n           [\n             idRol || null,\n             tipoDocumento,\n             documento,\n@@ -368,9 +344,8 @@\n             row.telefono?.toString().trim() || null,\n             null,  // foto\n             rh,\n             idFicha,\n-            idPrograma,\n             fechaInicioFinal,\n             fechaFinFinal,\n             jornada,\n             cargo,\n"
                },
                {
                    "date": 1764229987956,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,16 +249,8 @@\n                     `UPDATE Fichas SET fecha_inicio = ?, fecha_fin = ? WHERE id_ficha = ?`,\n                     [fechaInicioFormacion, fechaFinFormacion, idFicha]\n                   );\n                   \n-                  // Actualizar fechas de todas las personas de esta ficha para mantener consistencia\n-                  await pool.execute(\n-                    `UPDATE Personas \n-                     SET fecha_inicio_formacion = ?, fecha_fin_formacion = ?\n-                     WHERE id_ficha = ?`,\n-                    [fechaInicioFormacion, fechaFinFormacion, idFicha]\n-                  );\n-                  \n                   fechaInicioDesdeFicha = fechaInicioFormacion;\n                   fechaFinDesdeFicha = fechaFinFormacion;\n                   console.log(`✅ Fechas actualizadas para ficha ${codigoFicha} y todas sus personas`);\n                 } catch (error) {\n@@ -283,76 +275,64 @@\n           }\n         }\n         \n         // Usar fechas de la ficha si están disponibles, sino usar las del Excel\n-        const fechaInicioFinal = fechaInicioDesdeFicha || fechaInicioFormacion;\n-        const fechaFinFinal = fechaFinDesdeFicha || fechaFinFormacion;\n-\n         if (existing.length > 0) {\n           // La persona ya existe, actualizar en lugar de insertar\n           const personaExistente = existing[0];\n           \n-        await pool.execute(\n-          `UPDATE Personas \n-           SET nombres = ?, apellidos = ?, estado = ?, id_rol = ?, \n-               email = COALESCE(?, email), telefono = COALESCE(?, telefono),\n-               rh = COALESCE(?, rh),\n-               id_ficha = COALESCE(?, id_ficha),\n-               fecha_inicio_formacion = ?,\n-               fecha_fin_formacion = ?,\n-               jornada = COALESCE(?, jornada),\n-               cargo = COALESCE(?, cargo),\n-               tipo_contrato = COALESCE(?, tipo_contrato),\n-               fecha_actualizacion = NOW()\n-           WHERE documento = ? AND tipo_documento = ?`,\n-          [\n-            nombresValue,\n-            apellidosValue,\n-            estadoFinal,\n-            idRol || null,\n-            row.email?.toString().trim() || null,\n-            row.telefono?.toString().trim() || null,\n-            rh,\n-            idFicha,\n-            fechaInicioFinal,\n-            fechaFinFinal,\n-            jornada,\n-            cargo,\n-            tipoContrato,\n-            documento,\n-            tipoDocumento\n-          ]\n-        );\n+          await pool.execute(\n+            `UPDATE Personas \n+             SET nombres = ?, apellidos = ?, estado = ?, id_rol = ?, \n+                 email = COALESCE(?, email), telefono = COALESCE(?, telefono),\n+                 rh = COALESCE(?, rh),\n+                 id_ficha = COALESCE(?, id_ficha),\n+                 cargo = COALESCE(?, cargo),\n+                 tipo_contrato = COALESCE(?, tipo_contrato),\n+                 fecha_actualizacion = NOW()\n+             WHERE documento = ? AND tipo_documento = ?`,\n+            [\n+              nombresValue,\n+              apellidosValue,\n+              estadoFinal,\n+              idRol || null,\n+              row.email?.toString().trim() || null,\n+              row.telefono?.toString().trim() || null,\n+              rh,\n+              idFicha,\n+              cargo,\n+              tipoContrato,\n+              documento,\n+              tipoDocumento\n+            ]\n+          );\n           \n           await this.processRoleSpecificData(personaExistente.id_persona, row, rol);\n           insertedIds.push(personaExistente.id_persona);\n           successful++;\n         } else {\n           // La persona NO existe, insertar nueva\n-        const [result] = await pool.execute(\n-          `INSERT INTO Personas \n-           (id_rol, tipo_documento, documento, nombres, apellidos, estado, email, telefono, foto, \n-            rh, id_ficha, fecha_inicio_formacion, fecha_fin_formacion, jornada, cargo, tipo_contrato, fecha_registro)\n-           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,\n-          [\n-            idRol || null,\n-            tipoDocumento,\n-            documento,\n-            nombresValue,\n-            apellidosValue,\n-            estadoFinal,\n-            row.email?.toString().trim() || null,\n-            row.telefono?.toString().trim() || null,\n-            null,  // foto\n-            rh,\n-            idFicha,\n-            fechaInicioFinal,\n-            fechaFinFinal,\n-            jornada,\n-            cargo,\n-            tipoContrato\n-          ]\n-        );\n+          const [result] = await pool.execute(\n+            `INSERT INTO Personas \n+             (id_rol, tipo_documento, documento, nombres, apellidos, estado, email, telefono, foto, \n+              rh, id_ficha, cargo, tipo_contrato, fecha_registro)\n+             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,\n+            [\n+              idRol || null,\n+              tipoDocumento,\n+              documento,\n+              nombresValue,\n+              apellidosValue,\n+              estadoFinal,\n+              row.email?.toString().trim() || null,\n+              row.telefono?.toString().trim() || null,\n+              null,  // foto\n+              rh,\n+              idFicha,\n+              cargo,\n+              tipoContrato\n+            ]\n+          );\n \n           await this.processRoleSpecificData(result.insertId, row, rol);\n           insertedIds.push(result.insertId);\n           successful++;\n"
                },
                {
                    "date": 1764307505454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -213,67 +213,30 @@\n         const tipoContrato = row.tipo_contrato?.toLowerCase().trim() || null;\n         \n         // Preparar campos de ficha y programa\n         const codigoFicha = row.ficha?.toString().trim() || null;\n-        const programaFormacion = row.programa_formacion?.toString().trim() || null;\n-        const jornada = row.jornada?.toLowerCase().trim() || null;\n-        \n-        // Variables para fechas que vendrán de la tabla Fichas\n-        let fechaInicioDesdeFicha = null;\n-        let fechaFinDesdeFicha = null;\n-        \n-        // Buscar o crear ficha si es aprendiz y tiene código de ficha\n+        const codigoPrograma = row.codigo_programa?.toString().trim() || row.programa_formacion?.toString().trim() || null;\n+        const nombrePrograma = row.nombre_programa?.toString().trim() || codigoPrograma;\n+        const nivelPrograma = this.normalizeNivel(row.nivel?.toString().trim() || row.nivel_programa?.toString().trim());\n+        const jornadaFicha = this.normalizeJornada(row.jornada?.toString().trim());\n+        const estadoFicha = this.normalizeFichaEstado(row.estado_ficha || row.estado);\n+        const numeroAprendices = Number(row.numero_aprendices) || null;\n+        const capacidadMaxima = Number(row.capacidad_maxima) || null;\n+        const estadoFichaFinal = estadoFicha || 'activa';\n+\n+        const idPrograma = await this.ensureProgramRecord(codigoPrograma, nombrePrograma, nivelPrograma);\n         let idFicha = null;\n-        if (rol === 'aprendiz' && codigoFicha) {\n-          // Buscar ficha existente (con fechas)\n-          const [fichas] = await pool.execute(\n-            'SELECT id_ficha, fecha_inicio, fecha_fin FROM fichas WHERE codigo_ficha = ?',\n-            [codigoFicha]\n-          );\n-          \n-          if (fichas.length > 0) {\n-            // Ficha existe: usar las fechas de la ficha\n-            idFicha = fichas[0].id_ficha;\n-            fechaInicioDesdeFicha = fichas[0].fecha_inicio;\n-            fechaFinDesdeFicha = fichas[0].fecha_fin;\n-            \n-            // Si la ficha no tiene fechas pero las tenemos en el Excel, actualizar la ficha\n-            // O si las fechas del Excel son diferentes y válidas, actualizar la ficha\n-            if (fechaInicioFormacion && fechaFinFormacion) {\n-              const necesitaActualizar = !fechaInicioDesdeFicha || \n-                                        fechaInicioDesdeFicha.toString() !== fechaInicioFormacion ||\n-                                        fechaFinDesdeFicha?.toString() !== fechaFinFormacion;\n-              \n-              if (necesitaActualizar) {\n-                try {\n-                  await pool.execute(\n-                    `UPDATE Fichas SET fecha_inicio = ?, fecha_fin = ? WHERE id_ficha = ?`,\n-                    [fechaInicioFormacion, fechaFinFormacion, idFicha]\n-                  );\n-                  \n-                  fechaInicioDesdeFicha = fechaInicioFormacion;\n-                  fechaFinDesdeFicha = fechaFinFormacion;\n-                  console.log(`✅ Fechas actualizadas para ficha ${codigoFicha} y todas sus personas`);\n-                } catch (error) {\n-                  console.warn(`Error actualizando fechas de ficha ${codigoFicha}:`, error.message);\n-                }\n-              }\n-            }\n-          } else if (programaFormacion) {\n-            // Crear nueva ficha con las fechas del Excel\n-            try {\n-              const [resultFicha] = await pool.execute(\n-                `INSERT INTO fichas (codigo_ficha, programa_formacion, jornada, fecha_inicio, fecha_fin, estado)\n-                 VALUES (?, ?, ?, ?, ?, 'activa')`,\n-                [codigoFicha, programaFormacion, jornada || 'diurna', fechaInicioFormacion, fechaFinFormacion]\n-              );\n-              idFicha = resultFicha.insertId;\n-              fechaInicioDesdeFicha = fechaInicioFormacion;\n-              fechaFinDesdeFicha = fechaFinFormacion;\n-            } catch (error) {\n-              console.warn(`Error creando ficha ${codigoFicha}:`, error.message);\n-            }\n-          }\n+        if (rol === 'aprendiz' && codigoFicha && idPrograma) {\n+          idFicha = await this.ensureFichaRecord({\n+            codigoFicha,\n+            idPrograma,\n+            jornada: jornadaFicha,\n+            fechaInicio: fechaInicioFormacion,\n+            fechaFin: fechaFinFormacion,\n+            estado: estadoFichaFinal,\n+            numeroAprendices,\n+            capacidadMaxima\n+          });\n         }\n         \n         // Usar fechas de la ficha si están disponibles, sino usar las del Excel\n         if (existing.length > 0) {\n@@ -452,6 +415,105 @@\n       console.error(`Error procesando datos específicos de rol para persona ${personId}:`, error);\n       // No fallar la importación completa por esto\n     }\n   }\n+\n+  normalizeNivel(value) {\n+    if (!value) return 'Técnico';\n+    const normalized = value.trim();\n+    const allowed = ['Técnico', 'Tecnológico', 'Especialización', 'Complementaria'];\n+    if (allowed.includes(normalized)) {\n+      return normalized;\n+    }\n+    const lower = normalized.toLowerCase();\n+    if (lower.includes('tecnol')) return 'Tecnológico';\n+    if (lower.includes('especializ')) return 'Especialización';\n+    if (lower.includes('complement')) return 'Complementaria';\n+    return 'Técnico';\n+  }\n+\n+  normalizeJornada(value) {\n+    const jornada = (value || 'diurna').toString().toLowerCase().trim();\n+    if (['diurna', 'nocturna', 'mixta'].includes(jornada)) {\n+      return jornada;\n+    }\n+    if (jornada.includes('noci')) return 'nocturna';\n+    if (jornada.includes('mix')) return 'mixta';\n+    return 'diurna';\n+  }\n+\n+  normalizeFichaEstado(value) {\n+    const estado = (value || 'activa').toString().toLowerCase().trim();\n+    const allowed = ['activa', 'finalizada', 'cancelada'];\n+    return allowed.includes(estado) ? estado : 'activa';\n+  }\n+\n+  async ensureProgramRecord(codigoPrograma, nombrePrograma, nivelPrograma) {\n+    if (!codigoPrograma) {\n+      return null;\n+    }\n+    const code = codigoPrograma.trim();\n+    const [existing] = await pool.execute(\n+      'SELECT id_programa FROM programas_formacion WHERE codigo_programa = ? LIMIT 1',\n+      [code]\n+    );\n+    if (existing.length > 0) {\n+      return existing[0].id_programa;\n+    }\n+\n+    const [result] = await pool.execute(\n+      `INSERT INTO programas_formacion (codigo_programa, nombre_programa, nivel, estado)\n+       VALUES (?, ?, ?, 'activo')`,\n+      [code, nombrePrograma || code, nivelPrograma || 'Técnico']\n+    );\n+    return result.insertId;\n+  }\n+\n+  async ensureFichaRecord({\n+    codigoFicha,\n+    idPrograma,\n+    jornada,\n+    fechaInicio,\n+    fechaFin,\n+    estado,\n+    numeroAprendices,\n+    capacidadMaxima\n+  }) {\n+    if (!codigoFicha || !idPrograma) {\n+      return null;\n+    }\n+    const [existing] = await pool.execute(\n+      'SELECT id_ficha FROM fichas WHERE codigo_ficha = ? LIMIT 1',\n+      [codigoFicha]\n+    );\n+    if (existing.length > 0) {\n+      await pool.execute(\n+        `UPDATE fichas\n+         SET id_programa = ?, jornada = ?, fecha_inicio = COALESCE(?, fecha_inicio),\n+             fecha_fin = COALESCE(?, fecha_fin), estado = ?, numero_aprendices = COALESCE(?, numero_aprendices),\n+             capacidad_maxima = COALESCE(?, capacidad_maxima), fecha_actualizacion = NOW()\n+         WHERE id_ficha = ?`,\n+        [idPrograma, jornada, fechaInicio, fechaFin, estado, numeroAprendices, capacidadMaxima, existing[0].id_ficha]\n+      );\n+      return existing[0].id_ficha;\n+    }\n+\n+    const [result] = await pool.execute(\n+      `INSERT INTO fichas \n+       (codigo_ficha, id_programa, jornada, fecha_inicio, fecha_fin, estado, numero_aprendices, capacidad_maxima)\n+       VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,\n+      [\n+        codigoFicha,\n+        idPrograma,\n+        jornada,\n+        fechaInicio,\n+        fechaFin,\n+        estado,\n+        numeroAprendices ?? 0,\n+        capacidadMaxima ?? null\n+      ]\n+    );\n+\n+    return result.insertId;\n+  }\n }\n \n"
                },
                {
                    "date": 1764308089157,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -249,10 +249,9 @@\n                  email = COALESCE(?, email), telefono = COALESCE(?, telefono),\n                  rh = COALESCE(?, rh),\n                  id_ficha = COALESCE(?, id_ficha),\n                  cargo = COALESCE(?, cargo),\n-                 tipo_contrato = COALESCE(?, tipo_contrato),\n-                 fecha_actualizacion = NOW()\n+                 tipo_contrato = COALESCE(?, tipo_contrato)\n              WHERE documento = ? AND tipo_documento = ?`,\n             [\n               nombresValue,\n               apellidosValue,\n@@ -489,9 +488,9 @@\n       await pool.execute(\n         `UPDATE fichas\n          SET id_programa = ?, jornada = ?, fecha_inicio = COALESCE(?, fecha_inicio),\n              fecha_fin = COALESCE(?, fecha_fin), estado = ?, numero_aprendices = COALESCE(?, numero_aprendices),\n-             capacidad_maxima = COALESCE(?, capacidad_maxima), fecha_actualizacion = NOW()\n+             capacidad_maxima = COALESCE(?, capacidad_maxima)\n          WHERE id_ficha = ?`,\n         [idPrograma, jornada, fechaInicio, fechaFin, estado, numeroAprendices, capacidadMaxima, existing[0].id_ficha]\n       );\n       return existing[0].id_ficha;\n"
                },
                {
                    "date": 1764317890992,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,11 +1,13 @@\n // Batch Processor - Procesador por lotes para importación masiva\n import pool from '../utils/dbPool.js';\n import { validateBatch } from '../utils/dataValidator.js';\n+import LogService from './LogService.js';\n \n export class BatchProcessor {\n-  constructor(batchSize = 50) {\n+  constructor(batchSize = 50, userId = null) {\n     this.batchSize = batchSize;\n+    this.userId = userId;\n     this.processed = 0;\n     this.total = 0;\n     this.successful = 0;\n     this.failed = 0;\n@@ -50,8 +52,43 @@\n       \n       this.emitProgress();\n     }\n \n+    // Registrar importación en auditoría\n+    try {\n+      await LogService.auditoria(\n+        'Personas',\n+        null,\n+        'INSERT',\n+        null,\n+        {\n+          tipo: 'importacion_masiva',\n+          total_filas: this.total,\n+          exitosos: this.successful,\n+          fallidos: this.failed,\n+          errores_count: this.errors.length\n+        },\n+        this.userId || null,\n+        null\n+      );\n+\n+      // Registrar en logs de seguridad\n+      await LogService.logSeguridad(\n+        'acceso_sistema',\n+        this.userId || null,\n+        `Importación masiva completada: ${this.successful} exitosos, ${this.failed} fallidos de ${this.total} registros`,\n+        {\n+          total: this.total,\n+          exitosos: this.successful,\n+          fallidos: this.failed,\n+          tabla: 'Personas'\n+        },\n+        null\n+      );\n+    } catch (logError) {\n+      console.error('Error registrando importación en auditoría:', logError.message);\n+    }\n+\n     return {\n       total: this.total,\n       processed: this.processed,\n       successful: this.successful,\n"
                }
            ],
            "date": 1764229660147,
            "name": "Commit-0",
            "content": "// Batch Processor - Procesador por lotes para importación masiva\nimport pool from '../utils/dbPool.js';\nimport { validateBatch } from '../utils/dataValidator.js';\n\nexport class BatchProcessor {\n  constructor(batchSize = 50) {\n    this.batchSize = batchSize;\n    this.processed = 0;\n    this.total = 0;\n    this.successful = 0;\n    this.failed = 0;\n    this.errors = [];\n    this.warnings = [];\n    this.progressCallbacks = [];\n  }\n\n  onProgress(callback) {\n    this.progressCallbacks.push(callback);\n  }\n\n  emitProgress() {\n    const progress = {\n      processed: this.processed,\n      total: this.total,\n      successful: this.successful,\n      failed: this.failed,\n      percentage: Math.round((this.processed / this.total) * 100)\n    };\n    \n    this.progressCallbacks.forEach(callback => callback(progress));\n  }\n\n  async processFile(rows, fieldMapping) {\n    this.total = rows.length;\n    this.processed = 0;\n    this.successful = 0;\n    this.failed = 0;\n    this.errors = [];\n    this.warnings = [];\n\n    for (let i = 0; i < rows.length; i += this.batchSize) {\n      const batch = rows.slice(i, i + this.batchSize);\n      const result = await this.processBatch(batch, fieldMapping, i);\n      \n      this.processed += batch.length;\n      this.successful += result.successful;\n      this.failed += result.failed;\n      this.errors.push(...result.errors);\n      this.warnings.push(...result.warnings);\n      \n      this.emitProgress();\n    }\n\n    return {\n      total: this.total,\n      processed: this.processed,\n      successful: this.successful,\n      failed: this.failed,\n      errors: this.errors,\n      warnings: this.warnings\n    };\n  }\n\n  async processBatch(batch, fieldMapping, startIndex) {\n    // Validar lote\n    const validationResults = await validateBatch(batch, fieldMapping, startIndex);\n    \n    let successful = 0;\n    let failed = validationResults.invalidCount;\n    const errors = [...validationResults.errors];\n    const warnings = [...validationResults.warnings];\n\n    // Procesar filas válidas\n    if (validationResults.validRows.length > 0) {\n      try {\n        const insertResult = await this.insertBatch(validationResults.validRows, startIndex);\n        successful = insertResult.successful;\n        failed += insertResult.failed;\n        errors.push(...insertResult.errors);\n      } catch (error) {\n        console.error('Error insertando lote:', error);\n        failed += validationResults.validRows.length;\n        errors.push({\n          row: startIndex + 1,\n          message: `Error al insertar lote: ${error.message}`,\n          field: 'batch',\n          batch: true\n        });\n      }\n    }\n\n    return {\n      successful,\n      failed,\n      errors,\n      warnings\n    };\n  }\n\n  async insertBatch(rows, startIndex = 0) {\n    if (rows.length === 0) {\n      return { successful: 0, failed: 0, errors: [] };\n    }\n\n    // Obtener IDs de roles por defecto\n    const [roles] = await pool.execute('SELECT id_rol, nombre_rol FROM Roles');\n    const roleMap = {};\n    roles.forEach(r => {\n      roleMap[r.nombre_rol.toLowerCase()] = r.id_rol;\n    });\n\n    // Insertar una por una para manejar errores individuales\n    const insertedIds = [];\n    const errors = [];\n    let successful = 0;\n    let failed = 0;\n    \n    for (let i = 0; i < rows.length; i++) {\n      const row = rows[i];\n      const rowIndex = startIndex + i;\n      \n      try {\n        const rol = row.rol?.toLowerCase() || 'aprendiz';\n        const idRol = roleMap[rol] || roleMap['aprendiz'];\n        const nombreCompleto = `${row.nombres?.toString().trim() || ''} ${row.apellidos?.toString().trim() || ''}`.trim();\n        const nameParts = nombreCompleto.split(' ').filter(Boolean);\n        const nombresValue = row.nombres?.toString().trim() || nameParts.slice(0, -1).join(' ') || nombreCompleto;\n        const apellidosValue = row.apellidos?.toString().trim() || (nameParts.length > 1 ? nameParts.slice(-1).join(' ') : '');\n        \n        if (!nombreCompleto) {\n          throw new Error('Nombre completo no puede estar vacío');\n        }\n        \n        const documento = row.documento?.toString().trim() || '';\n        const tipoDocumento = (row.tipo_documento?.toUpperCase() || 'CC').trim();\n        \n        // VERIFICAR SI LA PERSONA YA EXISTE antes de insertar\n        const [existing] = await pool.execute(\n          `SELECT id_persona, estado FROM Personas \n           WHERE documento = ? AND tipo_documento = ?`,\n          [documento, tipoDocumento]\n        );\n        \n        // Preparar campos adicionales\n        const estado = row.estado?.toLowerCase().trim() || 'activo';\n        const validEstados = ['activo', 'inactivo', 'suspendido'];\n        const estadoFinal = validEstados.includes(estado) ? estado : 'activo';\n        \n        // Campos nuevos\n        const rh = row.rh?.toString().trim().toUpperCase() || null;\n        \n        // Procesar fechas: convertir cadenas vacías a null y validar fechas\n        // También maneja números seriales de Excel (ej: 45367 = fecha en Excel)\n        const procesarFecha = (fecha) => {\n          if (!fecha) return null;\n          \n          const fechaStr = fecha.toString().trim();\n          if (fechaStr === '' || fechaStr === 'null' || fechaStr === 'NULL') return null;\n          \n          // Detectar si es un número serial de Excel (números entre 1 y 100000)\n          // Los números seriales de Excel son enteros o decimales sin formato de fecha\n          const numFecha = parseFloat(fechaStr);\n          const isNumeric = !isNaN(numFecha) && isFinite(numFecha) && fechaStr.match(/^\\d+(\\.\\d+)?$/);\n          \n          if (isNumeric && numFecha >= 1 && numFecha <= 100000) {\n            // Es un número serial de Excel\n            // Convertir serial de Excel a fecha JavaScript\n            // Excel cuenta desde 1900-01-01 como día 1\n            // Fórmula: fecha = 1900-01-01 + (serial - 1) días\n            // Pero Excel tiene un bug: trata 1900 como año bisiesto (no lo es)\n            // Para números >= 60 (después de 29 de febrero de 1900), restamos 1 día\n            const excelEpoch = new Date(1900, 0, 1); // 1 de enero de 1900\n            const daysToAdd = numFecha >= 60 ? numFecha - 2 : numFecha - 1; // Compensar bug de Excel\n            const fechaDate = new Date(excelEpoch.getTime() + daysToAdd * 24 * 60 * 60 * 1000);\n            \n            // Validar que sea una fecha razonable (entre 1900 y 2100)\n            const year = fechaDate.getFullYear();\n            if (year >= 1900 && year <= 2100) {\n              const month = String(fechaDate.getMonth() + 1).padStart(2, '0');\n              const day = String(fechaDate.getDate()).padStart(2, '0');\n              return `${year}-${month}-${day}`;\n            } else {\n              console.warn(`Año fuera de rango (${year}) para serial Excel ${numFecha}, se usará null`);\n              return null;\n            }\n          }\n          \n          // Intentar parsear como fecha normal (texto con formato de fecha)\n          const fechaDate = new Date(fechaStr);\n          \n          // Verificar que sea una fecha válida\n          if (isNaN(fechaDate.getTime())) {\n            console.warn(`Fecha inválida: \"${fechaStr}\", se usará null`);\n            return null;\n          }\n          \n          // Validar que sea una fecha razonable\n          const year = fechaDate.getFullYear();\n          if (year < 1900 || year > 2100) {\n            console.warn(`Año fuera de rango (${year}) para fecha \"${fechaStr}\", se usará null`);\n            return null;\n          }\n          \n          // Retornar en formato YYYY-MM-DD para MySQL\n          const month = String(fechaDate.getMonth() + 1).padStart(2, '0');\n          const day = String(fechaDate.getDate()).padStart(2, '0');\n          return `${year}-${month}-${day}`;\n        };\n        \n        const fechaInicioFormacion = procesarFecha(row.fecha_inicio_formacion);\n        const fechaFinFormacion = procesarFecha(row.fecha_fin_formacion);\n        const cargo = row.cargo?.toString().trim() || null;\n        const tipoContrato = row.tipo_contrato?.toLowerCase().trim() || null;\n        \n        // Preparar campos de ficha y programa\n        const codigoFicha = row.ficha?.toString().trim() || null;\n        const programaFormacion = row.programa_formacion?.toString().trim() || null;\n        const jornada = row.jornada?.toLowerCase().trim() || null;\n        \n        // Buscar id_programa si se proporciona el nombre del programa\n        let idPrograma = null;\n        if (rol === 'aprendiz' && programaFormacion) {\n          try {\n            // Buscar por nombre exacto primero\n            const [programas] = await pool.execute(\n              `SELECT id_programa FROM Programas_Formacion \n               WHERE nombre_programa = ? OR nombre_programa LIKE ?`,\n              [programaFormacion, `%${programaFormacion}%`]\n            );\n            \n            if (programas.length > 0) {\n              idPrograma = programas[0].id_programa;\n              console.log(`✅ Programa encontrado: ${programaFormacion} -> id_programa: ${idPrograma}`);\n            } else {\n              console.warn(`⚠️  Programa no encontrado: ${programaFormacion}`);\n            }\n          } catch (error) {\n            console.warn(`Error buscando programa ${programaFormacion}:`, error.message);\n          }\n        }\n        \n        // Variables para fechas que vendrán de la tabla Fichas\n        let fechaInicioDesdeFicha = null;\n        let fechaFinDesdeFicha = null;\n        \n        // Buscar o crear ficha si es aprendiz y tiene código de ficha\n        let idFicha = null;\n        if (rol === 'aprendiz' && codigoFicha) {\n          // Buscar ficha existente (con fechas)\n          const [fichas] = await pool.execute(\n            'SELECT id_ficha, fecha_inicio, fecha_fin FROM Fichas WHERE codigo_ficha = ?',\n            [codigoFicha]\n          );\n          \n          if (fichas.length > 0) {\n            // Ficha existe: usar las fechas de la ficha\n            idFicha = fichas[0].id_ficha;\n            fechaInicioDesdeFicha = fichas[0].fecha_inicio;\n            fechaFinDesdeFicha = fichas[0].fecha_fin;\n            \n            // Si la ficha no tiene fechas pero las tenemos en el Excel, actualizar la ficha\n            // O si las fechas del Excel son diferentes y válidas, actualizar la ficha\n            if (fechaInicioFormacion && fechaFinFormacion) {\n              const necesitaActualizar = !fechaInicioDesdeFicha || \n                                        fechaInicioDesdeFicha.toString() !== fechaInicioFormacion ||\n                                        fechaFinDesdeFicha?.toString() !== fechaFinFormacion;\n              \n              if (necesitaActualizar) {\n                try {\n                  await pool.execute(\n                    `UPDATE Fichas SET fecha_inicio = ?, fecha_fin = ? WHERE id_ficha = ?`,\n                    [fechaInicioFormacion, fechaFinFormacion, idFicha]\n                  );\n                  \n                  // Actualizar fechas de todas las personas de esta ficha para mantener consistencia\n                  await pool.execute(\n                    `UPDATE Personas \n                     SET fecha_inicio_formacion = ?, fecha_fin_formacion = ?\n                     WHERE id_ficha = ?`,\n                    [fechaInicioFormacion, fechaFinFormacion, idFicha]\n                  );\n                  \n                  fechaInicioDesdeFicha = fechaInicioFormacion;\n                  fechaFinDesdeFicha = fechaFinFormacion;\n                  console.log(`✅ Fechas actualizadas para ficha ${codigoFicha} y todas sus personas`);\n                } catch (error) {\n                  console.warn(`Error actualizando fechas de ficha ${codigoFicha}:`, error.message);\n                }\n              }\n            }\n          } else if (programaFormacion) {\n            // Crear nueva ficha con las fechas del Excel\n            try {\n              const [resultFicha] = await pool.execute(\n                `INSERT INTO Fichas (codigo_ficha, programa_formacion, jornada, fecha_inicio, fecha_fin, estado)\n                 VALUES (?, ?, ?, ?, ?, 'activa')`,\n                [codigoFicha, programaFormacion, jornada || 'diurna', fechaInicioFormacion, fechaFinFormacion]\n              );\n              idFicha = resultFicha.insertId;\n              fechaInicioDesdeFicha = fechaInicioFormacion;\n              fechaFinDesdeFicha = fechaFinFormacion;\n            } catch (error) {\n              console.warn(`Error creando ficha ${codigoFicha}:`, error.message);\n            }\n          }\n        }\n        \n        // Usar fechas de la ficha si están disponibles, sino usar las del Excel\n        const fechaInicioFinal = fechaInicioDesdeFicha || fechaInicioFormacion;\n        const fechaFinFinal = fechaFinDesdeFicha || fechaFinFormacion;\n\n        if (existing.length > 0) {\n          // La persona ya existe, actualizar en lugar de insertar\n          const personaExistente = existing[0];\n          \n        await pool.execute(\n          `UPDATE Personas \n           SET nombres = ?, apellidos = ?, estado = ?, id_rol = ?, \n               email = COALESCE(?, email), telefono = COALESCE(?, telefono),\n               rh = COALESCE(?, rh),\n               id_ficha = COALESCE(?, id_ficha),\n               id_programa = COALESCE(?, id_programa),\n               fecha_inicio_formacion = ?,\n               fecha_fin_formacion = ?,\n               jornada = COALESCE(?, jornada),\n               cargo = COALESCE(?, cargo),\n               tipo_contrato = COALESCE(?, tipo_contrato),\n               fecha_actualizacion = NOW()\n           WHERE documento = ? AND tipo_documento = ?`,\n          [\n            nombresValue,\n            apellidosValue,\n            estadoFinal,\n            idRol || null,\n            row.email?.toString().trim() || null,\n            row.telefono?.toString().trim() || null,\n            rh,\n            idFicha,\n            idPrograma,\n            fechaInicioFinal,\n            fechaFinFinal,\n            jornada,\n            cargo,\n            tipoContrato,\n            documento,\n            tipoDocumento\n          ]\n        );\n          \n          await this.processRoleSpecificData(personaExistente.id_persona, row, rol);\n          insertedIds.push(personaExistente.id_persona);\n          successful++;\n        } else {\n          // La persona NO existe, insertar nueva\n        const [result] = await pool.execute(\n          `INSERT INTO Personas \n           (id_rol, tipo_documento, documento, nombres, apellidos, estado, email, telefono, foto, \n            rh, id_ficha, id_programa, fecha_inicio_formacion, fecha_fin_formacion, jornada, cargo, tipo_contrato, fecha_registro)\n           VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, NOW())`,\n          [\n            idRol || null,\n            tipoDocumento,\n            documento,\n            nombresValue,\n            apellidosValue,\n            estadoFinal,\n            row.email?.toString().trim() || null,\n            row.telefono?.toString().trim() || null,\n            null,  // foto\n            rh,\n            idFicha,\n            idPrograma,\n            fechaInicioFinal,\n            fechaFinFinal,\n            jornada,\n            cargo,\n            tipoContrato\n          ]\n        );\n\n          await this.processRoleSpecificData(result.insertId, row, rol);\n          insertedIds.push(result.insertId);\n          successful++;\n        }\n      } catch (error) {\n        console.error(`Error insertando fila ${rowIndex + 1} con documento ${row.documento}:`, error);\n        failed++;\n        errors.push({\n          row: rowIndex + 1,\n          field: 'database',\n          message: `Error al insertar: ${error.message}`,\n          documento: row.documento\n        });\n      }\n    }\n\n    return {\n      successful,\n      failed,\n      errors\n    };\n  }\n\n  /**\n   * Procesar datos específicos por rol (asignaciones, ambientes, etc.)\n   */\n  async processRoleSpecificData(personId, row, rol) {\n    try {\n      // Para APRENDICES: Asignar ambiente\n      if (rol === 'aprendiz' && row.ambiente_asignado) {\n        const nombreAmbiente = row.ambiente_asignado.toString().trim();\n        \n        // Buscar ambiente por nombre\n        const [ambientes] = await pool.execute(\n          'SELECT id_ambiente FROM Ambientes WHERE nombre_ambiente LIKE ? OR codigo_ambiente = ? LIMIT 1',\n          [`%${nombreAmbiente}%`, nombreAmbiente]\n        );\n        \n        if (ambientes.length > 0) {\n          const idAmbiente = ambientes[0].id_ambiente;\n          \n          // Verificar si ya existe la asignación\n          const [asignaciones] = await pool.execute(\n            'SELECT id_asignacion FROM Asignaciones_Ambientes WHERE id_persona = ? AND id_ambiente = ?',\n            [personId, idAmbiente]\n          );\n          \n          if (asignaciones.length === 0) {\n            await pool.execute(\n              `INSERT INTO Asignaciones_Ambientes (id_persona, id_ambiente, tipo_asignacion, activa)\n               VALUES (?, ?, 'aprendiz', TRUE)`,\n              [personId, idAmbiente]\n            );\n          }\n        }\n      }\n\n      // Para INSTRUCTORES: Asignar múltiples ambientes\n      if (rol === 'instructor' && row.ambientes_clase) {\n        const ambientesList = row.ambientes_clase.toString().split(',').map(a => a.trim()).filter(a => a);\n        const horarios = row.horarios_clase?.toString().trim() || null;\n        \n        for (const nombreAmbiente of ambientesList) {\n          const [ambientes] = await pool.execute(\n            'SELECT id_ambiente FROM Ambientes WHERE nombre_ambiente LIKE ? OR codigo_ambiente = ? LIMIT 1',\n            [`%${nombreAmbiente}%`, nombreAmbiente]\n          );\n          \n          if (ambientes.length > 0) {\n            const idAmbiente = ambientes[0].id_ambiente;\n            \n            // Verificar si ya existe la asignación\n            const [asignaciones] = await pool.execute(\n              'SELECT id_asignacion FROM Asignaciones_Ambientes WHERE id_persona = ? AND id_ambiente = ?',\n              [personId, idAmbiente]\n            );\n            \n            if (asignaciones.length === 0) {\n              await pool.execute(\n                `INSERT INTO Asignaciones_Ambientes (id_persona, id_ambiente, tipo_asignacion, horario_asignado, activa)\n                 VALUES (?, ?, 'instructor', ?, TRUE)`,\n                [personId, idAmbiente, horarios]\n              );\n            }\n          }\n        }\n      }\n\n      // Para ADMINISTRATIVOS: Asignar ambiente de trabajo\n      if (rol === 'administrativo' && row.ambiente_trabajo) {\n        const nombreAmbiente = row.ambiente_trabajo.toString().trim();\n        \n        const [ambientes] = await pool.execute(\n          'SELECT id_ambiente FROM Ambientes WHERE nombre_ambiente LIKE ? OR codigo_ambiente = ? LIMIT 1',\n          [`%${nombreAmbiente}%`, nombreAmbiente]\n        );\n        \n        if (ambientes.length > 0) {\n          const idAmbiente = ambientes[0].id_ambiente;\n          const horarioOficina = row.horario_oficina?.toString().trim() || null;\n          \n          const [asignaciones] = await pool.execute(\n            'SELECT id_asignacion FROM Asignaciones_Ambientes WHERE id_persona = ? AND id_ambiente = ?',\n            [personId, idAmbiente]\n          );\n          \n          if (asignaciones.length === 0) {\n            await pool.execute(\n              `INSERT INTO Asignaciones_Ambientes (id_persona, id_ambiente, tipo_asignacion, horario_asignado, activa)\n               VALUES (?, ?, 'administrativo', ?, TRUE)`,\n              [personId, idAmbiente, horarioOficina]\n            );\n          }\n        }\n      }\n    } catch (error) {\n      console.error(`Error procesando datos específicos de rol para persona ${personId}:`, error);\n      // No fallar la importación completa por esto\n    }\n  }\n}\n\n"
        }
    ]
}