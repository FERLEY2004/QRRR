{
    "sourceFile": "control-acceso-sena/backend/src/services/ReportService.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1764227629993,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1764232818289,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,7 +1,8 @@\n // Report Service - Servicio de reportes y consultas\n import pool from '../utils/dbPool.js';\n import { CatalogService } from './CatalogService.js';\n+import { getRegistroIdField } from '../utils/columnResolver.js';\n \n export class ReportService {\n   /**\n    * HU9 - Personas actualmente dentro del establecimiento\n@@ -140,14 +141,20 @@\n     try {\n       const fechaDesde = filters.fecha_desde || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n       const fechaHasta = filters.fecha_hasta || new Date().toISOString().split('T')[0];\n \n+      const idColumn = await getRegistroIdField();\n       const query = `\n         SELECT \n-          r.id_registro_entrada_salida as id_acceso,\n+          r.${idColumn} as id_acceso,\n           p.documento,\n           p.tipo_documento,\n-          CONCAT(p.nombres, ' ', p.apellidos, IFNULL(CONCAT('', ''), '')) as nombre_completo,\n+          COALESCE(\n+            CONCAT(p.nombres, ' ', p.apellidos),\n+            p.nombres,\n+            p.apellidos,\n+            'Sin nombre'\n+          ) as nombre_completo,\n           f.codigo_ficha,\n           pf.codigo_programa,\n           pf.nombre_programa,\n           pf.nivel,\n@@ -211,23 +218,24 @@\n     try {\n       const page = pagination.page || 1;\n       const limit = pagination.limit || 50;\n       const offset = (page - 1) * limit;\n+      const idColumn = await getRegistroIdField();\n \n       console.log('üîç [ReportService] Obteniendo historial de accesos con filtros:', filters);\n \n       // Consulta mejorada que calcula fecha_salida y duracion_minutos emparejando ENTRADAS con SALIDAS\n       // Para ENTRADAS: fecha_entrada = r.fecha_hora, fecha_salida = siguiente SALIDA\n       // Para SALIDAS: fecha_entrada = anterior ENTRADA, fecha_salida = r.fecha_hora\n       let query = `\n         SELECT \n-          r.id_registro_entrada_salida as id_acceso,\n+          r.${idColumn} as id_acceso,\n           p.documento,\n           p.tipo_documento,\n           COALESCE(\n             CONCAT(p.nombres, ' ', p.apellidos),\n-            p.nombre,\n-            CONCAT(p.nombres, p.apellidos),\n+            p.nombres,\n+            p.apellidos,\n             'Sin nombre'\n           ) as nombre_completo,\n           COALESCE(role.nombre_rol, 'sin rol') as rol,\n           r.tipo as tipo_acceso,\n"
                },
                {
                    "date": 1764233133677,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n         SELECT \n           vd.id_persona,\n           vd.documento,\n           vd.nombre_completo,\n-          vd.rol,\n+          COALESCE(vd.rol, role.nombre_rol, 'sin rol') as rol,\n           vd.foto,\n           vd.fecha_entrada,\n           vd.minutos_dentro,\n           vd.zona,\n@@ -31,8 +31,9 @@\n           p.email,\n           p.telefono\n         FROM v_personas_dentro vd\n         INNER JOIN Personas p ON vd.id_persona = p.id_persona\n+        LEFT JOIN Roles role ON p.id_rol = role.id_rol\n         WHERE 1=1\n       `;\n \n       const params = [];\n"
                },
                {
                    "date": 1764235547613,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -14,9 +14,9 @@\n         SELECT \n           vd.id_persona,\n           vd.documento,\n           vd.nombre_completo,\n-          COALESCE(vd.rol, role.nombre_rol, 'sin rol') as rol,\n+          COALESCE(vd.nombre_rol, role.nombre_rol, 'sin rol') as rol,\n           vd.foto,\n           vd.fecha_entrada,\n           vd.minutos_dentro,\n           vd.zona,\n@@ -39,9 +39,9 @@\n       const params = [];\n \n       // Filtros opcionales\n       if (filters.rol) {\n-        query += ` AND vd.rol = ?`;\n+        query += ` AND vd.nombre_rol = ?`;\n         params.push(filters.rol);\n       }\n \n       if (filters.zona) {\n"
                },
                {
                    "date": 1764313330454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -19,10 +19,8 @@\n           vd.foto,\n           vd.fecha_entrada,\n           vd.minutos_dentro,\n           vd.zona,\n-          vd.id_visitante,\n-          vd.motivo_visita,\n           CONCAT(\n             LPAD(FLOOR(vd.minutos_dentro / 60), 2, '0'), ':',\n             LPAD(vd.minutos_dentro % 60, 2, '0')\n           ) as tiempo_dentro,\n@@ -68,10 +66,10 @@\n           minutos_dentro: row.minutos_dentro,\n           foto: row.foto,\n           email: row.email,\n           telefono: row.telefono,\n-          esVisitante: !!row.id_visitante,\n-          motivo_visita: row.motivo_visita\n+          esVisitante: false,\n+          motivo_visita: null\n         })),\n         total: rows.length,\n         timestamp: new Date().toISOString()\n       };\n"
                }
            ],
            "date": 1764227629993,
            "name": "Commit-0",
            "content": "// Report Service - Servicio de reportes y consultas\nimport pool from '../utils/dbPool.js';\nimport { CatalogService } from './CatalogService.js';\n\nexport class ReportService {\n  /**\n   * HU9 - Personas actualmente dentro del establecimiento\n   * Usa la vista v_personas_dentro que implementa la l√≥gica de circuito abierto\n   */\n  static async getCurrentPeople(filters = {}) {\n    try {\n      let query = `\n        SELECT \n          vd.id_persona,\n          vd.documento,\n          vd.nombre_completo,\n          vd.rol,\n          vd.foto,\n          vd.fecha_entrada,\n          vd.minutos_dentro,\n          vd.zona,\n          vd.id_visitante,\n          vd.motivo_visita,\n          CONCAT(\n            LPAD(FLOOR(vd.minutos_dentro / 60), 2, '0'), ':',\n            LPAD(vd.minutos_dentro % 60, 2, '0')\n          ) as tiempo_dentro,\n          TIMESTAMPDIFF(SECOND, vd.fecha_entrada, NOW()) as tiempo_segundos,\n          p.tipo_documento,\n          p.email,\n          p.telefono\n        FROM v_personas_dentro vd\n        INNER JOIN Personas p ON vd.id_persona = p.id_persona\n        WHERE 1=1\n      `;\n\n      const params = [];\n\n      // Filtros opcionales\n      if (filters.rol) {\n        query += ` AND vd.rol = ?`;\n        params.push(filters.rol);\n      }\n\n      if (filters.zona) {\n        query += ` AND vd.zona LIKE ?`;\n        params.push(`%${filters.zona}%`);\n      }\n\n      query += ` ORDER BY vd.fecha_entrada DESC`;\n\n      const [rows] = await pool.execute(query, params);\n\n      return {\n        success: true,\n        data: rows.map(row => ({\n          id: row.id_persona,\n          documento: row.documento,\n          tipo_documento: row.tipo_documento,\n          nombre_completo: row.nombre_completo,\n          rol: row.rol,\n          zona: row.zona || 'Bloque Principal',\n          fecha_entrada: row.fecha_entrada,\n          tiempo_dentro: row.tiempo_dentro,\n          tiempo_segundos: row.tiempo_segundos,\n          minutos_dentro: row.minutos_dentro,\n          foto: row.foto,\n          email: row.email,\n          telefono: row.telefono,\n          esVisitante: !!row.id_visitante,\n          motivo_visita: row.motivo_visita\n        })),\n        total: rows.length,\n        timestamp: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Error en getCurrentPeople:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * HU7 - Flujos predictivos (an√°lisis de patrones)\n   */\n  static async getPredictiveFlows(filters = {}) {\n    try {\n      const dias = filters.dias || 7;\n      const fechaFin = filters.fecha_hasta || new Date().toISOString().split('T')[0];\n      const fechaInicio = filters.fecha_desde || new Date(Date.now() - dias * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n\n      const query = `\n        SELECT \n          HOUR(r.fecha_hora) as hora,\n          DAYNAME(r.fecha_hora) as dia_semana,\n          COUNT(*) as frecuencia,\n          AVG(TIMESTAMPDIFF(MINUTE, r.fecha_hora, COALESCE(r2.fecha_hora, NOW()))) as tiempo_promedio_minutos,\n          COALESCE(role.nombre_rol, 'sin rol') as nombre_rol\n        FROM registros_entrada_salida r\n        LEFT JOIN registros_entrada_salida r2 \n          ON r2.id_persona = r.id_persona \n          AND r2.tipo = 'SALIDA'\n          AND r2.fecha_hora > r.fecha_hora\n        INNER JOIN Personas p ON r.id_persona = p.id_persona\n        LEFT JOIN Roles role ON p.id_rol = role.id_rol\n        WHERE DATE(r.fecha_hora) BETWEEN ? AND ?\n          AND (p.estado = 'activo' OR p.estado = 'ACTIVO')\n        GROUP BY HOUR(r.fecha_hora), DAYNAME(r.fecha_hora), role.nombre_rol\n        ORDER BY frecuencia DESC\n        LIMIT 100\n      `;\n\n      const [rows] = await pool.execute(query, [fechaInicio, fechaFin]);\n\n      return {\n        success: true,\n        data: rows.map(row => ({\n          hora: row.hora,\n          dia_semana: row.dia_semana,\n          frecuencia: parseInt(row.frecuencia) || 0,\n          tiempo_promedio_minutos: Math.round(row.tiempo_promedio_minutos || 0),\n        rol: row.nombre_rol\n        })),\n        periodo: {\n          fecha_desde: fechaInicio,\n          fecha_hasta: fechaFin,\n          dias: dias\n        },\n        generated_at: new Date().toISOString()\n      };\n    } catch (error) {\n      console.error('Error en getPredictiveFlows:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Reporte de accesos por programa espec√≠fico\n   */\n  static async getAccessByProgram(codigoPrograma, filters = {}) {\n    try {\n      const fechaDesde = filters.fecha_desde || new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString().split('T')[0];\n      const fechaHasta = filters.fecha_hasta || new Date().toISOString().split('T')[0];\n\n      const query = `\n        SELECT \n          r.id_registro_entrada_salida as id_acceso,\n          p.documento,\n          p.tipo_documento,\n          CONCAT(p.nombres, ' ', p.apellidos, IFNULL(CONCAT('', ''), '')) as nombre_completo,\n          f.codigo_ficha,\n          pf.codigo_programa,\n          pf.nombre_programa,\n          pf.nivel,\n          r.tipo as tipo_acceso,\n          r.fecha_hora as fecha_entrada,\n          NULL as fecha_salida,\n          TIMESTAMPDIFF(MINUTE, r.fecha_hora, NOW()) as duracion_minutos,\n          CASE \n            WHEN r.tipo = 'ENTRADA' THEN 'activo'\n            ELSE 'finalizado'\n          END as estado\n        FROM registros_entrada_salida r\n        INNER JOIN Personas p ON r.id_persona = p.id_persona\n        LEFT JOIN fichas f ON p.id_ficha = f.id_ficha\n        LEFT JOIN programas_formacion pf ON f.id_programa = pf.id_programa\n        WHERE pf.codigo_programa = ?\n          AND DATE(r.fecha_hora) BETWEEN ? AND ?\n          AND (p.estado = 'activo' OR p.estado = 'ACTIVO')\n        ORDER BY r.fecha_hora DESC\n      `;\n\n      const [rows] = await pool.execute(query, [codigoPrograma, fechaDesde, fechaHasta]);\n\n      const estadisticas = {\n        total_accesos: rows.length,\n        entradas: rows.filter(r => r.tipo_acceso === 'entrada').length,\n        salidas: rows.filter(r => r.tipo_acceso === 'salida').length,\n        aprendices_unicos: new Set(rows.map(r => r.documento)).size,\n        tiempo_promedio_minutos: rows.length > 0\n          ? Math.round(rows.reduce((sum, r) => sum + (r.duracion_minutos || 0), 0) / rows.length)\n          : 0\n      };\n\n      return {\n        success: true,\n        data: rows,\n        estadisticas,\n        programa: rows[0] ? {\n          codigo: rows[0].codigo_programa,\n          nombre: rows[0].nombre_programa,\n          nivel: rows[0].nivel\n        } : null,\n        periodo: {\n          fecha_desde: fechaDesde,\n          fecha_hasta: fechaHasta\n        }\n      };\n    } catch (error) {\n      console.error('Error en getAccessByProgram:', error);\n      throw error;\n    }\n  }\n\n\n  /**\n   * Historial de accesos con filtros avanzados\n   * Usa registros_entrada_salida (circuito abierto)\n   * Calcula fecha_salida y duracion_minutos emparejando ENTRADAS con SALIDAS\n   */\n  static async getAccessHistory(filters = {}, pagination = {}) {\n    try {\n      const page = pagination.page || 1;\n      const limit = pagination.limit || 50;\n      const offset = (page - 1) * limit;\n\n      console.log('üîç [ReportService] Obteniendo historial de accesos con filtros:', filters);\n\n      // Consulta mejorada que calcula fecha_salida y duracion_minutos emparejando ENTRADAS con SALIDAS\n      // Para ENTRADAS: fecha_entrada = r.fecha_hora, fecha_salida = siguiente SALIDA\n      // Para SALIDAS: fecha_entrada = anterior ENTRADA, fecha_salida = r.fecha_hora\n      let query = `\n        SELECT \n          r.id_registro_entrada_salida as id_acceso,\n          p.documento,\n          p.tipo_documento,\n          COALESCE(\n            CONCAT(p.nombres, ' ', p.apellidos),\n            p.nombre,\n            CONCAT(p.nombres, p.apellidos),\n            'Sin nombre'\n          ) as nombre_completo,\n          COALESCE(role.nombre_rol, 'sin rol') as rol,\n          r.tipo as tipo_acceso,\n          CASE \n            WHEN r.tipo = 'ENTRADA' THEN r.fecha_hora\n            WHEN r.tipo = 'SALIDA' THEN (\n              SELECT r2.fecha_hora \n              FROM registros_entrada_salida r2 \n              WHERE r2.id_persona = r.id_persona \n                AND r2.tipo = 'ENTRADA' \n                AND r2.fecha_hora < r.fecha_hora\n              ORDER BY r2.fecha_hora DESC\n              LIMIT 1\n            )\n            ELSE r.fecha_hora\n          END as fecha_entrada,\n          CASE \n            WHEN r.tipo = 'ENTRADA' THEN (\n              SELECT r2.fecha_hora \n              FROM registros_entrada_salida r2 \n              WHERE r2.id_persona = r.id_persona \n                AND r2.tipo = 'SALIDA' \n                AND r2.fecha_hora > r.fecha_hora\n              ORDER BY r2.fecha_hora ASC\n              LIMIT 1\n            )\n            WHEN r.tipo = 'SALIDA' THEN r.fecha_hora\n            ELSE NULL\n          END as fecha_salida,\n          CASE \n            WHEN r.tipo = 'ENTRADA' THEN (\n              SELECT TIMESTAMPDIFF(MINUTE, r.fecha_hora, r2.fecha_hora)\n              FROM registros_entrada_salida r2 \n              WHERE r2.id_persona = r.id_persona \n                AND r2.tipo = 'SALIDA' \n                AND r2.fecha_hora > r.fecha_hora\n              ORDER BY r2.fecha_hora ASC\n              LIMIT 1\n            )\n            WHEN r.tipo = 'SALIDA' THEN (\n              SELECT TIMESTAMPDIFF(MINUTE, r2.fecha_hora, r.fecha_hora)\n              FROM registros_entrada_salida r2 \n              WHERE r2.id_persona = r.id_persona \n                AND r2.tipo = 'ENTRADA' \n                AND r2.fecha_hora < r.fecha_hora\n              ORDER BY r2.fecha_hora DESC\n              LIMIT 1\n            )\n            ELSE NULL\n          END as duracion_minutos,\n          CASE \n            WHEN r.tipo = 'ENTRADA' AND EXISTS (\n              SELECT 1 \n              FROM registros_entrada_salida r2 \n              WHERE r2.id_persona = r.id_persona \n                AND r2.tipo = 'SALIDA' \n                AND r2.fecha_hora > r.fecha_hora\n            ) THEN 'finalizado'\n            WHEN r.tipo = 'ENTRADA' THEN 'activo'\n            WHEN r.tipo = 'SALIDA' THEN 'finalizado'\n            ELSE 'activo'\n          END as estado,\n          'Sistema' as registrado_por\n        FROM registros_entrada_salida r\n        LEFT JOIN Personas p ON r.id_persona = p.id_persona\n        LEFT JOIN Roles role ON p.id_rol = role.id_rol\n        WHERE 1=1\n      `;\n\n      const params = [];\n\n      if (filters.fecha_desde) {\n        query += ` AND DATE(r.fecha_hora) >= ?`;\n        params.push(filters.fecha_desde);\n      }\n\n      if (filters.fecha_hasta) {\n        query += ` AND DATE(r.fecha_hora) <= ?`;\n        params.push(filters.fecha_hasta);\n      }\n\n      if (filters.documento) {\n        query += ` AND p.documento LIKE ?`;\n        params.push(`%${filters.documento}%`);\n      }\n\n      if (filters.rol) {\n        query += ` AND role.nombre_rol = ?`;\n        params.push(filters.rol);\n      }\n\n      if (filters.tipo_acceso) {\n        query += ` AND r.tipo = ?`;\n        params.push(filters.tipo_acceso);\n      }\n\n      // Contar total para paginaci√≥n\n      let countQuery = `\n        SELECT COUNT(*) as total\n        FROM registros_entrada_salida r\n        LEFT JOIN Personas p ON r.id_persona = p.id_persona\n        LEFT JOIN Roles role ON p.id_rol = role.id_rol\n        WHERE 1=1\n      `;\n      const countParams = [];\n      \n      // Aplicar los mismos filtros al COUNT\n      if (filters.fecha_desde) {\n        countQuery += ` AND DATE(r.fecha_hora) >= ?`;\n        countParams.push(filters.fecha_desde);\n      }\n      \n      if (filters.fecha_hasta) {\n        countQuery += ` AND DATE(r.fecha_hora) <= ?`;\n        countParams.push(filters.fecha_hasta);\n      }\n      \n      if (filters.documento) {\n        countQuery += ` AND p.documento LIKE ?`;\n        countParams.push(`%${filters.documento}%`);\n      }\n      \n      if (filters.rol) {\n        countQuery += ` AND role.nombre_rol = ?`;\n        countParams.push(filters.rol);\n      }\n      \n      if (filters.tipo_acceso) {\n        countQuery += ` AND r.tipo = ?`;\n        countParams.push(filters.tipo_acceso);\n      }\n\n      const [countRows] = await pool.execute(countQuery, countParams);\n      const total = countRows[0]?.total || 0;\n\n      // Agregar ordenamiento y paginaci√≥n\n      const safeLimit = Math.max(1, Math.min(parseInt(limit) || 50, 1000));\n      const safeOffset = Math.max(0, parseInt(offset) || 0);\n      query += ` ORDER BY r.fecha_hora DESC LIMIT ${safeLimit} OFFSET ${safeOffset}`;\n\n      console.log('üìù [ReportService] Ejecutando consulta SQL para historial de accesos...');\n      const [rows] = await pool.execute(query, params);\n      \n      console.log(`‚úÖ [ReportService] Consulta exitosa: ${rows.length} registros obtenidos`);\n\n      // Procesar datos para asegurar formato correcto\n      const processedRows = rows.map((row, index) => {\n        try {\n          const processed = {\n            id_acceso: row.id_acceso,\n            documento: row.documento || 'N/A',\n            tipo_documento: row.tipo_documento || null,\n            nombre_completo: row.nombre_completo || 'Sin nombre',\n            rol: row.rol || 'sin rol',\n            tipo_acceso: row.tipo_acceso,\n            fecha_entrada: row.fecha_entrada ? new Date(row.fecha_entrada).toISOString() : null,\n            fecha_salida: row.fecha_salida ? new Date(row.fecha_salida).toISOString() : null,\n            duracion_minutos: row.duracion_minutos !== null && row.duracion_minutos !== undefined \n              ? parseInt(row.duracion_minutos) \n              : null,\n            estado: row.estado || 'activo',\n            registrado_por: row.registrado_por || 'Sistema'\n          };\n          \n          if (index === 0) {\n            console.log(`üìã [ReportService] Primer registro procesado:`, JSON.stringify(processed, null, 2));\n          }\n          \n          return processed;\n        } catch (error) {\n          console.error(`‚ùå [ReportService] Error procesando registro ${index + 1}:`, error.message);\n          return null;\n        }\n      }).filter(row => row !== null);\n      \n      const withFechaSalida = processedRows.filter(r => r.fecha_salida).length;\n      const withDuracion = processedRows.filter(r => r.duracion_minutos !== null).length;\n      \n      console.log(`üìä [ReportService] Estad√≠sticas de procesamiento:`);\n      console.log(`   - Registros procesados: ${processedRows.length}`);\n      console.log(`   - Con fecha_salida: ${withFechaSalida}`);\n      console.log(`   - Con duracion_minutos: ${withDuracion}`);\n\n      return {\n        success: true,\n        data: processedRows,\n        pagination: {\n          total: total,\n          page: page,\n          limit: limit,\n          totalPages: Math.ceil(total / limit)\n        },\n        filters: filters,\n        metadata: {\n          registros_con_fecha_salida: withFechaSalida,\n          registros_con_duracion: withDuracion\n        }\n      };\n    } catch (error) {\n      console.error('Error en getAccessHistory:', error);\n      console.error('Error stack:', error.stack);\n      console.error('Error message:', error.message);\n      console.error('Error SQL:', error.sql);\n      throw error;\n    }\n  }\n}\n\n"
        }
    ]
}