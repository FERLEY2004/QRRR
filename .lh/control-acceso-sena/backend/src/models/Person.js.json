{
    "sourceFile": "control-acceso-sena/backend/src/models/Person.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764230575589,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764230575589,
            "name": "Commit-0",
            "content": "// Person Model\nimport pool from '../utils/dbPool.js';\n\nexport default class Person {\n  // Buscar persona por documento\n  static async findByDocument(documento) {\n    const [rows] = await pool.execute(\n      `SELECT p.*, r.nombre_rol \n       FROM personas p\n       LEFT JOIN roles r ON p.id_rol = r.id_rol\n       WHERE p.documento = ? AND p.estado = 'ACTIVO'`,\n      [documento]\n    );\n    return rows[0];\n  }\n\n  // Buscar persona por ID\n  static async findById(id) {\n    const [rows] = await pool.execute(\n      `SELECT p.*, r.nombre_rol \n       FROM personas p\n       LEFT JOIN roles r ON p.id_rol = r.id_rol\n       WHERE p.id_persona = ?`,\n      [id]\n    );\n    return rows[0];\n  }\n\n  // Obtener todas las personas activas dentro del centro (circuito abierto)\n  static async getCurrentPeople() {\n    try {\n      // Usar la vista v_personas_dentro que implementa la lógica de circuito abierto\n      const [rows] = await pool.execute(\n        `SELECT * FROM v_personas_dentro\n         ORDER BY fecha_entrada DESC`\n      );\n      return rows || [];\n    } catch (error) {\n      // Si la vista no existe, calcular manualmente usando la lógica de circuito abierto\n      if (error.code === 'ER_NO_SUCH_TABLE' || error.message?.includes('doesn\\'t exist')) {\n        console.warn('⚠️  Vista v_personas_dentro no existe, calculando manualmente...');\n        try {\n          const [rows] = await pool.execute(\n            `SELECT \n              p.id_persona,\n              CONCAT(p.nombres, ' ', p.apellidos) as nombre_completo,\n              p.documento,\n              rol_tabla.nombre_rol,\n              p.foto,\n              r.fecha_hora as fecha_entrada,\n              TIMESTAMPDIFF(MINUTE, r.fecha_hora, NOW()) as minutos_dentro\n            FROM personas p\n            INNER JOIN registros_entrada_salida r ON p.id_persona = r.id_persona\n            LEFT JOIN roles rol_tabla ON p.id_rol = rol_tabla.id_rol\n            WHERE r.tipo = 'ENTRADA'\n              AND r.fecha_hora = (\n                SELECT MAX(fecha_hora) \n                FROM registros_entrada_salida \n                WHERE id_persona = p.id_persona\n              )\n              AND NOT EXISTS (\n                SELECT 1 \n                FROM registros_entrada_salida r2 \n                WHERE r2.id_persona = p.id_persona \n                  AND r2.tipo = 'SALIDA' \n                  AND r2.fecha_hora > r.fecha_hora\n              )\n              AND p.estado = 'ACTIVO'\n            ORDER BY r.fecha_hora DESC`\n          );\n          return rows || [];\n        } catch (fallbackError) {\n          console.error('❌ Error calculando personas dentro manualmente:', fallbackError.message);\n          return [];\n        }\n      }\n      console.error('❌ Error obteniendo personas dentro:', error.message);\n      return [];\n    }\n  }\n\n  // Verificar si una persona está dentro (circuito abierto)\n  static async isInside(personId) {\n    // Verificar si la última acción fue ENTRADA sin SALIDA posterior\n    const [rows] = await pool.execute(\n      `SELECT tipo, fecha_hora\n       FROM registros_entrada_salida\n       WHERE id_persona = ?\n       ORDER BY fecha_hora DESC\n       LIMIT 1`,\n      [personId]\n    );\n    \n    if (rows.length === 0) {\n      return false;\n    }\n    \n    const ultimoRegistro = rows[0];\n    \n    // Si el último registro es ENTRADA, está dentro\n    if (ultimoRegistro.tipo === 'ENTRADA') {\n      // Verificar que no haya una SALIDA posterior\n      const [salidaRows] = await pool.execute(\n        `SELECT 1 FROM registros_entrada_salida\n         WHERE id_persona = ? AND tipo = 'SALIDA' AND fecha_hora > ?\n         LIMIT 1`,\n        [personId, ultimoRegistro.fecha_hora]\n      );\n      return salidaRows.length === 0;\n    }\n    \n    return false;\n  }\n\n  // Buscar persona por documento sin filtrar por estado\n  static async findByDocumentAnyStatus(documento, tipo_documento = 'CC') {\n    const [rows] = await pool.execute(\n      `SELECT p.*, r.nombre_rol \n       FROM personas p\n       LEFT JOIN roles r ON p.id_rol = r.id_rol\n       WHERE p.documento = ? AND p.tipo_documento = ?`,\n      [documento, tipo_documento.toUpperCase()]\n    );\n    return rows[0];\n  }\n\n  // Crear una nueva persona automáticamente\n    static async create(personData) {\n    try {\n      const {\n        nombre,\n        nombres,\n        apellidos,\n        documento,\n        tipo_documento = 'CC',\n        rol = 'aprendiz',\n        email = null,\n        telefono = null,\n        foto = null\n      } = personData;\n\n      const nameParts = (nombre || '').trim().split(' ').filter(Boolean);\n      const nombresValue = nombres?.trim() || (nameParts.length > 1 ? nameParts.slice(0, -1).join(' ') : nombre?.trim() || 'Visitante');\n      const apellidosValue = apellidos?.trim() || (nameParts.length > 1 ? nameParts.slice(-1).join(' ') : 'Visitante');\n\n      // Validar datos requeridos\n      const hasName = !!(nombres?.trim() || apellidos?.trim() || nombre?.trim());\n      if (!documento || !hasName) {\n        throw new Error('Nombre y documento son requeridos');\n      }\n\n      // Verificar si ya existe (incluso si está inactivo)\n      const existingPerson = await this.findByDocumentAnyStatus(documento, tipo_documento);\n      \n      if (existingPerson) {\n        // Si existe pero está inactivo, reactivarlo y actualizar información\n        if (existingPerson.estado !== 'activo') {\n          // Obtener el ID del rol\n        const [roleRows] = await pool.execute(\n            'SELECT id_rol FROM roles WHERE nombre_rol = ? LIMIT 1',\n            [rol.toUpperCase()]\n          );\n          const idRol = roleRows.length > 0 ? roleRows[0].id_rol : null;\n\n          // Reactivar y actualizar información\n          await pool.execute(\n            `UPDATE personas \n             SET nombres = ?, apellidos = ?, id_rol = ?, estado = 'ACTIVO', \n                 email = COALESCE(?, email), telefono = COALESCE(?, telefono), \n                 foto = COALESCE(?, foto), fecha_actualizacion = NOW()\n             WHERE id_persona = ?`,\n            [nombresValue, apellidosValue, idRol, email, telefono, foto, existingPerson.id_persona]\n          );\n\n          // Obtener la persona actualizada\n          const updatedPerson = await this.findById(existingPerson.id_persona);\n          return updatedPerson;\n        } else {\n          // Ya existe y está activo, retornar la persona existente\n          return existingPerson;\n        }\n      }\n\n      // Obtener el ID del rol\n      const [roleRows] = await pool.execute(\n        'SELECT id_rol FROM roles WHERE nombre_rol = ? LIMIT 1',\n        [rol.toUpperCase()]\n      );\n      const idRol = roleRows.length > 0 ? roleRows[0].id_rol : null;\n\n      // Insertar la nueva persona\n      const [result] = await pool.execute(\n        `INSERT INTO personas (nombres, apellidos, documento, tipo_documento, id_rol, estado, email, telefono, foto, fecha_registro)\n         VALUES (?, ?, ?, ?, ?, 'ACTIVO', ?, ?, ?, NOW())`,\n        [nombresValue, apellidosValue, documento, tipo_documento.toUpperCase(), idRol, email, telefono, foto]\n      );\n\n      // Obtener la persona creada con su rol\n      const createdPerson = await this.findById(result.insertId);\n      return createdPerson;\n    } catch (error) {\n      console.error('Error creando persona:', error);\n      throw error;\n    }\n  }\n}\n"
        }
    ]
}