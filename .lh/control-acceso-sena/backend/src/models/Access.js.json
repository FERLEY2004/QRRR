{
    "sourceFile": "control-acceso-sena/backend/src/models/Access.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1764227373242,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1764227373241,
            "name": "Commit-0",
            "content": "// Access Model - Sistema de Circuito Abierto\nimport pool from '../utils/dbPool.js';\n\nexport default class Access {\n  // Registrar entrada (circuito abierto)\n  static async registerEntry(personId, userId = null, tipoAcceso = 'ENTRADA') {\n    const [result] = await pool.execute(\n      `INSERT INTO registros_entrada_salida (id_persona, tipo, fecha_hora)\n       VALUES (?, ?, NOW())`,\n      [personId, 'ENTRADA']\n    );\n    return result.insertId;\n  }\n\n  // Registrar salida (circuito abierto)\n  static async registerExit(personId, userId = null) {\n    // En circuito abierto, simplemente insertamos un registro de SALIDA\n    const [result] = await pool.execute(\n      `INSERT INTO registros_entrada_salida (id_persona, tipo, fecha_hora)\n       VALUES (?, ?, NOW())`,\n      [personId, 'SALIDA']\n    );\n    // Retornar true para compatibilidad con código existente que espera booleano\n    return result.insertId > 0;\n  }\n\n  // Obtener historial de accesos de una persona\n  static async getHistoryByPerson(personId, limit = 10) {\n    const [rows] = await pool.execute(\n      `SELECT r.*, p.nombre, p.documento\n       FROM registros_entrada_salida r\n       INNER JOIN Personas p ON r.id_persona = p.id_persona\n       WHERE r.id_persona = ?\n       ORDER BY r.fecha_hora DESC\n       LIMIT ?`,\n      [personId, limit]\n    );\n    return rows;\n  }\n\n  // Obtener estadísticas del día\n  static async getDailyStats(date = null) {\n    const targetDate = date || new Date().toISOString().split('T')[0];\n    \n    // Estadísticas usando registros_entrada_salida (circuito abierto)\n    let accessRows;\n    try {\n      [accessRows] = await pool.execute(\n        `SELECT \n          COUNT(*) as total_registros,\n          COUNT(CASE WHEN tipo = 'ENTRADA' THEN 1 END) as entradas,\n          COUNT(CASE WHEN tipo = 'SALIDA' THEN 1 END) as salidas\n         FROM registros_entrada_salida\n         WHERE DATE(fecha_hora) = ?`,\n        [targetDate]\n      );\n    } catch (error) {\n      console.warn('⚠️  Error obteniendo estadísticas del día, usando valores por defecto:', error.message);\n      accessRows = [{ total_registros: 0, entradas: 0, salidas: 0 }];\n    }\n    \n    // Personas actualmente dentro (usando vista) - con manejo de errores\n    let personasDentro = 0;\n    try {\n      const [insideRows] = await pool.execute(\n        `SELECT COUNT(*) as personas_dentro\n         FROM v_personas_dentro`\n      );\n      personasDentro = insideRows[0]?.personas_dentro || 0;\n    } catch (error) {\n      // Si la vista no existe, calcular manualmente\n      if (error.code === 'ER_NO_SUCH_TABLE' || error.message?.includes('doesn\\'t exist')) {\n        console.warn('⚠️  Vista v_personas_dentro no existe, calculando manualmente...');\n        try {\n          const [insideRows] = await pool.execute(\n            `SELECT COUNT(DISTINCT p.id_persona) as personas_dentro\n             FROM Personas p\n             INNER JOIN registros_entrada_salida r ON p.id_persona = r.id_persona\n             WHERE r.tipo = 'ENTRADA'\n               AND r.fecha_hora = (\n                 SELECT MAX(fecha_hora) \n                 FROM registros_entrada_salida \n                 WHERE id_persona = p.id_persona\n               )\n               AND NOT EXISTS (\n                 SELECT 1 \n                 FROM registros_entrada_salida r2 \n                 WHERE r2.id_persona = p.id_persona \n                   AND r2.tipo = 'SALIDA' \n                   AND r2.fecha_hora > r.fecha_hora\n               )\n               AND (p.estado = 'ACTIVO' OR p.estado = 'activo')`\n          );\n          personasDentro = insideRows[0]?.personas_dentro || 0;\n        } catch (fallbackError) {\n          console.warn('⚠️  Error calculando personas dentro manualmente, usando 0:', fallbackError.message);\n          personasDentro = 0;\n        }\n      } else {\n        console.warn('⚠️  Error obteniendo personas dentro, usando 0:', error.message);\n        personasDentro = 0;\n      }\n    }\n    \n    // Estadísticas de visitantes del día - probar ambos nombres de tabla\n    let visitorsCount = 0;\n    try {\n      try {\n        // Intentar con Visitantes (mayúscula) primero\n        const [visitorRows] = await pool.execute(\n          `SELECT COUNT(*) as visitantes\n           FROM Visitantes\n           WHERE DATE(fecha_inicio) = ?`,\n          [targetDate]\n        );\n        visitorsCount = visitorRows[0]?.visitantes || 0;\n      } catch (error) {\n        // Si falla, intentar con visitantes (minúscula)\n        if (error.code === 'ER_NO_SUCH_TABLE') {\n          const [visitorRows] = await pool.execute(\n            `SELECT COUNT(*) as visitantes\n             FROM visitantes\n             WHERE DATE(fecha_inicio) = ?`,\n            [targetDate]\n          );\n          visitorsCount = visitorRows[0]?.visitantes || 0;\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      console.warn('⚠️  Error obteniendo estadísticas de visitantes, usando 0:', error.message);\n      visitorsCount = 0;\n    }\n    \n    return {\n      total_registros: accessRows[0]?.total_registros || 0,\n      personas_dentro: personasDentro,\n      entradas: accessRows[0]?.entradas || 0,\n      salidas: accessRows[0]?.salidas || 0,\n      visitantes: visitorsCount\n    };\n  }\n}\n"
        }
    ]
}